{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"themes/fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":1,"renderable":1},{"_id":"themes/fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"themes/fluid/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/default.png","path":"img/default.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/fluid.png","path":"img/fluid.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/boot.js","path":"js/boot.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/events.js","path":"js/events.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/plugins.js","path":"js/plugins.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":1,"renderable":1},{"_id":"source/img/bg/IMG_0048.jpg","path":"img/bg/IMG_0048.jpg","modified":1,"renderable":0},{"_id":"source/img/bg/hs.jpg","path":"img/bg/hs.jpg","modified":1,"renderable":0},{"_id":"source/img/logo/1.svg","path":"img/logo/1.svg","modified":1,"renderable":0},{"_id":"source/img/logo/2.svg","path":"img/logo/2.svg","modified":1,"renderable":0},{"_id":"source/img/logo/3.svg","path":"img/logo/3.svg","modified":1,"renderable":0},{"_id":"source/img/logo/4.svg","path":"img/logo/4.svg","modified":1,"renderable":0},{"_id":"source/img/logo/5.svg","path":"img/logo/5.svg","modified":1,"renderable":0},{"_id":"source/img/logo/6.svg","path":"img/logo/6.svg","modified":1,"renderable":0}],"Cache":[{"_id":"source/_posts/JS正则表达式入门.md","hash":"bb915f1926e800f7996b1c38cc648645b9082e3b","modified":1677828465145},{"_id":"source/_posts/BFC.md","hash":"645d64787a7732849b99fc48a861c726072c4e13","modified":1677828616732},{"_id":"source/_posts/meetOrSlice算法.md","hash":"7b52f149056bffeed44045cd8d183b4325e7843e","modified":1677828948536},{"_id":"source/_posts/浅谈计算机字体.md","hash":"c90c3a97ebfa222f7546107c5464535a0a555268","modified":1677836883147},{"_id":"source/_posts/.DS_Store","hash":"670024bfb11293f243788571e4f12ba139af059a","modified":1677848458260},{"_id":"source/.DS_Store","hash":"01430583e3ff27df117bfcaee6b47641af99d6ea","modified":1677593924491},{"_id":"source/_posts/this指针.md","hash":"fdd08363133fd5cb4467b8495b34414d03ba13d1","modified":1677593466990},{"_id":"source/_posts/浏览器同源策略.md","hash":"fdc5bd4b2a1fffcb1bce37655d7e46e149dbd0fd","modified":1677848952857},{"_id":"source/_posts/浏览器缓存策略.md","hash":"a48d7a5b0a6e10389e787b7d78099f974b96bdbc","modified":1677848217902},{"_id":"source/_data/languages/zh-CN.yml","hash":"c599e877fed87314ea11506e4baae172174ec7d0","modified":1677584941689},{"_id":"source/css/custom.css","hash":"84e983991f440cd2a282f11f88a2c395bfd89f81","modified":1677593004128},{"_id":"source/img/.DS_Store","hash":"bf60020995406914b5a3d8e3a28fd0fe394844df","modified":1677827624124},{"_id":"source/about/index.md","hash":"f123433aceb7db7d731ffb292fca0cd29c93b335","modified":1677584941690},{"_id":"source/_posts/BFC/3.png","hash":"8fb6222d1feea83b6ab412344751ab25a044f570","modified":1677353610000},{"_id":"source/_posts/this指针/5.png","hash":"fd61bf1fd530634f075d34a429a8e05d952ba73e","modified":1677353488000},{"_id":"source/img/logo/3.svg","hash":"937b51c28f5ed6fa47857bb65bb6a5a0314b6c4f","modified":1677593837000},{"_id":"source/img/logo/2.svg","hash":"88f5a0e6e613c12943d698e7492c3d6ed61b98b0","modified":1677593828000},{"_id":"source/img/logo/1.svg","hash":"bf2a45c4f41c35d941f5eb30940e250299e08660","modified":1677593817000},{"_id":"source/img/logo/5.svg","hash":"72285272ff64ebf1c6217cdd385540d0f62c1185","modified":1677593878000},{"_id":"source/img/logo/4.svg","hash":"dbdbb40cae8cc20892b96aa63813924ecf669e29","modified":1677593878000},{"_id":"source/img/logo/6.svg","hash":"27a5067ec922e13ba296d59d8db1b1094f6ccd1c","modified":1677593878000},{"_id":"source/_posts/BFC/5.png","hash":"d587bf92b5eda087c53ff3a21c0c41a2836bee18","modified":1677353610000},{"_id":"source/_posts/this指针/4.png","hash":"3f45edec62ac2357acd4449f12d6fd0c40b839ba","modified":1677353488000},{"_id":"source/_posts/this指针/1.png","hash":"010df365706510909bc5fb151f2c2a5d1d5eadff","modified":1677353488000},{"_id":"source/_posts/BFC/4.png","hash":"21c3a89ffccbdbfc9fd8c6217592a25b6fd76b3d","modified":1677353610000},{"_id":"source/_posts/BFC/2.png","hash":"1c89eadcb4b80ecf675954b0f808f099b87c9d68","modified":1677353610000},{"_id":"source/_posts/BFC/1.png","hash":"c74117161d65f282743ec87fb7de4b0891510ca9","modified":1677353610000},{"_id":"source/_posts/this指针/2.png","hash":"d2547baea38a606ff1c2a1f027f1ef5df76ca4da","modified":1677353488000},{"_id":"source/_posts/this指针/8.png","hash":"726563949c0a2fc722403013084db32aba631183","modified":1677582808292},{"_id":"source/_posts/this指针/7.png","hash":"e1feae3c2bc356cf78a8bb53d15c07fca193caaf","modified":1677580951815},{"_id":"source/_posts/this指针/3.png","hash":"a11c9c33db0dde6e4fafe2ff59db71b414992f55","modified":1677353488000},{"_id":"source/_posts/浏览器同源策略/1.png","hash":"212abda7729277e82e7b6bd3e69664726dec6b75","modified":1677468870000},{"_id":"source/img/bg/IMG_0048.jpg","hash":"1c382f0021da5b56deb1cc97c5b5f27c19bb4751","modified":1677584941692},{"_id":"source/_posts/浏览器同源策略/3.png","hash":"5d99263ab48a715f58d80e3c197f202e2fa0a8e3","modified":1677468870000},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1677596204437},{"_id":"themes/fluid/package.json","hash":"30e3f4ccfef8474c05cf0b1eb02e91bd0a152807","modified":1677596203698},{"_id":"themes/fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":1677596203521},{"_id":"themes/fluid/README.md","hash":"6d752df6f2278033dc2512a7d5be22c8a8eb665a","modified":1677596203543},{"_id":"themes/fluid/languages/en.yml","hash":"cb11b39f44ea069652c9647179606b6cecc98d50","modified":1677596203548},{"_id":"themes/fluid/_config.yml","hash":"088788e149051fc0a3c6096ba95e35a8344de04b","modified":1677596203545},{"_id":"themes/fluid/languages/de.yml","hash":"0e7d455d9e004ff15d8924b7a0c35cea25ee5b1d","modified":1677596203547},{"_id":"themes/fluid/languages/eo.yml","hash":"a556251cc50a5680578c03f1efbf252b1f4ab860","modified":1677596203550},{"_id":"themes/fluid/languages/es.yml","hash":"7112594259c88c04714be152af7fd377687dad40","modified":1677596203551},{"_id":"themes/fluid/languages/ja.yml","hash":"3dd6d20f8d26585a7c154a8e59fe8d5d902f4c6a","modified":1677596203553},{"_id":"themes/fluid/languages/zh-HK.yml","hash":"80ed400a7adaa92ea54fc7f5d534c9af795bed00","modified":1677596203565},{"_id":"themes/fluid/layout/404.ejs","hash":"b84d575c7b7f778b4cb64e89ad3d0aed4a896820","modified":1677596203569},{"_id":"themes/fluid/languages/zh-TW.yml","hash":"596d031dff3826ae8e4ffc8931fff28977b73247","modified":1677596203566},{"_id":"themes/fluid/languages/ru.yml","hash":"7dc78f22696649a4c68dc65a9b52d9a992fa82a0","modified":1677596203557},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"f96a22f989897ecddc69d5867a206e1cf6b8f610","modified":1677596203563},{"_id":"themes/fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":1677596203683},{"_id":"themes/fluid/layout/about.ejs","hash":"163bee643e6a38912d3ae70923c83c48d57222e7","modified":1677596203682},{"_id":"themes/fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":1677596203684},{"_id":"themes/fluid/layout/index.ejs","hash":"db000a6a0cec19d32a6e7e94cd4c478500d9c5ac","modified":1677596203687},{"_id":"themes/fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":1677596203685},{"_id":"themes/fluid/layout/page.ejs","hash":"ed5007a3feb8f14d3d2843271bfb298eb0c56219","modified":1677596203690},{"_id":"themes/fluid/layout/post.ejs","hash":"505bcc06e55066b7cc5551d9ac0694e7713bfab5","modified":1677596203692},{"_id":"themes/fluid/layout/layout.ejs","hash":"4a9800642a7c2fe336c2798e078942748c56ee66","modified":1677599265866},{"_id":"themes/fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":1677596203694},{"_id":"themes/fluid/layout/_partials/archive-list.ejs","hash":"7520fbf91f762207c2ab06b2c293235cd5b23905","modified":1677596203572},{"_id":"themes/fluid/layout/links.ejs","hash":"1cac32ec4579aaf7b9fa39d317497331d4c5e1dd","modified":1677596203689},{"_id":"themes/fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1677596203696},{"_id":"themes/fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":1677596203573},{"_id":"themes/fluid/layout/_partials/css.ejs","hash":"85f6e051550907681ab4ed2e268ac8f6e9ebf931","modified":1677596203592},{"_id":"themes/fluid/layout/_partials/head.ejs","hash":"7b7b1d098726e86687a15fe3d520d178577ffcae","modified":1677596203601},{"_id":"themes/fluid/layout/_partials/category-list.ejs","hash":"f8d2f1907450e61968e6d54443e9be8138196a77","modified":1677596203574},{"_id":"themes/fluid/layout/_partials/comments.ejs","hash":"d707c47b2638c94e489bc43d4cfd098b7c58447f","modified":1677596203590},{"_id":"themes/fluid/layout/_partials/markdown-plugins.ejs","hash":"fc4bdf7de0cf1a66d0e5e4fba1b31d6f7ed49468","modified":1677596203633},{"_id":"themes/fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1677596203640},{"_id":"themes/fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":1677596203714},{"_id":"themes/fluid/layout/_partials/scripts.ejs","hash":"da5810785105e5075861593c7ac22c7aa9665a72","modified":1677596203680},{"_id":"themes/fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":1677596203681},{"_id":"themes/fluid/scripts/filters/post-filter.js","hash":"d516b9db63067f9ea9c72cc75ae4ff358417e77d","modified":1677596203747},{"_id":"themes/fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":1677596203749},{"_id":"themes/fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":1677596203750},{"_id":"themes/fluid/scripts/helpers/date.js","hash":"9bda6382f61b40a20c24af466fe10c8366ebb74c","modified":1677596203808},{"_id":"themes/fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":1677596203828},{"_id":"themes/fluid/scripts/helpers/export-config.js","hash":"47e6dba7652a621a54067413490a11c8a89e3d7b","modified":1677596203829},{"_id":"themes/fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":1677596203832},{"_id":"themes/fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":1677596203839},{"_id":"themes/fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1677596203854},{"_id":"themes/fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1677596203859},{"_id":"themes/fluid/scripts/helpers/scope.js","hash":"d41d9d658fcb54964b388598e996747aadb85b0f","modified":1677596203858},{"_id":"themes/fluid/scripts/helpers/utils.js","hash":"226f99b465ff513de075a8e78b321d6cb62592ca","modified":1677596203871},{"_id":"themes/fluid/scripts/helpers/wordcount.js","hash":"4543b8954c5c2ca91191cc0d53cf071b3f26faaa","modified":1677596203872},{"_id":"themes/fluid/scripts/tags/checkbox.js","hash":"4938610c3543a921a341bc074626d511cb1a4b45","modified":1677596203875},{"_id":"themes/fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1677596203874},{"_id":"themes/fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1677596203889},{"_id":"themes/fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1677596203917},{"_id":"themes/fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1677596203984},{"_id":"themes/fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":1677596203999},{"_id":"themes/fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":1677596204025},{"_id":"themes/fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1677596204024},{"_id":"themes/fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1677596204046},{"_id":"themes/fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":1677596204036},{"_id":"themes/fluid/layout/_partials/header.ejs","hash":"0d5e397d30051e5fbabe7b47cfd1f1e6a5820af1","modified":1677596203619},{"_id":"themes/fluid/layout/_partials/footer.ejs","hash":"10ccfb8eef4e16182183c9a3e175c90d5b6397d3","modified":1677596203600},{"_id":"themes/fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1677596204443},{"_id":"themes/fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1677596203746},{"_id":"themes/fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":1677596204445},{"_id":"themes/fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":1677596204446},{"_id":"themes/fluid/source/css/main.styl","hash":"855ae5fe229c51afa57f7645f6997a27a705d7e4","modified":1677596204447},{"_id":"themes/fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1677596204450},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1677596204458},{"_id":"themes/fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1677596204456},{"_id":"themes/fluid/source/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1677596204464},{"_id":"themes/fluid/source/js/events.js","hash":"89e3561488a618ed0caeb9edf18e441978e29c25","modified":1677596204467},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1677596204462},{"_id":"themes/fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1677596204469},{"_id":"themes/fluid/source/js/local-search.js","hash":"cebcda5991b6a9ab9307c69542389ce9013f04f7","modified":1677596204473},{"_id":"themes/fluid/source/js/color-schema.js","hash":"76a198f8721352ebeaf5b2ef2f4db00612da4796","modified":1677596204466},{"_id":"themes/fluid/source/js/utils.js","hash":"45cc86f099db0a2c36ad49711ce66c2d598a2ab1","modified":1677596204475},{"_id":"themes/fluid/source/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1677596204471},{"_id":"themes/fluid/source/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1677596204474},{"_id":"themes/fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1677596204477},{"_id":"themes/fluid/layout/_partials/footer/beian.ejs","hash":"4fb9b5dd3f3e41a586d6af44e5069afe7c81fff2","modified":1677596203596},{"_id":"themes/fluid/layout/_partials/header/banner.ejs","hash":"b83ac14a4b9503ccbba571b333314aa616bb46f8","modified":1677597515413},{"_id":"themes/fluid/layout/_partials/header/navigation.ejs","hash":"1ce751519276d36b3f4c2629f1f6ec085d009d6a","modified":1677596842357},{"_id":"themes/fluid/layout/_partials/footer/statistics.ejs","hash":"454d8dd4c39f9494ebeb03ca0746f5bc122af76a","modified":1677596203598},{"_id":"themes/fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1677596203582},{"_id":"themes/fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1677596203578},{"_id":"themes/fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1677596203577},{"_id":"themes/fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1677596203583},{"_id":"themes/fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1677596203579},{"_id":"themes/fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1677596203584},{"_id":"themes/fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":1677596203587},{"_id":"themes/fluid/layout/_partials/comments/giscus.ejs","hash":"95f8b866b158eff9352c381c243b332a155a5110","modified":1677596203581},{"_id":"themes/fluid/layout/_partials/comments/twikoo.ejs","hash":"e6820fb7f13662c42f8433ec95404238f4c1860c","modified":1677596203585},{"_id":"themes/fluid/layout/_partials/comments/waline.ejs","hash":"12727da7cf3ac83443270f550be4d1c06135b52b","modified":1677596203589},{"_id":"themes/fluid/layout/_partials/plugins/anchorjs.ejs","hash":"40181442d3a2b8734783a0ad7caf2d2522e3f2ab","modified":1677596203644},{"_id":"themes/fluid/layout/_partials/plugins/code-widget.ejs","hash":"3a505cba37942badf62a56bbb8b605b72af330aa","modified":1677596203647},{"_id":"themes/fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":1677596203588},{"_id":"themes/fluid/layout/_partials/plugins/analytics.ejs","hash":"1327395a4dde1ea06c476b047fb110bcd269149f","modified":1677596203642},{"_id":"themes/fluid/layout/_partials/plugins/encrypt.ejs","hash":"e3713fa78e0fc14a239360b020068d8513573ae4","modified":1677596203648},{"_id":"themes/fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":1677596203649},{"_id":"themes/fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":1677596203650},{"_id":"themes/fluid/layout/_partials/plugins/mermaid.ejs","hash":"e49506e9895e255e0e53f34a11d325f83109c1b0","modified":1677596203655},{"_id":"themes/fluid/layout/_partials/post/category-bar.ejs","hash":"8772bce97ed297e7a88523f4e939ed6436c22f87","modified":1677596203671},{"_id":"themes/fluid/layout/_partials/plugins/typed.ejs","hash":"51faef29f8e464bcb2e73049b428b88c8dd8b40a","modified":1677596203657},{"_id":"themes/fluid/layout/_partials/post/meta-bottom.ejs","hash":"7079b27a7bc15a7dfa9209f6be6051bdec49ebad","modified":1677596203673},{"_id":"themes/fluid/layout/_partials/plugins/math.ejs","hash":"dcbf9a381ee76f2f1f75fcbc22c50a502ec85023","modified":1677596203651},{"_id":"themes/fluid/layout/_partials/post/meta-top.ejs","hash":"ce6e9f578f4faa45840abddf8f46af3f4b69c177","modified":1677596203675},{"_id":"themes/fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1677596203656},{"_id":"themes/fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":1677596203678},{"_id":"themes/fluid/layout/_partials/post/toc.ejs","hash":"635a89060fbf72eeda066fc4bd0a97462f069417","modified":1677596203679},{"_id":"themes/fluid/scripts/events/lib/highlight.js","hash":"0f02df2244e275595e72163498d42f42bcf0de5e","modified":1677596203740},{"_id":"themes/fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":1677596203727},{"_id":"themes/fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1677596203742},{"_id":"themes/fluid/scripts/events/lib/hello.js","hash":"44c5eb97b98813a07c659d6afedd17fad63b1821","modified":1677596203739},{"_id":"themes/fluid/scripts/events/lib/footnote.js","hash":"2ec2ae03c79bb1ae7ac3fcf7e00fb52d1af2898d","modified":1677596203728},{"_id":"themes/fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":1677596203741},{"_id":"themes/fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":1677596203743},{"_id":"themes/fluid/layout/_partials/post/copyright.ejs","hash":"9d13392cea94b66d86422ad17c66e5ae67ce1d32","modified":1677596203672},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1677596204056},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1677596204058},{"_id":"themes/fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":1677596203676},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"4ed5f0ae105ef4c7dd92eaf652ceda176c38e502","modified":1677596204442},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1677596204440},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":1677596204078},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"6c727d04e2ddd42e4ba6f8beb7db3ea03b6d273f","modified":1677599244686},{"_id":"themes/fluid/source/css/_pages/_base/color-schema.styl","hash":"61279540c2623ea4bf93e40613d41380839b92d3","modified":1677596204226},{"_id":"themes/fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":1677596204227},{"_id":"themes/fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1677596204228},{"_id":"themes/fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":1677596204416},{"_id":"themes/fluid/source/css/_pages/_post/highlight.styl","hash":"4df764d298fe556e501db4afc2b05686fe6ebcfb","modified":1677596204421},{"_id":"themes/fluid/source/css/_pages/_post/markdown.styl","hash":"1e3d3a82721e7c10bcfcecec6d81cf2979039452","modified":1677596204432},{"_id":"themes/fluid/source/css/_pages/_category/category-bar.styl","hash":"cc6df43fef6bb3efecbfdd8b9e467424a1dea581","modified":1677596204238},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"0acbd71633bcc7191672ea4e1b2277bea350d73b","modified":1677596204258},{"_id":"themes/fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":1677596204260},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1677596204439},{"_id":"themes/fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":1677596204248},{"_id":"themes/fluid/source/css/_pages/_post/post-page.styl","hash":"127bb5391370afe7fef2a297084d76406bc5e902","modified":1677596204433},{"_id":"themes/fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":1677596204249},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1677596204069},{"_id":"themes/fluid/source/css/_pages/_post/post-tag.styl","hash":"27f70062415ccf66a9b6f4952db124fc1471fda5","modified":1677596204436},{"_id":"themes/fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":1677596204101},{"_id":"themes/fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":1677596204130},{"_id":"themes/fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":1677596204125},{"_id":"themes/fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":1677596204124},{"_id":"themes/fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":1677596204137},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1677596204156},{"_id":"themes/fluid/source/css/_pages/_base/_widget/header.styl","hash":"b532cb15f56fbf346ca8f82a643bbbcefab30688","modified":1677598310506},{"_id":"themes/fluid/source/css/_pages/_base/_widget/modal.styl","hash":"adf6c1e5c8e1fb41c77ce6e2258001df61245aa2","modified":1677596204161},{"_id":"themes/fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":1677596204168},{"_id":"themes/fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1677596204179},{"_id":"themes/fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":1677596204170},{"_id":"themes/fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"8bb1b68e5f3552cb48c2ffa31edbc53646a8fb4c","modified":1677596204174},{"_id":"themes/fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1677596204205},{"_id":"themes/fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":1677596204214},{"_id":"themes/fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":1677596204180},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":1677596204148},{"_id":"themes/fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":1677596203745},{"_id":"themes/fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1677596204455},{"_id":"source/_posts/浏览器同源策略/2.png","hash":"adf3ba428627eb4ce5b1f062686708fddb674b79","modified":1677468870000},{"_id":"source/_posts/this指针/this.png","hash":"8ad4f733e1b6a5e729e7f09e51bd46f591754d21","modified":1677353488000},{"_id":"source/img/bg/hs.jpg","hash":"bda2cc0e1a2fd0c14fbd5809ddb5760963da22db","modified":1677584941731},{"_id":"public/css/custom.css","hash":"84e983991f440cd2a282f11f88a2c395bfd89f81","modified":1677849102108},{"_id":"public/local-search.xml","hash":"cfb5db3ecac690c62afbecc7c5833675e686b81c","modified":1677849102108},{"_id":"public/about/index.html","hash":"1f963d43b0660ddbe6a8e5c219b75c5cc9ec5514","modified":1677849102108},{"_id":"public/categories/Web前端/index.html","hash":"34ac402632a828c64f132a6ad40666c9be474f98","modified":1677849102108},{"_id":"public/categories/Web前端/SVG/index.html","hash":"9546e588f78fd3540341d0914c84a06aec2d411f","modified":1677849102108},{"_id":"public/categories/Web前端/CSS/index.html","hash":"b6cf1257ed6af4cc19fdb401c9f75de6c97d000e","modified":1677849102108},{"_id":"public/categories/字体渲染/index.html","hash":"710d53c81af1d41039d051657d23405bb1622482","modified":1677849102108},{"_id":"public/categories/浏览器/index.html","hash":"032ae6477181b7582f9b95c39d367a5ba3da92ee","modified":1677849102108},{"_id":"public/categories/Web前端/javascript/index.html","hash":"417f936c2d14bde62f5fb3bfb07e659fd9bb3939","modified":1677849102108},{"_id":"public/categories/Web前端/Javascript/index.html","hash":"e15312eee9ad46e62b8c67390d59f07c5c5337a3","modified":1677849102108},{"_id":"public/categories/Web前端/javascript/正则表达式/index.html","hash":"47697b90b8d8ae0fd7c1422bd9f7469a66280fdd","modified":1677849102108},{"_id":"public/archives/index.html","hash":"e4152ee0b6cb6f845c48cb164fd3105bfdbf4a4b","modified":1677849102108},{"_id":"public/archives/2023/index.html","hash":"22049fe192e05c7c3aa19194580059dad3af1a73","modified":1677849102108},{"_id":"public/archives/2023/02/index.html","hash":"38b8d7ffe259ed3206f0fabaaa35d682439c75bc","modified":1677849102108},{"_id":"public/archives/2023/03/index.html","hash":"04ff6f454fe5017ad735ba13c7c399a15dfd6c03","modified":1677849102108},{"_id":"public/tags/span-class-label-label-primary-BFC-span-span-class-label-label-primary-CSS渲染-span/index.html","hash":"72540ac0b685a56483220204c0f0a8f56a522514","modified":1677849102108},{"_id":"public/tags/span-class-label-label-primary-正则表达式-span/index.html","hash":"e9b496cd25b5c8bebd7f7344f920337633c9ad10","modified":1677849102108},{"_id":"public/tags/span-class-label-label-primary-this-span-span-class-label-label-primary-箭头函数-span/index.html","hash":"27abf69fa8c428952476e72b9c736dcc75382d4a","modified":1677849102108},{"_id":"public/tags/span-class-label-label-primary-字体渲染-span-span-class-label-label-primary-ttf-span-span-class-label-label-primary-字符编码-span/index.html","hash":"d882b99e5f54ed9737776d8b49696e5bfcace83d","modified":1677849102108},{"_id":"public/2023/03/03/浏览器缓存策略/index.html","hash":"ee1b2037b9a7b927de3b44fc4dde6f8f5fd502b7","modified":1677849102108},{"_id":"public/2023/03/03/meetOrSlice算法/index.html","hash":"b005546eabdefc1e885bce30d7449484cc92f2b3","modified":1677849102108},{"_id":"public/2023/03/03/JS正则表达式入门/index.html","hash":"b3e0beb049206e1dabf7582855212e7c19e1d6c9","modified":1677849102108},{"_id":"public/2023/03/03/浅谈计算机字体/index.html","hash":"757cec28534452da232414fb4c3dc32aa6dbcd0d","modified":1677849102108},{"_id":"public/2023/02/28/浏览器同源策略/index.html","hash":"1073e6422948102485d4f7b4c43d7dbd6d48bb14","modified":1677849102108},{"_id":"public/2023/02/28/BFC/index.html","hash":"2c3722b90bcabf2912af2bd89c0eb455324eb46c","modified":1677849102108},{"_id":"public/2023/02/28/this指针/index.html","hash":"e7da4a02ea1cff9143c15195b025f08c3122526e","modified":1677849102108},{"_id":"public/index.html","hash":"dee71ae27d5d45abd1b202ee79049d16887c62a8","modified":1677849102108},{"_id":"public/tags/span-class-label-label-primary-浏览器安全-span-span-class-label-label-primary-CORS-span/index.html","hash":"c727904f34f0b87490b1f6045158754767881915","modified":1677849102108},{"_id":"public/tags/span-class-label-label-primary-浏览器缓存-span-span-class-label-label-primary-HTTP-span/index.html","hash":"b96fce78b86af43b29859e4e1931a7d4256898f7","modified":1677849102108},{"_id":"public/404.html","hash":"4c8076c0873aaca5fe7143a8a06f677561b43cb0","modified":1677849102108},{"_id":"public/tags/index.html","hash":"924b2f2ef9e53dbc1d10076c6b8e6a1ad1ddbf5e","modified":1677849102108},{"_id":"public/links/index.html","hash":"1d50e46497384f027b231ef80bde7569c5288d03","modified":1677849102108},{"_id":"public/categories/index.html","hash":"919ce4041d6803c0577b12839f80584341fc4fd3","modified":1677849102108},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1677849102108},{"_id":"public/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1677849102108},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1677849102108},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1677849102108},{"_id":"public/img/logo/1.svg","hash":"bf2a45c4f41c35d941f5eb30940e250299e08660","modified":1677849102108},{"_id":"public/img/logo/2.svg","hash":"88f5a0e6e613c12943d698e7492c3d6ed61b98b0","modified":1677849102108},{"_id":"public/img/logo/3.svg","hash":"937b51c28f5ed6fa47857bb65bb6a5a0314b6c4f","modified":1677849102108},{"_id":"public/img/logo/4.svg","hash":"dbdbb40cae8cc20892b96aa63813924ecf669e29","modified":1677849102108},{"_id":"public/img/logo/5.svg","hash":"72285272ff64ebf1c6217cdd385540d0f62c1185","modified":1677849102108},{"_id":"public/img/logo/6.svg","hash":"27a5067ec922e13ba296d59d8db1b1094f6ccd1c","modified":1677849102108},{"_id":"public/2023/02/28/this指针/5.png","hash":"fd61bf1fd530634f075d34a429a8e05d952ba73e","modified":1677849102108},{"_id":"public/2023/02/28/BFC/3.png","hash":"8fb6222d1feea83b6ab412344751ab25a044f570","modified":1677849102108},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1677849102108},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1677849102108},{"_id":"public/css/highlight.css","hash":"0f9a477d33d3b15ebe7e163e756fb7c54c7ded6b","modified":1677849102108},{"_id":"public/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1677849102108},{"_id":"public/js/color-schema.js","hash":"76a198f8721352ebeaf5b2ef2f4db00612da4796","modified":1677849102108},{"_id":"public/js/events.js","hash":"89e3561488a618ed0caeb9edf18e441978e29c25","modified":1677849102108},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1677849102108},{"_id":"public/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1677849102108},{"_id":"public/js/local-search.js","hash":"cebcda5991b6a9ab9307c69542389ce9013f04f7","modified":1677849102108},{"_id":"public/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1677849102108},{"_id":"public/js/utils.js","hash":"45cc86f099db0a2c36ad49711ce66c2d598a2ab1","modified":1677849102108},{"_id":"public/css/main.css","hash":"45c25ab71a5356843398adacc25a9d6740a6a4a9","modified":1677849102108},{"_id":"public/2023/02/28/this指针/1.png","hash":"010df365706510909bc5fb151f2c2a5d1d5eadff","modified":1677849102108},{"_id":"public/2023/02/28/this指针/4.png","hash":"3f45edec62ac2357acd4449f12d6fd0c40b839ba","modified":1677849102108},{"_id":"public/2023/02/28/BFC/5.png","hash":"d587bf92b5eda087c53ff3a21c0c41a2836bee18","modified":1677849102108},{"_id":"public/css/highlight-dark.css","hash":"2b0daa6e5343da9dbb26d617d224b8397e48556b","modified":1677849102108},{"_id":"public/2023/02/28/this指针/2.png","hash":"d2547baea38a606ff1c2a1f027f1ef5df76ca4da","modified":1677849102108},{"_id":"public/2023/02/28/this指针/8.png","hash":"726563949c0a2fc722403013084db32aba631183","modified":1677849102108},{"_id":"public/2023/02/28/BFC/1.png","hash":"c74117161d65f282743ec87fb7de4b0891510ca9","modified":1677849102108},{"_id":"public/2023/02/28/BFC/4.png","hash":"21c3a89ffccbdbfc9fd8c6217592a25b6fd76b3d","modified":1677849102108},{"_id":"public/2023/02/28/BFC/2.png","hash":"1c89eadcb4b80ecf675954b0f808f099b87c9d68","modified":1677849102108},{"_id":"public/2023/02/28/this指针/3.png","hash":"a11c9c33db0dde6e4fafe2ff59db71b414992f55","modified":1677849102108},{"_id":"public/2023/02/28/this指针/7.png","hash":"e1feae3c2bc356cf78a8bb53d15c07fca193caaf","modified":1677849102108},{"_id":"public/img/bg/IMG_0048.jpg","hash":"1c382f0021da5b56deb1cc97c5b5f27c19bb4751","modified":1677849102108},{"_id":"public/2023/02/28/浏览器同源策略/1.png","hash":"212abda7729277e82e7b6bd3e69664726dec6b75","modified":1677849102108},{"_id":"public/2023/02/28/浏览器同源策略/3.png","hash":"5d99263ab48a715f58d80e3c197f202e2fa0a8e3","modified":1677849102108},{"_id":"public/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1677849102108},{"_id":"public/2023/02/28/浏览器同源策略/2.png","hash":"adf3ba428627eb4ce5b1f062686708fddb674b79","modified":1677849102108},{"_id":"public/2023/02/28/this指针/this.png","hash":"8ad4f733e1b6a5e729e7f09e51bd46f591754d21","modified":1677849102108},{"_id":"public/img/bg/hs.jpg","hash":"bda2cc0e1a2fd0c14fbd5809ddb5760963da22db","modified":1677849102108}],"Category":[{"name":"Web前端","_id":"clesk19ga0004dddf3ddxh0jy"},{"name":"SVG","parent":"clesk19ga0004dddf3ddxh0jy","_id":"clesk19gx000gdddfc9yiezox"},{"name":"CSS","parent":"clesk19ga0004dddf3ddxh0jy","_id":"clesk19gy000jdddf0okffdyh"},{"name":"字体渲染","_id":"clesk19h0000ndddf0ajv5peo"},{"name":"浏览器","_id":"clesk19ha000sdddf4c0da5j5"},{"name":"javascript","parent":"clesk19ga0004dddf3ddxh0jy","_id":"clesk19hb000wdddf29hk77ki"},{"name":"Javascript","parent":"clesk19ga0004dddf3ddxh0jy","_id":"clesk19hb000ydddf25aegwt5"},{"name":"正则表达式","parent":"clesk19hb000wdddf29hk77ki","_id":"clesk19hb000zdddfbmv1cgw3"}],"Data":[{"_id":"languages/zh-CN","data":{"name":"简体中文","home":{"menu":"首页","title":"首页"},"archive":{"menu":"归档","title":"归档","subtitle":"归档","post_total":"共计 %d 篇文章"},"category":{"menu":"分类","title":"分类","subtitle":"分类","post_total":"共计 %d 篇文章","more":"More..."},"tag":{"menu":"标签","title":"标签","subtitle":"标签","post_total":"共计 %d 篇文章"},"about":{"menu":"关于","title":"关于","subtitle":"关于"},"links":{"menu":"友链","title":"友链","subtitle":"友情链接"},"page404":{"menu":"页面不存在","title":"页面不存在","subtitle":"页面不存在"},"post":{"toc":"目录","prev_post":"上一篇","next_post":"下一篇","updated":"本文最后更新于：%s","meta":{"wordcount":"%s 字","min2read":"%s 分钟","views":"{} 次"},"copyright":{"author":"作者","posted":"发布于","updated":"更新于","licensed":"许可协议","CC":"CC - 知识共享许可协议","BY":"BY - 署名","SA":"SA - 相同方式共享","NC":"NC - 非商业性使用","ND":"ND - 禁止演绎"}},"footer":{"pv":"总访问量 {} 次","uv":"总访客数 {} 人"},"search":{"title":"搜索","keyword":"关键词"},"noscript_warning":"博客在允许 JavaScript 运行的环境下浏览效果更佳"}}],"Page":[{"title":"关于我","date":"2022-12-27T11:25:53.000Z","_content":"\n\n","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2022-12-27 19:25:53\n---\n\n\n","updated":"2023-02-28T11:49:01.690Z","path":"about/index.html","comments":1,"layout":"page","_id":"clesk19fw0000dddfce88auxc","content":"","site":{"data":{"languages/zh-CN":{"name":"简体中文","home":{"menu":"首页","title":"首页"},"archive":{"menu":"归档","title":"归档","subtitle":"归档","post_total":"共计 %d 篇文章"},"category":{"menu":"分类","title":"分类","subtitle":"分类","post_total":"共计 %d 篇文章","more":"More..."},"tag":{"menu":"标签","title":"标签","subtitle":"标签","post_total":"共计 %d 篇文章"},"about":{"menu":"关于","title":"关于","subtitle":"关于"},"links":{"menu":"友链","title":"友链","subtitle":"友情链接"},"page404":{"menu":"页面不存在","title":"页面不存在","subtitle":"页面不存在"},"post":{"toc":"目录","prev_post":"上一篇","next_post":"下一篇","updated":"本文最后更新于：%s","meta":{"wordcount":"%s 字","min2read":"%s 分钟","views":"{} 次"},"copyright":{"author":"作者","posted":"发布于","updated":"更新于","licensed":"许可协议","CC":"CC - 知识共享许可协议","BY":"BY - 署名","SA":"SA - 相同方式共享","NC":"NC - 非商业性使用","ND":"ND - 禁止演绎"}},"footer":{"pv":"总访问量 {} 次","uv":"总访客数 {} 人"},"search":{"title":"搜索","keyword":"关键词"},"noscript_warning":"博客在允许 JavaScript 运行的环境下浏览效果更佳"}}},"excerpt":"","more":""},{"_content":"[data-user-color-scheme=\"light\"] {\n    --navbar-bg-color: #fff;\n}\n\n[data-user-color-scheme=\"light\"] body {\n    background-color: #fff;\n}\n\n[data-user-color-scheme=\"light\"] .top-nav-collapse {\n    --navbar-text-color: #000;\n}\n\n[data-user-color-scheme=\"dark\"] {\n    --body-bg-color: #121211;\n    --navbar-bg-color: #212121;\n    --board-bg-color: #2a2a2a;\n}","source":"css/custom.css","raw":"[data-user-color-scheme=\"light\"] {\n    --navbar-bg-color: #fff;\n}\n\n[data-user-color-scheme=\"light\"] body {\n    background-color: #fff;\n}\n\n[data-user-color-scheme=\"light\"] .top-nav-collapse {\n    --navbar-text-color: #000;\n}\n\n[data-user-color-scheme=\"dark\"] {\n    --body-bg-color: #121211;\n    --navbar-bg-color: #212121;\n    --board-bg-color: #2a2a2a;\n}","date":"2023-02-28T14:03:24.128Z","updated":"2023-02-28T14:03:24.128Z","path":"css/custom.css","layout":"false","title":"","comments":1,"_id":"clesk19g70002dddf71oxe6me","content":"[data-user-color-scheme=\"light\"] {\n    --navbar-bg-color: #fff;\n}\n\n[data-user-color-scheme=\"light\"] body {\n    background-color: #fff;\n}\n\n[data-user-color-scheme=\"light\"] .top-nav-collapse {\n    --navbar-text-color: #000;\n}\n\n[data-user-color-scheme=\"dark\"] {\n    --body-bg-color: #121211;\n    --navbar-bg-color: #212121;\n    --board-bg-color: #2a2a2a;\n}","site":{"data":{"languages/zh-CN":{"name":"简体中文","home":{"menu":"首页","title":"首页"},"archive":{"menu":"归档","title":"归档","subtitle":"归档","post_total":"共计 %d 篇文章"},"category":{"menu":"分类","title":"分类","subtitle":"分类","post_total":"共计 %d 篇文章","more":"More..."},"tag":{"menu":"标签","title":"标签","subtitle":"标签","post_total":"共计 %d 篇文章"},"about":{"menu":"关于","title":"关于","subtitle":"关于"},"links":{"menu":"友链","title":"友链","subtitle":"友情链接"},"page404":{"menu":"页面不存在","title":"页面不存在","subtitle":"页面不存在"},"post":{"toc":"目录","prev_post":"上一篇","next_post":"下一篇","updated":"本文最后更新于：%s","meta":{"wordcount":"%s 字","min2read":"%s 分钟","views":"{} 次"},"copyright":{"author":"作者","posted":"发布于","updated":"更新于","licensed":"许可协议","CC":"CC - 知识共享许可协议","BY":"BY - 署名","SA":"SA - 相同方式共享","NC":"NC - 非商业性使用","ND":"ND - 禁止演绎"}},"footer":{"pv":"总访问量 {} 次","uv":"总访客数 {} 人"},"search":{"title":"搜索","keyword":"关键词"},"noscript_warning":"博客在允许 JavaScript 运行的环境下浏览效果更佳"}}},"excerpt":"","more":"[data-user-color-scheme=\"light\"] {\n    --navbar-bg-color: #fff;\n}\n\n[data-user-color-scheme=\"light\"] body {\n    background-color: #fff;\n}\n\n[data-user-color-scheme=\"light\"] .top-nav-collapse {\n    --navbar-text-color: #000;\n}\n\n[data-user-color-scheme=\"dark\"] {\n    --body-bg-color: #121211;\n    --navbar-bg-color: #212121;\n    --board-bg-color: #2a2a2a;\n}"}],"Post":[{"title":"BFC","date":"2023-02-28T14:03:56.000Z","excerpt":"本文主要介绍了BFC渲染规则以及通过一些实例证明。","_content":"# 什么是BFC？\n在了解BFC之前，先了解一下FC的定义。**FC**（Formatting Context 格式化上下文），FC指定了页面中一块独立区域的渲染规则，这个渲染规则可以理解为内部元素的布局规则。不同的FC有不同的规则定义。\n\n目前网页中几种FC的分类：\n\n- **IFC**（Inline Formatting Context）：行级格式化上下文\n- **BFC**（Block Formatting Context）：块格式化上下文\n    - 更多关于IFC / BFC的定义参考：[CSS 2.1 Visual formatting model：Section 9.4](https://www.w3.org/TR/CSS2/visuren.html#normal-flow)\n- **FFC**（Flex Formatting Context）：自适应格式化上下文\n    - 更多关于自适应布局的定义参考 ：[Flexible Box Layout Module Level 1](https://drafts.csswg.org/css-flexbox-1/#flex-formatting-context)\n- **GFC**（Grid Formatting Context）：网格布局格式化上下文\n\n\n# BFC的触发条件\n在以下几种情况下，会触发形成BFC：\n- 根元素`HTML`\n- 浮动元素：`float` 属性不为`none`\n- `position`定位：设置为 `absolute` 、`fixed`\n- `overflow` 属性：设置为非`visible` 、`clip`的**块**元素\n- `display`属性：\n    - 设置为 `table`类型：\n        - `table`：对应`<table>`\n        - `table-caption`：HTML 表格标题默认值\n        - `table-row`：对应`<tr>`\n        - `table-row-group`：`<tbody>`\n        - `table-header-group`：`<thead>`\n        - `table-footer-group`：`<tfoot>`\n        - `table-cell`：HTML 表格单元格默认值\n        - `inline-table`\n    - 设置为`inline-block`\n    - 设置为`flow-root`\n    - 设置为`flex`类型：父元素display属性为`flex` 或者 `inline-flex`，其子元素内部的布局规则为BFC（其子元素本身非`table`类型、`grid`类型、`flex`类型）\n    - 设置为`grid`类型：父元素display属性为`gird` 或者 `inline-grid`，其子元素内部的布局规则为BFC（其子元素本身非`table`类型、`grid`类型、`flex`类型）\n- `contain` 属性：\n    - `layout`\n    - `content`\n    - `paint`\n- *多列容器（暂时没有搞懂）*\n\n# BFC渲染规则\n- 渲染隔离：一个BFC是页面上的一个隔离的独立容器，容器里面的子元素的排版布局不会直接影响到外面的元素（可能通过子元素影响父元素容器大小间接影响外部元素布局）。\n- 容器大小计算：区域大小由内部元素的边界确定：\n    - 即一个BFC容器会包裹所有的子元素块，无论该子元素是否是浮动元素，所以BFC的高度计算会包含`float`元素。\n- `margin`重叠：\n    - 在同一个BFC中，相邻元素形成的`box`的上下`margin`产生重叠；\n    - 但在不同的BFC中，各自的子元素的`margin`不重叠。\n- 排布方向：\n    - 内部的子元素由上到下依次排布。\n    - 内部子元素根据书写方向（`writing-mode`）确定从左开始排布还是从右开始排布。\n    - 起始位置的子元素的`margin`紧贴父容器的`border`（只有起始方向的`margin`紧贴）。\n- 当前的BFC不与外部的`float box`重叠。\n\n# 实例验证\n## 1、容器大小计算\n区域大小由内部元素的边界确定，高度计算包含`float`元素\n当不给父容器设置高度的情况下，查看父容器的高度是如何计算的：\n```html\n <!-- bfc的高度计算会包含float子元素 可以用作清除内部浮动 -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <title>BFC</title>\n    <style>\n        .bfc {\n            display: flow-root;\n        }\n        .container {\n            border: 1px solid #939393;\n            background: #f2f2f2;\n            margin-bottom: 20px;\n        }\n        .float {\n            float: left;\n            background-color: #e98f53;\n        }\n        .child {\n            height: 40px;\n            width: 40px;\n        }  \n    </style>\n</head>\n\n<body>\n\t  <!-- 父容器非BFC -->\n    <div class=\"container\">\n        <div class=\"float child\"></div>\n    </div>\n\n\t\t<!-- 父容器是BFC -->\n    <div class=\"bfc container\" style=\"margin-top: 100px\">\n        <div class=\"float child\"></div>\n    </div>\n</body>\n</html>\n```\n\n![](1.png)\n\n## 2、margin重叠\n同一个BFC中相邻的元素上下`margin`重叠\n当给子元素设置\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <title>BFC</title>\n    <style>\n        .bfc {\n            display: flow-root;\n        }\n        .container {\n            border: 1px solid #939393;\n            background: #f2f2f2;\n        }\n       .bfc-child {\n            height: 40px;\n            margin: 30px 0;\n            background-color: #ccc;\n       }\n    </style>\n</head>\n\n<body>\n\t<div class=\"bfc container\">\n        <div class=\"bfc-child\"></div>\n    </div>\n    <div class=\"bfc container\">\n        <div class=\"bfc-child\"></div>\n        <div class=\"bfc-child\"></div>\n    </div>\n</body>\n</html>\n```\n\n![](2.png)\n\n相反，当父容器非BFC时，所有子元素（无论是否是平级）都会发生上下`margin`重叠。\n将上面父容器的display属性改为`contents` ：\n\n```css\n.bfc{\n\tdisplay: contents;\n}\n```\n\n![](3.png)\n\n> contents\n> These elements don't produce a specific box by themselves. They are replaced by their pseudo-box and their child boxes. \n> \n> 当设置元素为content时，该元素不会生成自己的box，而是会被子元素生成的box取代。\n> \n\n会发现此时处于两个父级下的子元素，上下`margin`也会发生重叠。此时因为父容器不是BFC，没有渲染隔离，所有子元素生成的盒子被平铺到了最外层。\n\n## 3、当前的BFC不与外部的`float box`重叠\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>BFC</title>\n    <style>\n\t     .bfc {\n            display: flow-root;\n        }\n        .float {\n            float: left;\n            background-color: #e98f53;\n            height: 40px;\n            width: 40px;\n        }\n        .aside {\n            width: 200px;\n            height: 200px;\n            background-color: #696fa7;\n        }\n    </style>\n</head>\n\n<body>\n    <!-- 规则三：bfc区域不和浮动元素重叠 -->\n    <div class=\"float\"></div>\n    <div class=\"aside\">该元素非BFC，则该元素和小黄块重叠</div>\n\n    <div class=\"float\"></div>\n    <div class=\"aside bfc\">该元素BFC，则该元素和小黄块不重叠</div>\n\n</body>\n\n</html>\n\n```\n\n![](4.png)\n\n# BFC的作用\n\n利用BFC的渲染规则，可以实现以下几个功能：\n- 自适应两栏布局\n- 阻止元素被浮动元素覆盖\n- 清除内部浮动\n- 阻止`margin`重叠：分属于不同的BFC时不发生重叠\n\n后面三条在实验中以及实现过了，但是针对第一条，如何利用BFC实现两栏布局呢？\n\n利用2个特性：\n1. 块级元素`width:auto` 时，会自动拉伸至父元素左右边界处（横向占满）。\n2. BFC渲染规则：当前的BFC不与外部的`float box`重叠。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>BFC</title>\n    <style>\n        .bfc {\n            display: flow-root;\n        }\n\t\t\t\t.container {\n            border: 1px solid #939393;\n            background: #f2f2f2;\n            margin-bottom: 20px;\n        }\n        .main{\n            height: 300px;\n            background: #ddd;\n        }\n        .float-aside{\n            width: 100px;\n            height: 150px;\n            float: left;\n            background: #757575;\n        }\n    </style>\n</head>\n\n<body>\n    <!-- 利用bfc区域不和浮动元素重叠的特性，实现自适应两栏布局 -->\n    <div class=\"bfc container\">\n        <div class=\"float-aside\"></div>\n        <div class=\"bfc main\">设置float的宽度，然后给相邻的bfc元素不设置宽度，块级元素默认宽度为auto，那么该bfc元素会自动延伸到父元素的最右端</div>\n    </div>\n</body>\n</html>\n```\n\n![](5.png)\n\n# 参考\n[[布局概念] 关于CSS-BFC深入理解](https://juejin.cn/post/6844903476774830094)\n[CSS Display Module Level 4](https://drafts.csswg.org/css-display/#formatting-context)\n\n","source":"_posts/BFC.md","raw":"---\ntitle: BFC\ndate: 2023-02-28 22:03:56\ncategory: [Web前端, CSS]\ntags: <span class=\"label label-primary\">BFC</span> <span class=\"label label-primary\">CSS渲染</span>\nexcerpt: 本文主要介绍了BFC渲染规则以及通过一些实例证明。\n---\n# 什么是BFC？\n在了解BFC之前，先了解一下FC的定义。**FC**（Formatting Context 格式化上下文），FC指定了页面中一块独立区域的渲染规则，这个渲染规则可以理解为内部元素的布局规则。不同的FC有不同的规则定义。\n\n目前网页中几种FC的分类：\n\n- **IFC**（Inline Formatting Context）：行级格式化上下文\n- **BFC**（Block Formatting Context）：块格式化上下文\n    - 更多关于IFC / BFC的定义参考：[CSS 2.1 Visual formatting model：Section 9.4](https://www.w3.org/TR/CSS2/visuren.html#normal-flow)\n- **FFC**（Flex Formatting Context）：自适应格式化上下文\n    - 更多关于自适应布局的定义参考 ：[Flexible Box Layout Module Level 1](https://drafts.csswg.org/css-flexbox-1/#flex-formatting-context)\n- **GFC**（Grid Formatting Context）：网格布局格式化上下文\n\n\n# BFC的触发条件\n在以下几种情况下，会触发形成BFC：\n- 根元素`HTML`\n- 浮动元素：`float` 属性不为`none`\n- `position`定位：设置为 `absolute` 、`fixed`\n- `overflow` 属性：设置为非`visible` 、`clip`的**块**元素\n- `display`属性：\n    - 设置为 `table`类型：\n        - `table`：对应`<table>`\n        - `table-caption`：HTML 表格标题默认值\n        - `table-row`：对应`<tr>`\n        - `table-row-group`：`<tbody>`\n        - `table-header-group`：`<thead>`\n        - `table-footer-group`：`<tfoot>`\n        - `table-cell`：HTML 表格单元格默认值\n        - `inline-table`\n    - 设置为`inline-block`\n    - 设置为`flow-root`\n    - 设置为`flex`类型：父元素display属性为`flex` 或者 `inline-flex`，其子元素内部的布局规则为BFC（其子元素本身非`table`类型、`grid`类型、`flex`类型）\n    - 设置为`grid`类型：父元素display属性为`gird` 或者 `inline-grid`，其子元素内部的布局规则为BFC（其子元素本身非`table`类型、`grid`类型、`flex`类型）\n- `contain` 属性：\n    - `layout`\n    - `content`\n    - `paint`\n- *多列容器（暂时没有搞懂）*\n\n# BFC渲染规则\n- 渲染隔离：一个BFC是页面上的一个隔离的独立容器，容器里面的子元素的排版布局不会直接影响到外面的元素（可能通过子元素影响父元素容器大小间接影响外部元素布局）。\n- 容器大小计算：区域大小由内部元素的边界确定：\n    - 即一个BFC容器会包裹所有的子元素块，无论该子元素是否是浮动元素，所以BFC的高度计算会包含`float`元素。\n- `margin`重叠：\n    - 在同一个BFC中，相邻元素形成的`box`的上下`margin`产生重叠；\n    - 但在不同的BFC中，各自的子元素的`margin`不重叠。\n- 排布方向：\n    - 内部的子元素由上到下依次排布。\n    - 内部子元素根据书写方向（`writing-mode`）确定从左开始排布还是从右开始排布。\n    - 起始位置的子元素的`margin`紧贴父容器的`border`（只有起始方向的`margin`紧贴）。\n- 当前的BFC不与外部的`float box`重叠。\n\n# 实例验证\n## 1、容器大小计算\n区域大小由内部元素的边界确定，高度计算包含`float`元素\n当不给父容器设置高度的情况下，查看父容器的高度是如何计算的：\n```html\n <!-- bfc的高度计算会包含float子元素 可以用作清除内部浮动 -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <title>BFC</title>\n    <style>\n        .bfc {\n            display: flow-root;\n        }\n        .container {\n            border: 1px solid #939393;\n            background: #f2f2f2;\n            margin-bottom: 20px;\n        }\n        .float {\n            float: left;\n            background-color: #e98f53;\n        }\n        .child {\n            height: 40px;\n            width: 40px;\n        }  \n    </style>\n</head>\n\n<body>\n\t  <!-- 父容器非BFC -->\n    <div class=\"container\">\n        <div class=\"float child\"></div>\n    </div>\n\n\t\t<!-- 父容器是BFC -->\n    <div class=\"bfc container\" style=\"margin-top: 100px\">\n        <div class=\"float child\"></div>\n    </div>\n</body>\n</html>\n```\n\n![](1.png)\n\n## 2、margin重叠\n同一个BFC中相邻的元素上下`margin`重叠\n当给子元素设置\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <title>BFC</title>\n    <style>\n        .bfc {\n            display: flow-root;\n        }\n        .container {\n            border: 1px solid #939393;\n            background: #f2f2f2;\n        }\n       .bfc-child {\n            height: 40px;\n            margin: 30px 0;\n            background-color: #ccc;\n       }\n    </style>\n</head>\n\n<body>\n\t<div class=\"bfc container\">\n        <div class=\"bfc-child\"></div>\n    </div>\n    <div class=\"bfc container\">\n        <div class=\"bfc-child\"></div>\n        <div class=\"bfc-child\"></div>\n    </div>\n</body>\n</html>\n```\n\n![](2.png)\n\n相反，当父容器非BFC时，所有子元素（无论是否是平级）都会发生上下`margin`重叠。\n将上面父容器的display属性改为`contents` ：\n\n```css\n.bfc{\n\tdisplay: contents;\n}\n```\n\n![](3.png)\n\n> contents\n> These elements don't produce a specific box by themselves. They are replaced by their pseudo-box and their child boxes. \n> \n> 当设置元素为content时，该元素不会生成自己的box，而是会被子元素生成的box取代。\n> \n\n会发现此时处于两个父级下的子元素，上下`margin`也会发生重叠。此时因为父容器不是BFC，没有渲染隔离，所有子元素生成的盒子被平铺到了最外层。\n\n## 3、当前的BFC不与外部的`float box`重叠\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>BFC</title>\n    <style>\n\t     .bfc {\n            display: flow-root;\n        }\n        .float {\n            float: left;\n            background-color: #e98f53;\n            height: 40px;\n            width: 40px;\n        }\n        .aside {\n            width: 200px;\n            height: 200px;\n            background-color: #696fa7;\n        }\n    </style>\n</head>\n\n<body>\n    <!-- 规则三：bfc区域不和浮动元素重叠 -->\n    <div class=\"float\"></div>\n    <div class=\"aside\">该元素非BFC，则该元素和小黄块重叠</div>\n\n    <div class=\"float\"></div>\n    <div class=\"aside bfc\">该元素BFC，则该元素和小黄块不重叠</div>\n\n</body>\n\n</html>\n\n```\n\n![](4.png)\n\n# BFC的作用\n\n利用BFC的渲染规则，可以实现以下几个功能：\n- 自适应两栏布局\n- 阻止元素被浮动元素覆盖\n- 清除内部浮动\n- 阻止`margin`重叠：分属于不同的BFC时不发生重叠\n\n后面三条在实验中以及实现过了，但是针对第一条，如何利用BFC实现两栏布局呢？\n\n利用2个特性：\n1. 块级元素`width:auto` 时，会自动拉伸至父元素左右边界处（横向占满）。\n2. BFC渲染规则：当前的BFC不与外部的`float box`重叠。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>BFC</title>\n    <style>\n        .bfc {\n            display: flow-root;\n        }\n\t\t\t\t.container {\n            border: 1px solid #939393;\n            background: #f2f2f2;\n            margin-bottom: 20px;\n        }\n        .main{\n            height: 300px;\n            background: #ddd;\n        }\n        .float-aside{\n            width: 100px;\n            height: 150px;\n            float: left;\n            background: #757575;\n        }\n    </style>\n</head>\n\n<body>\n    <!-- 利用bfc区域不和浮动元素重叠的特性，实现自适应两栏布局 -->\n    <div class=\"bfc container\">\n        <div class=\"float-aside\"></div>\n        <div class=\"bfc main\">设置float的宽度，然后给相邻的bfc元素不设置宽度，块级元素默认宽度为auto，那么该bfc元素会自动延伸到父元素的最右端</div>\n    </div>\n</body>\n</html>\n```\n\n![](5.png)\n\n# 参考\n[[布局概念] 关于CSS-BFC深入理解](https://juejin.cn/post/6844903476774830094)\n[CSS Display Module Level 4](https://drafts.csswg.org/css-display/#formatting-context)\n\n","slug":"BFC","published":1,"updated":"2023-03-03T07:30:16.732Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clesk19fy0001dddf2ayc9v46","content":"<h1 id=\"什么是BFC？\"><a href=\"#什么是BFC？\" class=\"headerlink\" title=\"什么是BFC？\"></a>什么是BFC？</h1><p>在了解BFC之前，先了解一下FC的定义。<strong>FC</strong>（Formatting Context 格式化上下文），FC指定了页面中一块独立区域的渲染规则，这个渲染规则可以理解为内部元素的布局规则。不同的FC有不同的规则定义。</p>\n<p>目前网页中几种FC的分类：</p>\n<ul>\n<li><strong>IFC</strong>（Inline Formatting Context）：行级格式化上下文</li>\n<li><strong>BFC</strong>（Block Formatting Context）：块格式化上下文<ul>\n<li>更多关于IFC / BFC的定义参考：<a href=\"https://www.w3.org/TR/CSS2/visuren.html#normal-flow\">CSS 2.1 Visual formatting model：Section 9.4</a></li>\n</ul>\n</li>\n<li><strong>FFC</strong>（Flex Formatting Context）：自适应格式化上下文<ul>\n<li>更多关于自适应布局的定义参考 ：<a href=\"https://drafts.csswg.org/css-flexbox-1/#flex-formatting-context\">Flexible Box Layout Module Level 1</a></li>\n</ul>\n</li>\n<li><strong>GFC</strong>（Grid Formatting Context）：网格布局格式化上下文</li>\n</ul>\n<h1 id=\"BFC的触发条件\"><a href=\"#BFC的触发条件\" class=\"headerlink\" title=\"BFC的触发条件\"></a>BFC的触发条件</h1><p>在以下几种情况下，会触发形成BFC：</p>\n<ul>\n<li>根元素<code>HTML</code></li>\n<li>浮动元素：<code>float</code> 属性不为<code>none</code></li>\n<li><code>position</code>定位：设置为 <code>absolute</code> 、<code>fixed</code></li>\n<li><code>overflow</code> 属性：设置为非<code>visible</code> 、<code>clip</code>的<strong>块</strong>元素</li>\n<li><code>display</code>属性：<ul>\n<li>设置为 <code>table</code>类型：<ul>\n<li><code>table</code>：对应<code>&lt;table&gt;</code></li>\n<li><code>table-caption</code>：HTML 表格标题默认值</li>\n<li><code>table-row</code>：对应<code>&lt;tr&gt;</code></li>\n<li><code>table-row-group</code>：<code>&lt;tbody&gt;</code></li>\n<li><code>table-header-group</code>：<code>&lt;thead&gt;</code></li>\n<li><code>table-footer-group</code>：<code>&lt;tfoot&gt;</code></li>\n<li><code>table-cell</code>：HTML 表格单元格默认值</li>\n<li><code>inline-table</code></li>\n</ul>\n</li>\n<li>设置为<code>inline-block</code></li>\n<li>设置为<code>flow-root</code></li>\n<li>设置为<code>flex</code>类型：父元素display属性为<code>flex</code> 或者 <code>inline-flex</code>，其子元素内部的布局规则为BFC（其子元素本身非<code>table</code>类型、<code>grid</code>类型、<code>flex</code>类型）</li>\n<li>设置为<code>grid</code>类型：父元素display属性为<code>gird</code> 或者 <code>inline-grid</code>，其子元素内部的布局规则为BFC（其子元素本身非<code>table</code>类型、<code>grid</code>类型、<code>flex</code>类型）</li>\n</ul>\n</li>\n<li><code>contain</code> 属性：<ul>\n<li><code>layout</code></li>\n<li><code>content</code></li>\n<li><code>paint</code></li>\n</ul>\n</li>\n<li><em>多列容器（暂时没有搞懂）</em></li>\n</ul>\n<h1 id=\"BFC渲染规则\"><a href=\"#BFC渲染规则\" class=\"headerlink\" title=\"BFC渲染规则\"></a>BFC渲染规则</h1><ul>\n<li>渲染隔离：一个BFC是页面上的一个隔离的独立容器，容器里面的子元素的排版布局不会直接影响到外面的元素（可能通过子元素影响父元素容器大小间接影响外部元素布局）。</li>\n<li>容器大小计算：区域大小由内部元素的边界确定：<ul>\n<li>即一个BFC容器会包裹所有的子元素块，无论该子元素是否是浮动元素，所以BFC的高度计算会包含<code>float</code>元素。</li>\n</ul>\n</li>\n<li><code>margin</code>重叠：<ul>\n<li>在同一个BFC中，相邻元素形成的<code>box</code>的上下<code>margin</code>产生重叠；</li>\n<li>但在不同的BFC中，各自的子元素的<code>margin</code>不重叠。</li>\n</ul>\n</li>\n<li>排布方向：<ul>\n<li>内部的子元素由上到下依次排布。</li>\n<li>内部子元素根据书写方向（<code>writing-mode</code>）确定从左开始排布还是从右开始排布。</li>\n<li>起始位置的子元素的<code>margin</code>紧贴父容器的<code>border</code>（只有起始方向的<code>margin</code>紧贴）。</li>\n</ul>\n</li>\n<li>当前的BFC不与外部的<code>float box</code>重叠。</li>\n</ul>\n<h1 id=\"实例验证\"><a href=\"#实例验证\" class=\"headerlink\" title=\"实例验证\"></a>实例验证</h1><h2 id=\"1、容器大小计算\"><a href=\"#1、容器大小计算\" class=\"headerlink\" title=\"1、容器大小计算\"></a>1、容器大小计算</h2><p>区域大小由内部元素的边界确定，高度计算包含<code>float</code>元素<br>当不给父容器设置高度的情况下，查看父容器的高度是如何计算的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"> <span class=\"hljs-comment\">&lt;!-- bfc的高度计算会包含float子元素 可以用作清除内部浮动 --&gt;</span><br><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>BFC<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.bfc</span> &#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">display</span>: flow-root;</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.container</span> &#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid <span class=\"hljs-number\">#939393</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-number\">#f2f2f2</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">margin-bottom</span>: <span class=\"hljs-number\">20px</span>;</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.float</span> &#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">float</span>: left;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#e98f53</span>;</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.child</span> &#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">40px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">40px</span>;</span><br><span class=\"language-css\">        &#125;  </span><br><span class=\"language-css\">    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>\t  <span class=\"hljs-comment\">&lt;!-- 父容器非BFC --&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;container&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;float child&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>\t\t<span class=\"hljs-comment\">&lt;!-- 父容器是BFC --&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;bfc container&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;margin-top: 100px&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;float child&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p><img src=\"1.png\"></p>\n<h2 id=\"2、margin重叠\"><a href=\"#2、margin重叠\" class=\"headerlink\" title=\"2、margin重叠\"></a>2、margin重叠</h2><p>同一个BFC中相邻的元素上下<code>margin</code>重叠<br>当给子元素设置</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>BFC<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.bfc</span> &#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">display</span>: flow-root;</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.container</span> &#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid <span class=\"hljs-number\">#939393</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-number\">#f2f2f2</span>;</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">       <span class=\"hljs-selector-class\">.bfc-child</span> &#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">40px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">30px</span> <span class=\"hljs-number\">0</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#ccc</span>;</span><br><span class=\"language-css\">       &#125;</span><br><span class=\"language-css\">    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;bfc container&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;bfc-child&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;bfc container&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;bfc-child&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;bfc-child&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p><img src=\"2.png\"></p>\n<p>相反，当父容器非BFC时，所有子元素（无论是否是平级）都会发生上下<code>margin</code>重叠。<br>将上面父容器的display属性改为<code>contents</code> ：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.bfc</span>&#123;<br>\t<span class=\"hljs-attribute\">display</span>: contents;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"3.png\"></p>\n<blockquote>\n<p>contents<br>These elements don’t produce a specific box by themselves. They are replaced by their pseudo-box and their child boxes. </p>\n<p>当设置元素为content时，该元素不会生成自己的box，而是会被子元素生成的box取代。</p>\n</blockquote>\n<p>会发现此时处于两个父级下的子元素，上下<code>margin</code>也会发生重叠。此时因为父容器不是BFC，没有渲染隔离，所有子元素生成的盒子被平铺到了最外层。</p>\n<h2 id=\"3、当前的BFC不与外部的float-box重叠\"><a href=\"#3、当前的BFC不与外部的float-box重叠\" class=\"headerlink\" title=\"3、当前的BFC不与外部的float box重叠\"></a>3、当前的BFC不与外部的<code>float box</code>重叠</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;X-UA-Compatible&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>BFC<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">\t     <span class=\"hljs-selector-class\">.bfc</span> &#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">display</span>: flow-root;</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.float</span> &#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">float</span>: left;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#e98f53</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">40px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">40px</span>;</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.aside</span> &#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">200px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">200px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#696fa7</span>;</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-comment\">&lt;!-- 规则三：bfc区域不和浮动元素重叠 --&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;float&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;aside&quot;</span>&gt;</span>该元素非BFC，则该元素和小黄块重叠<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;float&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;aside bfc&quot;</span>&gt;</span>该元素BFC，则该元素和小黄块不重叠<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure>\n\n<p><img src=\"4.png\"></p>\n<h1 id=\"BFC的作用\"><a href=\"#BFC的作用\" class=\"headerlink\" title=\"BFC的作用\"></a>BFC的作用</h1><p>利用BFC的渲染规则，可以实现以下几个功能：</p>\n<ul>\n<li>自适应两栏布局</li>\n<li>阻止元素被浮动元素覆盖</li>\n<li>清除内部浮动</li>\n<li>阻止<code>margin</code>重叠：分属于不同的BFC时不发生重叠</li>\n</ul>\n<p>后面三条在实验中以及实现过了，但是针对第一条，如何利用BFC实现两栏布局呢？</p>\n<p>利用2个特性：</p>\n<ol>\n<li>块级元素<code>width:auto</code> 时，会自动拉伸至父元素左右边界处（横向占满）。</li>\n<li>BFC渲染规则：当前的BFC不与外部的<code>float box</code>重叠。</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;X-UA-Compatible&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>BFC<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.bfc</span> &#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">display</span>: flow-root;</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">\t\t\t\t<span class=\"hljs-selector-class\">.container</span> &#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid <span class=\"hljs-number\">#939393</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-number\">#f2f2f2</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">margin-bottom</span>: <span class=\"hljs-number\">20px</span>;</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.main</span>&#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">300px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-number\">#ddd</span>;</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.float-aside</span>&#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">150px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">float</span>: left;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-number\">#757575</span>;</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-comment\">&lt;!-- 利用bfc区域不和浮动元素重叠的特性，实现自适应两栏布局 --&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;bfc container&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;float-aside&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;bfc main&quot;</span>&gt;</span>设置float的宽度，然后给相邻的bfc元素不设置宽度，块级元素默认宽度为auto，那么该bfc元素会自动延伸到父元素的最右端<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p><img src=\"5.png\"></p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://juejin.cn/post/6844903476774830094\">[布局概念] 关于CSS-BFC深入理解</a><br><a href=\"https://drafts.csswg.org/css-display/#formatting-context\">CSS Display Module Level 4</a></p>\n","site":{"data":{"languages/zh-CN":{"name":"简体中文","home":{"menu":"首页","title":"首页"},"archive":{"menu":"归档","title":"归档","subtitle":"归档","post_total":"共计 %d 篇文章"},"category":{"menu":"分类","title":"分类","subtitle":"分类","post_total":"共计 %d 篇文章","more":"More..."},"tag":{"menu":"标签","title":"标签","subtitle":"标签","post_total":"共计 %d 篇文章"},"about":{"menu":"关于","title":"关于","subtitle":"关于"},"links":{"menu":"友链","title":"友链","subtitle":"友情链接"},"page404":{"menu":"页面不存在","title":"页面不存在","subtitle":"页面不存在"},"post":{"toc":"目录","prev_post":"上一篇","next_post":"下一篇","updated":"本文最后更新于：%s","meta":{"wordcount":"%s 字","min2read":"%s 分钟","views":"{} 次"},"copyright":{"author":"作者","posted":"发布于","updated":"更新于","licensed":"许可协议","CC":"CC - 知识共享许可协议","BY":"BY - 署名","SA":"SA - 相同方式共享","NC":"NC - 非商业性使用","ND":"ND - 禁止演绎"}},"footer":{"pv":"总访问量 {} 次","uv":"总访客数 {} 人"},"search":{"title":"搜索","keyword":"关键词"},"noscript_warning":"博客在允许 JavaScript 运行的环境下浏览效果更佳"}}},"more":"<h1 id=\"什么是BFC？\"><a href=\"#什么是BFC？\" class=\"headerlink\" title=\"什么是BFC？\"></a>什么是BFC？</h1><p>在了解BFC之前，先了解一下FC的定义。<strong>FC</strong>（Formatting Context 格式化上下文），FC指定了页面中一块独立区域的渲染规则，这个渲染规则可以理解为内部元素的布局规则。不同的FC有不同的规则定义。</p>\n<p>目前网页中几种FC的分类：</p>\n<ul>\n<li><strong>IFC</strong>（Inline Formatting Context）：行级格式化上下文</li>\n<li><strong>BFC</strong>（Block Formatting Context）：块格式化上下文<ul>\n<li>更多关于IFC / BFC的定义参考：<a href=\"https://www.w3.org/TR/CSS2/visuren.html#normal-flow\">CSS 2.1 Visual formatting model：Section 9.4</a></li>\n</ul>\n</li>\n<li><strong>FFC</strong>（Flex Formatting Context）：自适应格式化上下文<ul>\n<li>更多关于自适应布局的定义参考 ：<a href=\"https://drafts.csswg.org/css-flexbox-1/#flex-formatting-context\">Flexible Box Layout Module Level 1</a></li>\n</ul>\n</li>\n<li><strong>GFC</strong>（Grid Formatting Context）：网格布局格式化上下文</li>\n</ul>\n<h1 id=\"BFC的触发条件\"><a href=\"#BFC的触发条件\" class=\"headerlink\" title=\"BFC的触发条件\"></a>BFC的触发条件</h1><p>在以下几种情况下，会触发形成BFC：</p>\n<ul>\n<li>根元素<code>HTML</code></li>\n<li>浮动元素：<code>float</code> 属性不为<code>none</code></li>\n<li><code>position</code>定位：设置为 <code>absolute</code> 、<code>fixed</code></li>\n<li><code>overflow</code> 属性：设置为非<code>visible</code> 、<code>clip</code>的<strong>块</strong>元素</li>\n<li><code>display</code>属性：<ul>\n<li>设置为 <code>table</code>类型：<ul>\n<li><code>table</code>：对应<code>&lt;table&gt;</code></li>\n<li><code>table-caption</code>：HTML 表格标题默认值</li>\n<li><code>table-row</code>：对应<code>&lt;tr&gt;</code></li>\n<li><code>table-row-group</code>：<code>&lt;tbody&gt;</code></li>\n<li><code>table-header-group</code>：<code>&lt;thead&gt;</code></li>\n<li><code>table-footer-group</code>：<code>&lt;tfoot&gt;</code></li>\n<li><code>table-cell</code>：HTML 表格单元格默认值</li>\n<li><code>inline-table</code></li>\n</ul>\n</li>\n<li>设置为<code>inline-block</code></li>\n<li>设置为<code>flow-root</code></li>\n<li>设置为<code>flex</code>类型：父元素display属性为<code>flex</code> 或者 <code>inline-flex</code>，其子元素内部的布局规则为BFC（其子元素本身非<code>table</code>类型、<code>grid</code>类型、<code>flex</code>类型）</li>\n<li>设置为<code>grid</code>类型：父元素display属性为<code>gird</code> 或者 <code>inline-grid</code>，其子元素内部的布局规则为BFC（其子元素本身非<code>table</code>类型、<code>grid</code>类型、<code>flex</code>类型）</li>\n</ul>\n</li>\n<li><code>contain</code> 属性：<ul>\n<li><code>layout</code></li>\n<li><code>content</code></li>\n<li><code>paint</code></li>\n</ul>\n</li>\n<li><em>多列容器（暂时没有搞懂）</em></li>\n</ul>\n<h1 id=\"BFC渲染规则\"><a href=\"#BFC渲染规则\" class=\"headerlink\" title=\"BFC渲染规则\"></a>BFC渲染规则</h1><ul>\n<li>渲染隔离：一个BFC是页面上的一个隔离的独立容器，容器里面的子元素的排版布局不会直接影响到外面的元素（可能通过子元素影响父元素容器大小间接影响外部元素布局）。</li>\n<li>容器大小计算：区域大小由内部元素的边界确定：<ul>\n<li>即一个BFC容器会包裹所有的子元素块，无论该子元素是否是浮动元素，所以BFC的高度计算会包含<code>float</code>元素。</li>\n</ul>\n</li>\n<li><code>margin</code>重叠：<ul>\n<li>在同一个BFC中，相邻元素形成的<code>box</code>的上下<code>margin</code>产生重叠；</li>\n<li>但在不同的BFC中，各自的子元素的<code>margin</code>不重叠。</li>\n</ul>\n</li>\n<li>排布方向：<ul>\n<li>内部的子元素由上到下依次排布。</li>\n<li>内部子元素根据书写方向（<code>writing-mode</code>）确定从左开始排布还是从右开始排布。</li>\n<li>起始位置的子元素的<code>margin</code>紧贴父容器的<code>border</code>（只有起始方向的<code>margin</code>紧贴）。</li>\n</ul>\n</li>\n<li>当前的BFC不与外部的<code>float box</code>重叠。</li>\n</ul>\n<h1 id=\"实例验证\"><a href=\"#实例验证\" class=\"headerlink\" title=\"实例验证\"></a>实例验证</h1><h2 id=\"1、容器大小计算\"><a href=\"#1、容器大小计算\" class=\"headerlink\" title=\"1、容器大小计算\"></a>1、容器大小计算</h2><p>区域大小由内部元素的边界确定，高度计算包含<code>float</code>元素<br>当不给父容器设置高度的情况下，查看父容器的高度是如何计算的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"> <span class=\"hljs-comment\">&lt;!-- bfc的高度计算会包含float子元素 可以用作清除内部浮动 --&gt;</span><br><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>BFC<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.bfc</span> &#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">display</span>: flow-root;</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.container</span> &#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid <span class=\"hljs-number\">#939393</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-number\">#f2f2f2</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">margin-bottom</span>: <span class=\"hljs-number\">20px</span>;</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.float</span> &#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">float</span>: left;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#e98f53</span>;</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.child</span> &#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">40px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">40px</span>;</span><br><span class=\"language-css\">        &#125;  </span><br><span class=\"language-css\">    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>\t  <span class=\"hljs-comment\">&lt;!-- 父容器非BFC --&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;container&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;float child&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>\t\t<span class=\"hljs-comment\">&lt;!-- 父容器是BFC --&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;bfc container&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;margin-top: 100px&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;float child&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p><img src=\"1.png\"></p>\n<h2 id=\"2、margin重叠\"><a href=\"#2、margin重叠\" class=\"headerlink\" title=\"2、margin重叠\"></a>2、margin重叠</h2><p>同一个BFC中相邻的元素上下<code>margin</code>重叠<br>当给子元素设置</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>BFC<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.bfc</span> &#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">display</span>: flow-root;</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.container</span> &#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid <span class=\"hljs-number\">#939393</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-number\">#f2f2f2</span>;</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">       <span class=\"hljs-selector-class\">.bfc-child</span> &#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">40px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">30px</span> <span class=\"hljs-number\">0</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#ccc</span>;</span><br><span class=\"language-css\">       &#125;</span><br><span class=\"language-css\">    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;bfc container&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;bfc-child&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;bfc container&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;bfc-child&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;bfc-child&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p><img src=\"2.png\"></p>\n<p>相反，当父容器非BFC时，所有子元素（无论是否是平级）都会发生上下<code>margin</code>重叠。<br>将上面父容器的display属性改为<code>contents</code> ：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.bfc</span>&#123;<br>\t<span class=\"hljs-attribute\">display</span>: contents;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"3.png\"></p>\n<blockquote>\n<p>contents<br>These elements don’t produce a specific box by themselves. They are replaced by their pseudo-box and their child boxes. </p>\n<p>当设置元素为content时，该元素不会生成自己的box，而是会被子元素生成的box取代。</p>\n</blockquote>\n<p>会发现此时处于两个父级下的子元素，上下<code>margin</code>也会发生重叠。此时因为父容器不是BFC，没有渲染隔离，所有子元素生成的盒子被平铺到了最外层。</p>\n<h2 id=\"3、当前的BFC不与外部的float-box重叠\"><a href=\"#3、当前的BFC不与外部的float-box重叠\" class=\"headerlink\" title=\"3、当前的BFC不与外部的float box重叠\"></a>3、当前的BFC不与外部的<code>float box</code>重叠</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;X-UA-Compatible&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>BFC<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">\t     <span class=\"hljs-selector-class\">.bfc</span> &#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">display</span>: flow-root;</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.float</span> &#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">float</span>: left;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#e98f53</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">40px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">40px</span>;</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.aside</span> &#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">200px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">200px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#696fa7</span>;</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-comment\">&lt;!-- 规则三：bfc区域不和浮动元素重叠 --&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;float&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;aside&quot;</span>&gt;</span>该元素非BFC，则该元素和小黄块重叠<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;float&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;aside bfc&quot;</span>&gt;</span>该元素BFC，则该元素和小黄块不重叠<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure>\n\n<p><img src=\"4.png\"></p>\n<h1 id=\"BFC的作用\"><a href=\"#BFC的作用\" class=\"headerlink\" title=\"BFC的作用\"></a>BFC的作用</h1><p>利用BFC的渲染规则，可以实现以下几个功能：</p>\n<ul>\n<li>自适应两栏布局</li>\n<li>阻止元素被浮动元素覆盖</li>\n<li>清除内部浮动</li>\n<li>阻止<code>margin</code>重叠：分属于不同的BFC时不发生重叠</li>\n</ul>\n<p>后面三条在实验中以及实现过了，但是针对第一条，如何利用BFC实现两栏布局呢？</p>\n<p>利用2个特性：</p>\n<ol>\n<li>块级元素<code>width:auto</code> 时，会自动拉伸至父元素左右边界处（横向占满）。</li>\n<li>BFC渲染规则：当前的BFC不与外部的<code>float box</code>重叠。</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;X-UA-Compatible&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>BFC<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.bfc</span> &#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">display</span>: flow-root;</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">\t\t\t\t<span class=\"hljs-selector-class\">.container</span> &#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid <span class=\"hljs-number\">#939393</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-number\">#f2f2f2</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">margin-bottom</span>: <span class=\"hljs-number\">20px</span>;</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.main</span>&#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">300px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-number\">#ddd</span>;</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.float-aside</span>&#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">150px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">float</span>: left;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-number\">#757575</span>;</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-comment\">&lt;!-- 利用bfc区域不和浮动元素重叠的特性，实现自适应两栏布局 --&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;bfc container&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;float-aside&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;bfc main&quot;</span>&gt;</span>设置float的宽度，然后给相邻的bfc元素不设置宽度，块级元素默认宽度为auto，那么该bfc元素会自动延伸到父元素的最右端<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p><img src=\"5.png\"></p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://juejin.cn/post/6844903476774830094\">[布局概念] 关于CSS-BFC深入理解</a><br><a href=\"https://drafts.csswg.org/css-display/#formatting-context\">CSS Display Module Level 4</a></p>\n"},{"title":"JS正则表达式入门","date":"2023-03-03T07:09:17.000Z","excerpt":"正则表达式就是对字符串操作的一种逻辑公式，就像数学公式一样，通过按照一定的规则，组合使用`+ - * / （）=` 以及数字或者变量，形成一个表达式。","_content":"\n## 简单理解正则表达式\n\n正则表达式是用于匹配字符串中字符组合的模式，可以这样定义：\n\n> 正则表达式是对字符串（包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为“元字符”））操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。正则表达式是一种文本模式，该模式描述在搜索文本时要匹配的一个或多个字符串。\n>\n> 胡军伟, 秦奕青, 张伟. 正则表达式在Web信息抽取中的应用[J]. 北京信息科技大学学报(自然科学版), 2011, 26(6):86-89.\n\n可以简单理解为，正则表达式就是对字符串操作的一种逻辑公式，就像数学公式一样，通过按照一定的规则，组合使用`+ - * / （）=` 以及数字或者变量，形成一个表达式。正则表达式也是使用一些具有特殊含义的**特定符号**，来抽象表达符合某种规则的字符串。这种特定符号，我们称之为**元字符**。元字符按功能又可以分为以下几种类型：\n\n- 字符\n- 位置\n- 量词\n- 分支\n- 分组\n- 引用\n\n通过对不同类型的元字符进行任意组合，就可以生成一个模式，使用这个模式，就可以在任意字符串中匹配你想要的内容。在js中，我们一般使用 `/表达式/ `的字面量来表示这是一个正则表达式。\n\n\n\n## 字符类型\n\n在一个字符串中，如果我们想要要匹配某个或者某种类型的字符，我们可以选择**精确匹配**和**模糊匹配**。\n\n#### 模糊匹配\n\n模糊匹配就是一个**元字符**可以表示某一类字符集。\n\n下表列出了一些常用的元字符集：\n\n| 字符     | 定义                         | 描述                                                         |\n| -------- | ---------------------------- | ------------------------------------------------------------ |\n| `.`      | 通用符                       | 匹配除换行符（`\\n`、`\\r`）之外的任何单个字符                 |\n| `\\s`     | 空白符（space）              | 匹配任何**空白字符**，包括**空格**、**换页符**、**换行符**、**回车符**、**制表符**、**垂直制表符**<br />等价于 `[ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]`<br />⚠️ 这里有一个空格符号<br />⚠️ 记忆：空格符（十进制、八进制、十六进制） +  表中的特殊符号（十进制、八进制、十六进制） |\n| `\\S`     | 非空白符                     | 匹配任何**非**空白字符<br />等价于`[^ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]`（这里的`^`表示**非**的意思） |\n| `\\d`     | 数字符（digital）            | 匹配一个数字。等价于`[0-9]`                                  |\n| `\\D`     | 非数字符                     | 匹配一个非数字符。等价于`[^0-9]`                             |\n| `\\w`     | 字母、数字、下划线符（word） | 匹配一个单字字符（字母、数字或者下划线）。<br />等价于 `[A-Za-z0-9_]`。 |\n| `\\W`     | 非（字母、数字、下划线）符   | 匹配一个非单字字符。<br />等价于 `[^A-Za-z0-9_]`。           |\n| `\\f`     | 换页符（特殊符号）           |                                                              |\n| `\\n`     | 换行符（特殊符号）           |                                                              |\n| `\\r`     | 回车符（特殊符号）           |                                                              |\n| `\\t`     | 制表符（特殊符号）           |                                                              |\n| `\\v`     | 垂直制表符（特殊符号）       |                                                              |\n| `[xyz]`  | 自定义字符集                 | 你可以在字符集中任意组合元字符和普通字符，形成一个自定义字符集，从而使字符串去匹配方括号中的任意字符。<br />可以使用 `-` 破折号代表范围<br />🌰<br />`[xyz]`：可以匹配`x` `y` `z` 三个字符中的任意一个<br />`[0-9a-z]`：等价于`[0123456789zbcdefghijklmnopqrstuvwxyz]` 表示匹配任意一个数字或者小写字母<br />`[\\dAa-z]` ：表示可以匹配任意一个数字（`\\d`）或者小写字母(`a-z`)以及大写字母`A` |\n| `[^xyz]` | 自定义（排除）字符集         | 在方括号内部的开头加上`^`，表示匹配任意一个**不是**自定义字符集内部的字符。如果在中间加上非呢？<br />🌰<br />`[^xyz]`：匹配**排除**`x` `y` `z` 以外的任意一个字符<br />`[^\\dAa-z]` ：表示可以匹配任意一个 **不是** 数字（`\\d`） 且**不是**小写字母(`a-z`)且**不是**大写字母`A`的字符 |\n\n#### 精确匹配\n\n除**元字符**外，其他任意一个字符，只匹配字符本身。例如`/a/`，只能匹配字符串`abc`中的`a`。\n\n 如果想要匹配元字符**本身**，使用转义符号`\\`进行转义。\n\n🌰 想要匹配 `.` ，则写成`\\.`\n\n🌰 想要匹配`+`（量词类型元字符），则写成`\\+`\n\n\n\n#### 单字符匹配\n\n⚠️ 无论是模糊匹配还是精确匹配，在**不加量词**的情况下，一个**字符符号**（元字符或者普通符号）只能匹配单个字符。我们可以把正则里面的符号理解为占位符，一个萝卜一个坑。所以只要当前这个符号匹配到了字符，坑就被占了，下一个字符就需要有新的符号去匹配。所以我们如果要匹配多个字符，只要将多个**字符符号**组合在一起，形成一个子串模式，就能匹配一个满足条件的连续字符串。\n\n\n##### 匹配数字\n\n```javascript\nlet str = 'the id is: 123';\nlet reg = /\\d/;\n\nconsole.log(str.match(reg)); \n// [ '1', index: 11, input: 'the id is: 123', groups: undefined ]\n// match方法返回一个数组，其中数组的第一个元素表示匹配到的内容。\n// 可以看到每次只匹配一个字符\n```\n\n\n\n##### 替换空白符号\n\n```javascript\nlet str = 'the space is: \\n,\\f,\\r,\\t,\\v';\nlet reg = /\\s/g;\t// 将整个字符串中的空白符都替换为#\n\nconsole.log(str.replace(reg, '#'));\n// 一次只会匹配成功一个，replace方法的说明在下面\n//the#space#is:##,#,#,#,#\n```\n\n\n\n##### 删除所有非单字符\n\n```javascript\nlet str = '删除当前行中非数字(delete not number)123，(not word)非英文字母和非下划线_的符号！';\nlet reg = /\\W/g;\n\nconsole.log(str.replace(reg, ''));\t\n//deletenotnumber123notword_\n```\n\n\n\n##### 自定义字符集\n\n```javascript\nlet str = '在字符串中只留下字符集中的字符: 数字123，通配符. 普通英文字母wwwww';\n\nlet reg1 = /[^\\.数w]/g;\nconsole.log(str.replace(reg1, ''));\n// 数.wwwww\n\nlet reg2 = /[\\.数w]/g;\nconsole.log(str.replace(reg1, ''));\n//在字符串中只留下字符集中的字符: 字123，通配符 普通英文字母\n```\n\n\n\n## 位置类型\n\n什么是位置，什么又是位置字符呢？\n\n其实在一个连续的字符串中，相邻字符之间是存在一个位置的，我们可以把这个位置理解为空字符。如图所示（图源网络）：\n\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/5/1731e6ec5794d5c5~tplv-t2oaga2asx-image.image)\n\n在正则中，我们除了可以匹配具体字符以外，还可以使用元字符来表示具体要匹配哪个位置。\n\n在js中，表示位置的元字符分为4类：\n\n| 位置     | 相关元字符                                   |\n| -------- | -------------------------------------------- |\n| 开始     | `^`                                          |\n| 结尾     | `$`                                          |\n| 单词边界 | `\\b` `\\B`                                    |\n| 断言     | `(?=)`<br />`(?!)`<br />`(?<=)`<br />`(?<!)` |\n\n\n\n#### 开始\n\n元字符`^`既可以表示位置，也可以代表非。\n\n- 表示位置时：这个元字符写在整个正则表达式的最开始。\n- 表示非时：写在方括号`[]`的最开始。\n\n当表示开始位置，代表当前正则表达式**必须**从字符串的**最开始**进行匹配。如果不存在这个元字符，只要字符串中任意一个子串满足正则表达式即可。\n\n```javascript\nlet reg = /^\\d/;\t// 表示匹配到的字符串必须以数字开头\nlet str1 = \"abcdefg123\";\nlet str2 = \"123abcd\";\n\nconsole.log(reg.test(str1)) // false\nconsole.log(reg.test(str2)) // true\n```\n\n\n\n我们通常情况下都是对一个连续的单行字符串进行匹配，`^` 表示整个字符串的最开始。如果想要匹配多行文本中每行的开头，需要满足两个条件：\n\n1. 当前字符串需要使用换行符`\\n`分割形成多行文本，`^`表示换行符**后**紧跟的位置\n2. 需要将正则的多行标志`multiple`置为`true`（之后说明）\n\n```javascript\nlet reg = /^\\d+/mg;\t// m表示开启多行匹配。匹配当前多行文本中所有以数字开头的行，并获取开头的数字内容\nlet str = '123ad\\n0abc123\\nabc123';\nlet a = str.match(reg);\nconsole.log(a);\n\n//[ '123', '0' ]\n```\n\n\n\n#### 结束\n\n元字符 `$` 表示结束位置。匹配输入的结束。同 `^` 一样，如果多行标志被设置为 `true`，那么也匹配换行符`\\n`**前**紧贴的位置。\n\n```javascript\nlet reg = /\\d$/;\t// 表示匹配到的字符串必须以数字结尾\nlet str1 = \"abcdefg123\";\nlet str2 = \"123abcd\";\n\nconsole.log(reg.test(str1)) // true\nconsole.log(reg.test(str2)) // false\n```\n\n\n\n```javascript\nlet reg = /\\d+$/mg;\t// m表示开启多行匹配。匹配当前多行文本中所有以数字开头的行，并获取开头的数字内容\nlet str = '123ad\\n0abc2\\nabc3';\nlet a = str.match(reg);\nconsole.log(a);\n\n//[ '2', '3' ]\n```\n\n\n\n#### 单词边界\n\n其实在这里，`\\b` 表示单词边界的位置，`\\B`表示**非单词边界**的位置。\n\n那什么是单词呢？我们回到之前的字符类型的元字符表可以看到，`\\w`其实就是word，连续的word形成了words，就是代表了这里的单词。我们已经知道`\\w`等价于`[A-Za-z0-9_]`，所以这里的单词就是指带了这些字符。\n\n那边界的定义又是什么？\n\n我们已知，每两个相邻字符之间，都存在一个位置，如果相邻两个字符都属于`\\w`，那这两个相邻字符之间的位置就叫**非单词边界`\\B`**；如果两个相邻字符**只有一个**字符属于`\\w`，或者**两个都不属于**`\\w`，那它们之间的位置就叫做**单词边界`\\b`**。 （`b`可以理解为`break`）\n\n需要注意的一点，字符串的开始和结束，都算作单词边界。可以理解为在字符串的开始和结束，存在一个空字符`\"\"` ，那么无论相邻的字符是否属于`\\w`，都存在一个空字符`\"\"`不属于`\\w`。\n\n\n```javascript\nlet breakReg = /\\b/g,\n    notBreakReg = /\\B/g;\nlet str = \"word_break.mp3\";\nlet bStr = str.replace(breakReg, \"|\");\nlet Bstr = str.replace(notBreakReg, \"|\");\nconsole.log(\"bStr is: \", bStr);\nconsole.log(\"Bstr is: \", Bstr);\n\n\n// bStr is:  |word_break|.|mp3|\n// Bstr is:  w|o|r|d|_|b|r|e|a|k.m|p|3\n```\n\n\n\n#### 断言\n\n> 零宽断言正如它的名字一样，是一种零宽度的匹配，它匹配到的内容不会保存到匹配结果中去，最终匹配结果只是一个位置而已。\n> 作用是给指定位置添加一个限定条件，用来规定此位置之前或者之后的字符必须满足限定条件才能使正则中的字表达式匹配成功。\n>\n> ​\t\t\t\t\t\t\t\t\t \t\t\t\t     ——源自博客《正则表达式零宽断言详解》\n\n听起来断言很复杂，其实道理很简单。所谓断言，其实就是我们的正则表达式在**匹配位置**的时候，必须要满足一定的条件才行。这里的条件，就是一个子表达式，其中断言又分为：\n\n- 先行：\n  - 正向：`(?=子表达式)`\n  - 负向：`(?!子表达式)`\n- 后行：\n  - 正向：`(?<=子表达式)`\n  - 负向：`(?<!子表达式)`\n\n在这里，先行和后行为相反组，表示匹配的位置在前还是在后；正向和负向为相反组，表示是否满足条件。组合起来的意思就是：\n\n- 正向先行`(?=)`：匹配**满足**子表达式的字符串**前面**的位置\n- 正向后行`(?<=)`：匹配**满足**子表达式的字符串**后面**的位置\n- 负向先行`(?!)`：匹配**不满足**子表达式的字符串**前面**的位置\n- 负向后行`(?<!)`：匹配**不满足**子表达式的字符串**后面**的位置\n\n\n简单记忆：\n\n- 正向：满足\n- 负向：不满足\n- 先行：前面\n- 后行：后面\n\n\n\n##### 正向（先/后）行\n\n```javascript\nlet str = '在js前面插入===,后面插入---: 前端基础三件套html,css,js; node, npm, react或者vue是新的三件套';\n\nlet reg1 = /(?=js)/g;\nconsole.log(str.replace(reg1, '==='));\n// 在===js前面插入===,后面插入---: 前端基础三件套html,css,===js; node, npm, react或者vue是新的三件套\n\n\nlet reg2 = /(?<=js)/g;\nconsole.log(str.replace(reg2, '---'));\n// 在js---前面插入===,后面插入---: 前端基础三件套html,css,js---; node, npm, react或者vue是新的三件套\n```\n\n\n##### 负向（先/后）行\n\n```javascript\nlet str = 'the number is 0000'; \n// 在所有非字母和非空白符的字符前插入 ===，后面插入---\n// 实际上在这个字符串中会有三个字符会匹配成功：数字字符、字符串的开始空字符、结束空字符。\n\nlet reg1 = /(?![a-zA-Z\\s])/g;\nconsole.log(str.replace(reg1, '==='));\n// the number is ===0===0===0===0===\n// 最后一个===实际上是匹配到了结束空字符''，在结束空字符前插入了===\n\nlet reg2 = /(?<![a-zA-Z\\s])/g;\nconsole.log(str.replace(reg2, '---'));\n// ---the number is 0---0---0---0---\n// 第一个---实际上是匹配到了开始空字符''，在开始空字符后插入了---\n```\n\n\n\n\n\n## 量词类型\n\n根据前面的了解，我们知道 一个符号只能匹配一个字符，如果要匹配多个字符，就需要组合多个符号（包括元字符和普通字符）来进行匹配。但是如果要匹配一个连续重复的字符串`aaaaaaaaa`，按照前面的逻辑，我们的正则表达式要写出 `/aaaaaaaaa/` 才行。有没有更简便的方法呢？\n\n答案是有的。\n\n在正则中，存在这种量词类型的元字符，来简化表达式本身。例如上面的正则表达式我们可以写成`/a{9}/`，表示当前满足条件，能匹配成功的子串包含9个连续的a。\n\n量词类型的元字符用来表示重复次数，具体重复的对象，是前面紧跟的子模式。\n\n其中，量词元字符包括：\n\n| 字符     | 描述           |\n| -------- | -------------- |\n| `*`      | 重复0到n次     |\n| `+`      | 重复1到n次     |\n| `?`      | 出现0次或者1次 |\n| `{n}`    | 重复n次        |\n| `{n,}`   | 至少重复n次    |\n| `{n, m}` | 重复n到m次     |\n\n\n\n例如：\n\n```javascript\nlet str = 'the number is 0000123122, phone number is 057-9981013';\n\nlet reg1 = /\\d+/g;\nlet reg2 = /[num]{3}/g;\nlet reg3 = /0{2,4}/g;\nlet reg4 = /,?/;\n\nconsole.log(str.match(reg1))\n// [ '0000123122', '057', '9981013' ]\n\nconsole.log(str.match(reg2))\n// [ 'num', 'num' ]\n\nconsole.log(str.match(reg3))\n// [ '0000' ]\n\nconsole.log(reg4.test(str))\n// true\n```\n\n\n\n## 分组类型\n\n我们已知如何匹配一段由一个字符重复n次构成的字符串，例如 `aaaaaa` 。假如现在我们的字符串是`123xyzxyzxyz1axyzxyz`，很明显，这串字符中也存在重复的子串，但是并不满足单字符重复的特点，我们无法使用已经学到的东西来写出正则表达式。这个时候，就是分组类型的元字符上场的时候了。\n\n分组由圆括号 `()` 来表示。括号内部是子表达式，表示一个子串的匹配模式。说白了，分组就是把一些特殊的单字符组合看作一个单元，我们在匹配时，遇到这样的单元就当做一个整体来处理。具体是哪些特殊字符的组合，就可以任意定义，然后写成子模式。例如上面的字符串，我们把`xyz`看作一个单元，想要匹配出`xyz`，就可以这样写：\n\n```javascript\nlet str = \"123xyzxyzxyz1axyzxyz\";\nlet reg = /(xyz)/g;\nlet match = str.match(reg);\n\n// [ 'xyz', 'xyz', 'xyz', 'xyz', 'xyz' ]\n```\n\n\n\n如果把连续的两个甚至多个`xyz`看作一个单元来匹配，只需要需要在分组后添加量词即可。\n\n```javascript\nlet str = \"123xyzxyzxyz1axyzxyz\";\nlet reg = /(xyz)+/g;\nlet match = str.match(reg);\n\n// [ 'xyzxyzxyz', 'xyzxyz' ]\n```\n\n\n\n在分组类型的元字符中，有三种类型：\n\n| **捕获分组**     | **`（子表达式）`**    |\n| ---------------- | --------------------- |\n| **命名捕获分组** | **(?<name>子表达式)** |\n| **非捕获分组**   | **`(?:子表达式)`**    |\n\n\n\n##### 捕获与非捕获\n\n其区别就在于，当我们使用捕获分组的时候，每个子表达式匹配到的内容都会被分别记录下来，后面我们可以通过相应的api或者是引用类型的元字符获取到不同分组的匹配项；而非捕获分组就是不记录这个匹配项。例如：\n\n```javascript\nlet reg = /(\\d+)(?:[a-z]+)/;\t\nlet str = \"123abcd\";\n\nconsole.log(str.match(reg))\n// [ '123abcd', '123', index: 0, input: '123abcd', groups: undefined ]\n// 在这里，123abcd是整个正则匹配到的内容，而123则是我们捕获分组匹配到的内容\n// 可以看到，此时非捕获分组匹配到的内容并没有被保存下来，我们无法单独获取\n```\n\n\n\n##### 匿名捕获与命名捕获\n\n其中捕获分组又分为命名和匿名分组，匿名分组则使用索引值来获取，而命名分组除了可以使用索引值访问以外，还可以通过指定的属性访问获取。\n\n```javascript\nlet reg = /(\\d+)(?<char>[a-z]+)/;\nlet str = \"123abcd\";\n\nconsole.log(str.match(reg))\n```\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/5/1731e6ccb87320ec~tplv-t2oaga2asx-image.image)\n\n\n从结果中我们可以看到，使用命名捕获分组匹配到的分组，不但可以通过索引值来获取，还可以通过`groups.char`获取。\n\n## 引用类型\n\n引用，其实就是对捕获分组匹配到的内容的引用。\n\n在两个地方可以使用引用：\n\n- 在表达式本式中\n- 在相关的函数中\n\n##### 表达式中的引用\n\n在表达式中，有两种方法来获取引用：\n\n| 元字符     | 说明                                                         |\n| ---------- | ------------------------------------------------------------ |\n| `\\n`       | 匿名捕获分组的引用。它返回第n个子捕获匹配到的具体的内容(捕获的数目以左括号计数，即不论是否嵌套分组，命名捕获还是匿名捕获，都是按照左括号来计算，第一个左括号捕获的分组就是`\\1`, 第二个分组就是`\\2` ...)。 |\n| `\\k<name>` | 返回具体某个命名捕获分组的内容。                             |\n\n例如：判断一个字符串数组所有元素是否完全相等\n\n```javascript\nlet arr = ['abc', 'abc', 'abc'];\nlet str = arr.join(','); // abc,abc,abc\nlet reg = /(\\w+),\\1/; // 在这里，\\1 就表示了第一个分组获取到的具体内容。\n\nlet match = reg.test(str);\nconsole.log(match); // true\n```\n\n\n\n当然我们也可以使用命名捕获：\n\n```javascript\nlet arr = ['item', 'item', 'item'];\nlet str = arr.join(',')+',';\t// item,item,item,\nlet reg = /(?<element>\\w+)(,)\\k<element>\\2/; // 等价于/(?<element>\\w+)(,)\\1\\2/\n\nlet match = reg.test(str);\nconsole.log(match); // true\n```\n\n\n\n##### 相关函数中的引用\n\n在函数中有两种，一种是特殊字符指代，一种是函数参数。\n\n例如在`string.prototype.replace`中，可以使用特殊字符 `$n` 来指代分组，同样的，数字 `n `代表分组索引。\n\n```javascript\n// 交换位置\nlet names = 'john,marry,jerry';\nlet new_names = names.replace(/(\\w+),(\\w+),(\\w+)/, '$2,$3,$1');\nconsole.log(new_names); \n\n// marry,jerry,john\n```\n\n\n\n也可以在函数参数中使用：\n\n```javascript\n// 交换位置\nlet names = 'john,marry,jerry';\nlet new_names = names.replace(/(\\w+),(\\w+),(\\w+)/, function(content, n1, n2, n3){\n    return `${n3} ${n2} ${n1}`;\n});\nconsole.log(new_names); \n// jerry marry john\n```\n\n\n\n具体的 `replace` 方法介绍在下面。\n\n\n\n## 分支类型\n\n当我们在匹配一个字符串时，如果存在其中某部分子串，既可以是A，又可以是B，就可以使用分支元字符。\n\n| 元字符 | 定义 |\n| ------ | ---- |\n| `|`    | 或者 |\n\n\n\n```javascript\nlet strArr = ['year','mouth','day'];\nlet reg = /mouth|day/;\t//  匹配mouth或者day\n\nstrArr.forEach(str => {\n     console.log(str, \": \", reg.test(str));\n})\n\n\n// year :  false\n// mouth :  true\n// day :  true\n```\n\n\n\n\n\n如果需要匹配这样一个字符串，既可以是A，又可以是B，同时又要满足C的时候，还可以结合分组来使用\n\n例如匹配 `\"window98 / window2000 / window10\"` 这样一个字符串：\n\n```javascript\nlet wins = ['window98','window2000', 'window10', 'window99'];\nlet reg = /window(98|2000|10)/;\n\nwins.forEach(str => {\n    console.log(str, \": \", reg.test(str));\n})\n\n// window98 :  true\n// window2000 :  true\n// window10 :  true\n// window99 :  false\n```\n\n\n\n## JS中的正则\n\nJS中与正则相关的主要有两种对象，`String` 对象和 `RegExp` 对象。\n\n### RegExp对象\n\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/5/1731e6dd6df72f7b~tplv-t2oaga2asx-image.image)\n\n#### 创建\n\n##### 字面量\n\n```javascript\nlet reg = /\\d/\n```\n\n\n\n##### 构造函数\n\n```javascript\nlet reg = new RegExp('ab+c', 'i'); // 使用字符串创建\nlet reg1 =new RegExp(/ab+c/, 'i'); // 使用字面量创建\n```\n\n\n\n##### 工厂函数\n\n```javascript\nlet reg = RegExp('ab+c', 'i');\t// 使用字符串创建\nlet reg1 =RegExp(/ab+c/, 'i');\t// 使用字面量创建\n```\n\n\n\n注意：在使用RegExp方法创建正则表达式时，如果想要 `string` 类型的参数中使用元字符时，需要转义，例如：\n\n```javascript\n// 想要构建出 /\\d+/ 这样的表达式\nlet reg = RegExp('\\d+', 'i');\t\n// 此时创建出来的结果是 /d+/ 而不是目标表达式\n\n// 正确的写法应该是：\n// RegExp('\\\\d+', 'i');\t\n```\n\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/5/1731e6e2936db248~tplv-t2oaga2asx-image.image)\n\n#### lastIndex\n\n保存了当前正则实例上次匹配的位置。表示下次匹配从哪里开始。这个属性只有正则表达式使用了表示全局检索的 \"`g`\" 标志时，该属性才会起作用。所以当我们在使用全局匹配时，需要注意当前这个值是否被修改。**MDN**中是这样定义的：\n\n> - 如果 `lastIndex` 大于字符串的长度，则 `regexp.test` 和 `regexp.exec` 将会匹配失败，然后 `lastIndex` 被设置为 0。\n> - 如果 `lastIndex` 等于字符串的长度，且该正则表达式匹配空字符串，则该正则表达式匹配从 `lastIndex` 开始的字符串。（then the regular expression matches input starting at `lastIndex`.）\n> - 如果 `lastIndex` 等于字符串的长度，且该正则表达式不匹配空字符串 ，则该正则表达式不匹配字符串，`lastIndex` 被设置为 0.。\n> - 否则，`lastIndex` 被设置为紧随最近一次成功匹配的下一个位置。\n\n例如\n\n```javascript\nlet reg = /\\d+/g;\n\nfunction matchNumber(str){\n    return reg.test(str);\n}\n\nconsole.log(matchNumber('123')); // true\nconsole.log(matchNumber('456')); // false\n```\n\n上面的方法，我们期望返回两个`true`，但实际第一个确实返回`true`，第二个却返回了 `false`，这是因为我们的正则是一个全局变量，所以每次调用之后更改了`lastIndex`， 而每次的匹配都从`lastIndex`开始，所以第二次匹配，传入`456`实际会从第四个字符开始匹配。此时第四个字符为空，所以返回 `false`\n\n```javascript\nlet reg = /\\d+/g;\n\nfunction matchNumber(str){\n    console.log(\"reg.lastIndex is: \", reg.lastIndex);\n    return reg.test(str);\n}\n\nconsole.log(matchNumber('123')); // true\nconsole.log(matchNumber('456')); // false\nconsole.log(matchNumber('4'));\n/**\nreg.lastIndex is:  0\ntrue\n\nreg.lastIndex is:  3\nfalse\n\nreg.lastIndex is:  0\t\ntrue\n*/\n```\n\n\n\n#### 方法\n\n##### test\n\n测试当前字符串是否满足某个模式\n\n参数：`str` 要匹配正则表达式的字符串。\n\n返回：`boolean`值，表示是否匹配成功\n\n例如判断当前字符串是否由11位数字组成：\n\n```javascript\nlet reg = /^\\d{11}$/;\nlet phone_number = '13577898320';\n\nreg.test(phone_number); // true\n```\n\n\n\n##### exec\n\n方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 [`null`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null)。\n\n参数：`str` 要匹配正则表达式的字符串。\n\n返回：一个数组：\n\n| 对象             | 描述                               |\n| ---------------- | ---------------------------------- |\n| `[0]`            | 匹配的全部字符串                   |\n| `[1], ...[*n* ]` | 括号中的分组捕获                   |\n| `index`          | 匹配到的字符位于原始字符串的索引值 |\n| `input`          | 原始字符串                         |\n| `groups`         | 命名捕获对象                       |\n\n⚠️：在js与正则相关的函数中，调用这个函数，会涉及到正则对象的状态。MDN中是这样解释的：\n\n> 在设置了 [`global`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/global) 或 [`sticky`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky) 标志位的情况下（如 `/foo/g` or `/foo/y`），JavaScript [`RegExp`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp) 对象是**有状态**的。他们会将上次成功匹配后的位置记录在 [`lastIndex`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex) 属性中。使用此特性，`exec()` 可用来对单个字符串中的多次匹配结果进行逐条的遍历（包括捕获到的匹配），而相比之下， [`String.prototype.match()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match) 只会返回匹配到的结果。\n\n提取出字符串中所有的数字\n\n```javascript\nlet str = '各科成绩如下:数学: 121;语文: 120;英语: 138'\nlet reg = /\\d+/g;\nlet result = null;\nlet i = 0;\nwhile ((result = reg.exec(str)) !== null) {\n\tconsole.log(`-------------第${++i}次循环开始------------------`)\n\tconsole.log(\"result is: \", result); \n    console.log(\"reg.lastIndex is: \", reg.lastIndex); \n    console.log(`-------------第${++i}次循环结束------------------`)\n}\n\n\n/**\n-------------第1次循环开始------------------\nresult is:  [ '121',\n  index: 11,\n  input: '各科成绩如下:数学: 121;语文: 120;英语: 138',\n  groups: undefined ]\n  \nreg.lastIndex is:  14\n-------------第1次循环结束------------------\n\n-------------第2次循环开始------------------\nresult is:  [ '120',\n  index: 19,\n  input: '各科成绩如下:数学: 121;语文: 120;英语: 138',\n  groups: undefined ]\nreg.lastIndex is:  22\n-------------第2次循环结束------------------\n\n-------------第3次循环开始------------------\nresult is:  [ '138',\n  index: 27,\n  input: '各科成绩如下:数学: 121;语文: 120;英语: 138',\n  groups: undefined ]\n  \nreg.lastIndex is:  30\n-------------第3次循环结束------------------\n*/\n\n```\n\n\n\n### String对象\n\nString对象中涉及到正则的主要有4个方法：\n\n- `search`\n- `match`\n- `replace`\n- `split`\n\n而其中，`match`方法中，正则表达式的 `global` 的不同值会影响返回结果。\n\n\n\n#### search \n\n`search`方法很简单，主要用来查找子串的位置。\n\n- 参数：一个正则表达式，必填\n- 返回：找到的第一个子串在字符串中的索引值，如果没有找到就返回 `-1` \n\n```javascript\nlet str = 'find subString index: subString';\nlet reg1 = /subString/;\nlet reg2 = /substring/;\nlet reg3 = /subString/g;\n\nstr.search(reg1);\t\t// 5\nstr.search(reg1);\t\t// -1\nstr.search(reg1);\t\t// 5 此时有无global都不影响结果\n```\n\n\n\n#### match\n\n`match `方法中，主要用来提取字符串中满足条件的子串。\n\n- 参数：正则表达式，，必填。这个正则表达式的 `global` 标志的值会影响返回结果：\n  - `global == true` ：返回一个数组，包含了整个字符串中所有满足条件的子串。 \n  - `global == false`： 返回\n    - 数组`arr` ：\n      - `arr[0]` 是当前正则匹配到的第一个子串的值\n      - `arr[1] - arr[n]` ：分别是当前分组中捕获到的内容，有多少个分组就有多少项。且按照分组的顺序存储\n    - `index` ：当前匹配到的子串在整个字符串中的索引值\n    - `input` ：源字符串\n    - `groups`：对象，包含了所有命名捕获组匹配到的内容 ，如果没有定义命名捕获组则为`undefined`\n\n```javascript\nlet str = 'find subString index: subString';\nlet reg1 = /subString/;\nlet reg2 = /substring/;\nlet reg3 = /subString/g;\n\nstr.match(reg1);\n/**\n[\n  'subString',\n  index: 5,\n  input: 'find subString index: subString',\n  groups: undefined\n]\n**/\nstr.match(reg2);\t// null\nstr.match(reg3);\t// [ 'subString', 'subString' ]\n```\n\n\n\n#### replace\n\n`replace`方法，就是用指定的值来替换源字符串中一些特定的子串。\n\n- 参数：\n\n  - `pattern`： 模式，指定被替换的子串类型。可以是一个 `String`，也可以是一个 `RegExp` \n\n    -  `String` \n    -  `RegExp`：当为`RegExp`对象时，如果 `global`标志为`false`，则只会替换匹配到的第一个子串。\n\n  - `replacement`： 替换值，用于替换指定的子串。可以是一个 `String`，也可以是一个`Function`\n\n    - `String`：如果pattern是一个`RegExp`，还可以使用一些特殊字符来插入命令：\n\n      - | **`?`** | **插入一个 \"$\"**                 |\n        | -------- | -------------------------------- |\n        | **`$&`** | **插入匹配的子串**               |\n        | **$`**   | **插入当前匹配的子串左边的内容** |\n        | **`$'`** | **插入当前匹配的子串右边的内容** |\n        | **`$n`** | **插入指定的捕获组内容**         |\n\n    - `Function`：替换函数，可以指定返回的新字符串。只有第一个参数为正则时才生效。\n\n      - > 你可以指定一个函数作为第二个参数。在这种情况下，当匹配执行后，该函数就会执行。 函数的返回值作为替换字符串。 (注意：上面提到的特殊替换参数在这里不能被使用。) 另外要注意的是，如果第一个参数是正则表达式，**并且其为全局匹配模式**，那么这个方法将被多次调用，每次匹配都会被调用。（源自MDN）\n\n      - 参数：\n\n        - `match`：每次匹配到的子串。\n        - `p1,p2, ...`：假如`replace` 的 `pattern` 参数是一个 `RegExp`，则这里就是分别指代了各个分组匹配到的内容。\n        - `offset`：匹配到的子字符串在原字符串中的偏移量。\n        - `string`：源字符串。\n        - `NamedCaptureGroup`： 命名捕获组匹配的对象\n\n      - 返回：替换后的新字符串。\n\n- 返回：替换后的新字符串。\n\n\n\n有四种组合方式：\n\n##### 组合一：string + string\n\n```javascript\nlet str = '把名字替换成新的: john';\nlet new_str = str.replace('john', 'jerry');\nconsole.log(\"new_str is: \", new_str);\n// new_str is: 把名字替换成新的：jerry\n```\n\n\n\n##### 组合二：regexp + string\n\n```javascript\nlet str = '把名字替换成新的：john';\nlet new_str = str.replace(/john/, 'jerry');\nconsole.log(\"new_str is: \", new_str);\n// new_str is: 把名字替换成新的：jerry\n```\n\n\n\n##### 组合三：regexp + 特殊符号\n\n```javascript\nlet str = '交换名字：john,jerry'\nlet new_str = str.replace(/(\\w+),(\\w+)/, '$2,$1');\nconsole.log(\"new_str is: \", new_str);\n// new_str is: 交换名字：jerry,john\n```\n\n\n\n##### 组合四：regexp + function\n\n```javascript\nlet str = '交换名字：john,jerry'\nlet new_str = str.replace(/(?<person1>\\w+),(?<person2>\\w+)/, function(match, n1, n2, offset, input, groups){\n    console.log(\"match:\",match);\n    console.log(\"n1:\",n1);\n    console.log(\"n2:\",n2);\n    console.log(\"offset:\",offset);\n    console.log(\"input:\",input);\n    console.log(\"groups:\",groups);\n    return `${n2} && ${n1}`;\n});\nconsole.log(\"new_str is: \", new_str);\n\n/**\n    match: john,jerry\n    n1: john\n    n2: jerry\n    offset: 5\n    input: 交换名字：john,jerry\n    groups: { person1: 'john', person2: 'jerry' }\n    new_str is:  交换名字：jerry && john\n*/\n```\n\n\n\n#### split\n\n`split`方法主要用于分割字符串。\n\n- 参数：\n  - `separator` 分隔符，必填。可以是字符串或者正则表达式\n  - `limit` 限制，可选。限定返回的分割片段数量。\n- 返回：数组`arr`，包含了被分割后的片段。\n\n##### `limit` 限制\n\n```javascript\nlet str = '123,44a,234a,1';\nlet all = str.split(',');\nlet part = str.split(',', 2);\nconsole.log(\"all is: \", all);\nconsole.log(\"part is: \", part);\n// all is:  [ '123', '44a', '234a', '1' ]\n// part is:  [ '123', '44a' ]\n```\n\n\n\n##### 使用正则分割\n\n```javascript\nlet str = 'year4mouth12days';\nlet label = str.split(/\\d+/);\nconsole.log(\"label is: \", label);\n// label is:  [ 'year', 'mouth', 'days' ] \n```\n\n\n\n\n## 参考\n\n[JS正则表达式完整教程（略长）](https://juejin.im/post/6844903487155732494)\n\n[Python 正则表达式操作指南](https://wizardforcel.gitbooks.io/py-re-guide/content/)\n\n[正则表达式30分钟入门教程（正则表达式入门教程）](https://www.bookstack.cn/read/deerchao-regex/README.md)\n\n[正则表达式零宽断言详解](https://www.cnblogs.com/onepixel/articles/7717789.html)\n\n[MDN 正则表达式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions)\n\n[MDN RegExp](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp)\n\n[MDN String](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String)","source":"_posts/JS正则表达式入门.md","raw":"---\ntitle: JS正则表达式入门\ndate: 2023-03-03 15:09:17\ncategory: [Web前端, javascript, 正则表达式]\ntags: <span class=\"label label-primary\">正则表达式</span>\nexcerpt: 正则表达式就是对字符串操作的一种逻辑公式，就像数学公式一样，通过按照一定的规则，组合使用`+ - * / （）=` 以及数字或者变量，形成一个表达式。\n---\n\n## 简单理解正则表达式\n\n正则表达式是用于匹配字符串中字符组合的模式，可以这样定义：\n\n> 正则表达式是对字符串（包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为“元字符”））操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。正则表达式是一种文本模式，该模式描述在搜索文本时要匹配的一个或多个字符串。\n>\n> 胡军伟, 秦奕青, 张伟. 正则表达式在Web信息抽取中的应用[J]. 北京信息科技大学学报(自然科学版), 2011, 26(6):86-89.\n\n可以简单理解为，正则表达式就是对字符串操作的一种逻辑公式，就像数学公式一样，通过按照一定的规则，组合使用`+ - * / （）=` 以及数字或者变量，形成一个表达式。正则表达式也是使用一些具有特殊含义的**特定符号**，来抽象表达符合某种规则的字符串。这种特定符号，我们称之为**元字符**。元字符按功能又可以分为以下几种类型：\n\n- 字符\n- 位置\n- 量词\n- 分支\n- 分组\n- 引用\n\n通过对不同类型的元字符进行任意组合，就可以生成一个模式，使用这个模式，就可以在任意字符串中匹配你想要的内容。在js中，我们一般使用 `/表达式/ `的字面量来表示这是一个正则表达式。\n\n\n\n## 字符类型\n\n在一个字符串中，如果我们想要要匹配某个或者某种类型的字符，我们可以选择**精确匹配**和**模糊匹配**。\n\n#### 模糊匹配\n\n模糊匹配就是一个**元字符**可以表示某一类字符集。\n\n下表列出了一些常用的元字符集：\n\n| 字符     | 定义                         | 描述                                                         |\n| -------- | ---------------------------- | ------------------------------------------------------------ |\n| `.`      | 通用符                       | 匹配除换行符（`\\n`、`\\r`）之外的任何单个字符                 |\n| `\\s`     | 空白符（space）              | 匹配任何**空白字符**，包括**空格**、**换页符**、**换行符**、**回车符**、**制表符**、**垂直制表符**<br />等价于 `[ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]`<br />⚠️ 这里有一个空格符号<br />⚠️ 记忆：空格符（十进制、八进制、十六进制） +  表中的特殊符号（十进制、八进制、十六进制） |\n| `\\S`     | 非空白符                     | 匹配任何**非**空白字符<br />等价于`[^ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]`（这里的`^`表示**非**的意思） |\n| `\\d`     | 数字符（digital）            | 匹配一个数字。等价于`[0-9]`                                  |\n| `\\D`     | 非数字符                     | 匹配一个非数字符。等价于`[^0-9]`                             |\n| `\\w`     | 字母、数字、下划线符（word） | 匹配一个单字字符（字母、数字或者下划线）。<br />等价于 `[A-Za-z0-9_]`。 |\n| `\\W`     | 非（字母、数字、下划线）符   | 匹配一个非单字字符。<br />等价于 `[^A-Za-z0-9_]`。           |\n| `\\f`     | 换页符（特殊符号）           |                                                              |\n| `\\n`     | 换行符（特殊符号）           |                                                              |\n| `\\r`     | 回车符（特殊符号）           |                                                              |\n| `\\t`     | 制表符（特殊符号）           |                                                              |\n| `\\v`     | 垂直制表符（特殊符号）       |                                                              |\n| `[xyz]`  | 自定义字符集                 | 你可以在字符集中任意组合元字符和普通字符，形成一个自定义字符集，从而使字符串去匹配方括号中的任意字符。<br />可以使用 `-` 破折号代表范围<br />🌰<br />`[xyz]`：可以匹配`x` `y` `z` 三个字符中的任意一个<br />`[0-9a-z]`：等价于`[0123456789zbcdefghijklmnopqrstuvwxyz]` 表示匹配任意一个数字或者小写字母<br />`[\\dAa-z]` ：表示可以匹配任意一个数字（`\\d`）或者小写字母(`a-z`)以及大写字母`A` |\n| `[^xyz]` | 自定义（排除）字符集         | 在方括号内部的开头加上`^`，表示匹配任意一个**不是**自定义字符集内部的字符。如果在中间加上非呢？<br />🌰<br />`[^xyz]`：匹配**排除**`x` `y` `z` 以外的任意一个字符<br />`[^\\dAa-z]` ：表示可以匹配任意一个 **不是** 数字（`\\d`） 且**不是**小写字母(`a-z`)且**不是**大写字母`A`的字符 |\n\n#### 精确匹配\n\n除**元字符**外，其他任意一个字符，只匹配字符本身。例如`/a/`，只能匹配字符串`abc`中的`a`。\n\n 如果想要匹配元字符**本身**，使用转义符号`\\`进行转义。\n\n🌰 想要匹配 `.` ，则写成`\\.`\n\n🌰 想要匹配`+`（量词类型元字符），则写成`\\+`\n\n\n\n#### 单字符匹配\n\n⚠️ 无论是模糊匹配还是精确匹配，在**不加量词**的情况下，一个**字符符号**（元字符或者普通符号）只能匹配单个字符。我们可以把正则里面的符号理解为占位符，一个萝卜一个坑。所以只要当前这个符号匹配到了字符，坑就被占了，下一个字符就需要有新的符号去匹配。所以我们如果要匹配多个字符，只要将多个**字符符号**组合在一起，形成一个子串模式，就能匹配一个满足条件的连续字符串。\n\n\n##### 匹配数字\n\n```javascript\nlet str = 'the id is: 123';\nlet reg = /\\d/;\n\nconsole.log(str.match(reg)); \n// [ '1', index: 11, input: 'the id is: 123', groups: undefined ]\n// match方法返回一个数组，其中数组的第一个元素表示匹配到的内容。\n// 可以看到每次只匹配一个字符\n```\n\n\n\n##### 替换空白符号\n\n```javascript\nlet str = 'the space is: \\n,\\f,\\r,\\t,\\v';\nlet reg = /\\s/g;\t// 将整个字符串中的空白符都替换为#\n\nconsole.log(str.replace(reg, '#'));\n// 一次只会匹配成功一个，replace方法的说明在下面\n//the#space#is:##,#,#,#,#\n```\n\n\n\n##### 删除所有非单字符\n\n```javascript\nlet str = '删除当前行中非数字(delete not number)123，(not word)非英文字母和非下划线_的符号！';\nlet reg = /\\W/g;\n\nconsole.log(str.replace(reg, ''));\t\n//deletenotnumber123notword_\n```\n\n\n\n##### 自定义字符集\n\n```javascript\nlet str = '在字符串中只留下字符集中的字符: 数字123，通配符. 普通英文字母wwwww';\n\nlet reg1 = /[^\\.数w]/g;\nconsole.log(str.replace(reg1, ''));\n// 数.wwwww\n\nlet reg2 = /[\\.数w]/g;\nconsole.log(str.replace(reg1, ''));\n//在字符串中只留下字符集中的字符: 字123，通配符 普通英文字母\n```\n\n\n\n## 位置类型\n\n什么是位置，什么又是位置字符呢？\n\n其实在一个连续的字符串中，相邻字符之间是存在一个位置的，我们可以把这个位置理解为空字符。如图所示（图源网络）：\n\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/5/1731e6ec5794d5c5~tplv-t2oaga2asx-image.image)\n\n在正则中，我们除了可以匹配具体字符以外，还可以使用元字符来表示具体要匹配哪个位置。\n\n在js中，表示位置的元字符分为4类：\n\n| 位置     | 相关元字符                                   |\n| -------- | -------------------------------------------- |\n| 开始     | `^`                                          |\n| 结尾     | `$`                                          |\n| 单词边界 | `\\b` `\\B`                                    |\n| 断言     | `(?=)`<br />`(?!)`<br />`(?<=)`<br />`(?<!)` |\n\n\n\n#### 开始\n\n元字符`^`既可以表示位置，也可以代表非。\n\n- 表示位置时：这个元字符写在整个正则表达式的最开始。\n- 表示非时：写在方括号`[]`的最开始。\n\n当表示开始位置，代表当前正则表达式**必须**从字符串的**最开始**进行匹配。如果不存在这个元字符，只要字符串中任意一个子串满足正则表达式即可。\n\n```javascript\nlet reg = /^\\d/;\t// 表示匹配到的字符串必须以数字开头\nlet str1 = \"abcdefg123\";\nlet str2 = \"123abcd\";\n\nconsole.log(reg.test(str1)) // false\nconsole.log(reg.test(str2)) // true\n```\n\n\n\n我们通常情况下都是对一个连续的单行字符串进行匹配，`^` 表示整个字符串的最开始。如果想要匹配多行文本中每行的开头，需要满足两个条件：\n\n1. 当前字符串需要使用换行符`\\n`分割形成多行文本，`^`表示换行符**后**紧跟的位置\n2. 需要将正则的多行标志`multiple`置为`true`（之后说明）\n\n```javascript\nlet reg = /^\\d+/mg;\t// m表示开启多行匹配。匹配当前多行文本中所有以数字开头的行，并获取开头的数字内容\nlet str = '123ad\\n0abc123\\nabc123';\nlet a = str.match(reg);\nconsole.log(a);\n\n//[ '123', '0' ]\n```\n\n\n\n#### 结束\n\n元字符 `$` 表示结束位置。匹配输入的结束。同 `^` 一样，如果多行标志被设置为 `true`，那么也匹配换行符`\\n`**前**紧贴的位置。\n\n```javascript\nlet reg = /\\d$/;\t// 表示匹配到的字符串必须以数字结尾\nlet str1 = \"abcdefg123\";\nlet str2 = \"123abcd\";\n\nconsole.log(reg.test(str1)) // true\nconsole.log(reg.test(str2)) // false\n```\n\n\n\n```javascript\nlet reg = /\\d+$/mg;\t// m表示开启多行匹配。匹配当前多行文本中所有以数字开头的行，并获取开头的数字内容\nlet str = '123ad\\n0abc2\\nabc3';\nlet a = str.match(reg);\nconsole.log(a);\n\n//[ '2', '3' ]\n```\n\n\n\n#### 单词边界\n\n其实在这里，`\\b` 表示单词边界的位置，`\\B`表示**非单词边界**的位置。\n\n那什么是单词呢？我们回到之前的字符类型的元字符表可以看到，`\\w`其实就是word，连续的word形成了words，就是代表了这里的单词。我们已经知道`\\w`等价于`[A-Za-z0-9_]`，所以这里的单词就是指带了这些字符。\n\n那边界的定义又是什么？\n\n我们已知，每两个相邻字符之间，都存在一个位置，如果相邻两个字符都属于`\\w`，那这两个相邻字符之间的位置就叫**非单词边界`\\B`**；如果两个相邻字符**只有一个**字符属于`\\w`，或者**两个都不属于**`\\w`，那它们之间的位置就叫做**单词边界`\\b`**。 （`b`可以理解为`break`）\n\n需要注意的一点，字符串的开始和结束，都算作单词边界。可以理解为在字符串的开始和结束，存在一个空字符`\"\"` ，那么无论相邻的字符是否属于`\\w`，都存在一个空字符`\"\"`不属于`\\w`。\n\n\n```javascript\nlet breakReg = /\\b/g,\n    notBreakReg = /\\B/g;\nlet str = \"word_break.mp3\";\nlet bStr = str.replace(breakReg, \"|\");\nlet Bstr = str.replace(notBreakReg, \"|\");\nconsole.log(\"bStr is: \", bStr);\nconsole.log(\"Bstr is: \", Bstr);\n\n\n// bStr is:  |word_break|.|mp3|\n// Bstr is:  w|o|r|d|_|b|r|e|a|k.m|p|3\n```\n\n\n\n#### 断言\n\n> 零宽断言正如它的名字一样，是一种零宽度的匹配，它匹配到的内容不会保存到匹配结果中去，最终匹配结果只是一个位置而已。\n> 作用是给指定位置添加一个限定条件，用来规定此位置之前或者之后的字符必须满足限定条件才能使正则中的字表达式匹配成功。\n>\n> ​\t\t\t\t\t\t\t\t\t \t\t\t\t     ——源自博客《正则表达式零宽断言详解》\n\n听起来断言很复杂，其实道理很简单。所谓断言，其实就是我们的正则表达式在**匹配位置**的时候，必须要满足一定的条件才行。这里的条件，就是一个子表达式，其中断言又分为：\n\n- 先行：\n  - 正向：`(?=子表达式)`\n  - 负向：`(?!子表达式)`\n- 后行：\n  - 正向：`(?<=子表达式)`\n  - 负向：`(?<!子表达式)`\n\n在这里，先行和后行为相反组，表示匹配的位置在前还是在后；正向和负向为相反组，表示是否满足条件。组合起来的意思就是：\n\n- 正向先行`(?=)`：匹配**满足**子表达式的字符串**前面**的位置\n- 正向后行`(?<=)`：匹配**满足**子表达式的字符串**后面**的位置\n- 负向先行`(?!)`：匹配**不满足**子表达式的字符串**前面**的位置\n- 负向后行`(?<!)`：匹配**不满足**子表达式的字符串**后面**的位置\n\n\n简单记忆：\n\n- 正向：满足\n- 负向：不满足\n- 先行：前面\n- 后行：后面\n\n\n\n##### 正向（先/后）行\n\n```javascript\nlet str = '在js前面插入===,后面插入---: 前端基础三件套html,css,js; node, npm, react或者vue是新的三件套';\n\nlet reg1 = /(?=js)/g;\nconsole.log(str.replace(reg1, '==='));\n// 在===js前面插入===,后面插入---: 前端基础三件套html,css,===js; node, npm, react或者vue是新的三件套\n\n\nlet reg2 = /(?<=js)/g;\nconsole.log(str.replace(reg2, '---'));\n// 在js---前面插入===,后面插入---: 前端基础三件套html,css,js---; node, npm, react或者vue是新的三件套\n```\n\n\n##### 负向（先/后）行\n\n```javascript\nlet str = 'the number is 0000'; \n// 在所有非字母和非空白符的字符前插入 ===，后面插入---\n// 实际上在这个字符串中会有三个字符会匹配成功：数字字符、字符串的开始空字符、结束空字符。\n\nlet reg1 = /(?![a-zA-Z\\s])/g;\nconsole.log(str.replace(reg1, '==='));\n// the number is ===0===0===0===0===\n// 最后一个===实际上是匹配到了结束空字符''，在结束空字符前插入了===\n\nlet reg2 = /(?<![a-zA-Z\\s])/g;\nconsole.log(str.replace(reg2, '---'));\n// ---the number is 0---0---0---0---\n// 第一个---实际上是匹配到了开始空字符''，在开始空字符后插入了---\n```\n\n\n\n\n\n## 量词类型\n\n根据前面的了解，我们知道 一个符号只能匹配一个字符，如果要匹配多个字符，就需要组合多个符号（包括元字符和普通字符）来进行匹配。但是如果要匹配一个连续重复的字符串`aaaaaaaaa`，按照前面的逻辑，我们的正则表达式要写出 `/aaaaaaaaa/` 才行。有没有更简便的方法呢？\n\n答案是有的。\n\n在正则中，存在这种量词类型的元字符，来简化表达式本身。例如上面的正则表达式我们可以写成`/a{9}/`，表示当前满足条件，能匹配成功的子串包含9个连续的a。\n\n量词类型的元字符用来表示重复次数，具体重复的对象，是前面紧跟的子模式。\n\n其中，量词元字符包括：\n\n| 字符     | 描述           |\n| -------- | -------------- |\n| `*`      | 重复0到n次     |\n| `+`      | 重复1到n次     |\n| `?`      | 出现0次或者1次 |\n| `{n}`    | 重复n次        |\n| `{n,}`   | 至少重复n次    |\n| `{n, m}` | 重复n到m次     |\n\n\n\n例如：\n\n```javascript\nlet str = 'the number is 0000123122, phone number is 057-9981013';\n\nlet reg1 = /\\d+/g;\nlet reg2 = /[num]{3}/g;\nlet reg3 = /0{2,4}/g;\nlet reg4 = /,?/;\n\nconsole.log(str.match(reg1))\n// [ '0000123122', '057', '9981013' ]\n\nconsole.log(str.match(reg2))\n// [ 'num', 'num' ]\n\nconsole.log(str.match(reg3))\n// [ '0000' ]\n\nconsole.log(reg4.test(str))\n// true\n```\n\n\n\n## 分组类型\n\n我们已知如何匹配一段由一个字符重复n次构成的字符串，例如 `aaaaaa` 。假如现在我们的字符串是`123xyzxyzxyz1axyzxyz`，很明显，这串字符中也存在重复的子串，但是并不满足单字符重复的特点，我们无法使用已经学到的东西来写出正则表达式。这个时候，就是分组类型的元字符上场的时候了。\n\n分组由圆括号 `()` 来表示。括号内部是子表达式，表示一个子串的匹配模式。说白了，分组就是把一些特殊的单字符组合看作一个单元，我们在匹配时，遇到这样的单元就当做一个整体来处理。具体是哪些特殊字符的组合，就可以任意定义，然后写成子模式。例如上面的字符串，我们把`xyz`看作一个单元，想要匹配出`xyz`，就可以这样写：\n\n```javascript\nlet str = \"123xyzxyzxyz1axyzxyz\";\nlet reg = /(xyz)/g;\nlet match = str.match(reg);\n\n// [ 'xyz', 'xyz', 'xyz', 'xyz', 'xyz' ]\n```\n\n\n\n如果把连续的两个甚至多个`xyz`看作一个单元来匹配，只需要需要在分组后添加量词即可。\n\n```javascript\nlet str = \"123xyzxyzxyz1axyzxyz\";\nlet reg = /(xyz)+/g;\nlet match = str.match(reg);\n\n// [ 'xyzxyzxyz', 'xyzxyz' ]\n```\n\n\n\n在分组类型的元字符中，有三种类型：\n\n| **捕获分组**     | **`（子表达式）`**    |\n| ---------------- | --------------------- |\n| **命名捕获分组** | **(?<name>子表达式)** |\n| **非捕获分组**   | **`(?:子表达式)`**    |\n\n\n\n##### 捕获与非捕获\n\n其区别就在于，当我们使用捕获分组的时候，每个子表达式匹配到的内容都会被分别记录下来，后面我们可以通过相应的api或者是引用类型的元字符获取到不同分组的匹配项；而非捕获分组就是不记录这个匹配项。例如：\n\n```javascript\nlet reg = /(\\d+)(?:[a-z]+)/;\t\nlet str = \"123abcd\";\n\nconsole.log(str.match(reg))\n// [ '123abcd', '123', index: 0, input: '123abcd', groups: undefined ]\n// 在这里，123abcd是整个正则匹配到的内容，而123则是我们捕获分组匹配到的内容\n// 可以看到，此时非捕获分组匹配到的内容并没有被保存下来，我们无法单独获取\n```\n\n\n\n##### 匿名捕获与命名捕获\n\n其中捕获分组又分为命名和匿名分组，匿名分组则使用索引值来获取，而命名分组除了可以使用索引值访问以外，还可以通过指定的属性访问获取。\n\n```javascript\nlet reg = /(\\d+)(?<char>[a-z]+)/;\nlet str = \"123abcd\";\n\nconsole.log(str.match(reg))\n```\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/5/1731e6ccb87320ec~tplv-t2oaga2asx-image.image)\n\n\n从结果中我们可以看到，使用命名捕获分组匹配到的分组，不但可以通过索引值来获取，还可以通过`groups.char`获取。\n\n## 引用类型\n\n引用，其实就是对捕获分组匹配到的内容的引用。\n\n在两个地方可以使用引用：\n\n- 在表达式本式中\n- 在相关的函数中\n\n##### 表达式中的引用\n\n在表达式中，有两种方法来获取引用：\n\n| 元字符     | 说明                                                         |\n| ---------- | ------------------------------------------------------------ |\n| `\\n`       | 匿名捕获分组的引用。它返回第n个子捕获匹配到的具体的内容(捕获的数目以左括号计数，即不论是否嵌套分组，命名捕获还是匿名捕获，都是按照左括号来计算，第一个左括号捕获的分组就是`\\1`, 第二个分组就是`\\2` ...)。 |\n| `\\k<name>` | 返回具体某个命名捕获分组的内容。                             |\n\n例如：判断一个字符串数组所有元素是否完全相等\n\n```javascript\nlet arr = ['abc', 'abc', 'abc'];\nlet str = arr.join(','); // abc,abc,abc\nlet reg = /(\\w+),\\1/; // 在这里，\\1 就表示了第一个分组获取到的具体内容。\n\nlet match = reg.test(str);\nconsole.log(match); // true\n```\n\n\n\n当然我们也可以使用命名捕获：\n\n```javascript\nlet arr = ['item', 'item', 'item'];\nlet str = arr.join(',')+',';\t// item,item,item,\nlet reg = /(?<element>\\w+)(,)\\k<element>\\2/; // 等价于/(?<element>\\w+)(,)\\1\\2/\n\nlet match = reg.test(str);\nconsole.log(match); // true\n```\n\n\n\n##### 相关函数中的引用\n\n在函数中有两种，一种是特殊字符指代，一种是函数参数。\n\n例如在`string.prototype.replace`中，可以使用特殊字符 `$n` 来指代分组，同样的，数字 `n `代表分组索引。\n\n```javascript\n// 交换位置\nlet names = 'john,marry,jerry';\nlet new_names = names.replace(/(\\w+),(\\w+),(\\w+)/, '$2,$3,$1');\nconsole.log(new_names); \n\n// marry,jerry,john\n```\n\n\n\n也可以在函数参数中使用：\n\n```javascript\n// 交换位置\nlet names = 'john,marry,jerry';\nlet new_names = names.replace(/(\\w+),(\\w+),(\\w+)/, function(content, n1, n2, n3){\n    return `${n3} ${n2} ${n1}`;\n});\nconsole.log(new_names); \n// jerry marry john\n```\n\n\n\n具体的 `replace` 方法介绍在下面。\n\n\n\n## 分支类型\n\n当我们在匹配一个字符串时，如果存在其中某部分子串，既可以是A，又可以是B，就可以使用分支元字符。\n\n| 元字符 | 定义 |\n| ------ | ---- |\n| `|`    | 或者 |\n\n\n\n```javascript\nlet strArr = ['year','mouth','day'];\nlet reg = /mouth|day/;\t//  匹配mouth或者day\n\nstrArr.forEach(str => {\n     console.log(str, \": \", reg.test(str));\n})\n\n\n// year :  false\n// mouth :  true\n// day :  true\n```\n\n\n\n\n\n如果需要匹配这样一个字符串，既可以是A，又可以是B，同时又要满足C的时候，还可以结合分组来使用\n\n例如匹配 `\"window98 / window2000 / window10\"` 这样一个字符串：\n\n```javascript\nlet wins = ['window98','window2000', 'window10', 'window99'];\nlet reg = /window(98|2000|10)/;\n\nwins.forEach(str => {\n    console.log(str, \": \", reg.test(str));\n})\n\n// window98 :  true\n// window2000 :  true\n// window10 :  true\n// window99 :  false\n```\n\n\n\n## JS中的正则\n\nJS中与正则相关的主要有两种对象，`String` 对象和 `RegExp` 对象。\n\n### RegExp对象\n\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/5/1731e6dd6df72f7b~tplv-t2oaga2asx-image.image)\n\n#### 创建\n\n##### 字面量\n\n```javascript\nlet reg = /\\d/\n```\n\n\n\n##### 构造函数\n\n```javascript\nlet reg = new RegExp('ab+c', 'i'); // 使用字符串创建\nlet reg1 =new RegExp(/ab+c/, 'i'); // 使用字面量创建\n```\n\n\n\n##### 工厂函数\n\n```javascript\nlet reg = RegExp('ab+c', 'i');\t// 使用字符串创建\nlet reg1 =RegExp(/ab+c/, 'i');\t// 使用字面量创建\n```\n\n\n\n注意：在使用RegExp方法创建正则表达式时，如果想要 `string` 类型的参数中使用元字符时，需要转义，例如：\n\n```javascript\n// 想要构建出 /\\d+/ 这样的表达式\nlet reg = RegExp('\\d+', 'i');\t\n// 此时创建出来的结果是 /d+/ 而不是目标表达式\n\n// 正确的写法应该是：\n// RegExp('\\\\d+', 'i');\t\n```\n\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/5/1731e6e2936db248~tplv-t2oaga2asx-image.image)\n\n#### lastIndex\n\n保存了当前正则实例上次匹配的位置。表示下次匹配从哪里开始。这个属性只有正则表达式使用了表示全局检索的 \"`g`\" 标志时，该属性才会起作用。所以当我们在使用全局匹配时，需要注意当前这个值是否被修改。**MDN**中是这样定义的：\n\n> - 如果 `lastIndex` 大于字符串的长度，则 `regexp.test` 和 `regexp.exec` 将会匹配失败，然后 `lastIndex` 被设置为 0。\n> - 如果 `lastIndex` 等于字符串的长度，且该正则表达式匹配空字符串，则该正则表达式匹配从 `lastIndex` 开始的字符串。（then the regular expression matches input starting at `lastIndex`.）\n> - 如果 `lastIndex` 等于字符串的长度，且该正则表达式不匹配空字符串 ，则该正则表达式不匹配字符串，`lastIndex` 被设置为 0.。\n> - 否则，`lastIndex` 被设置为紧随最近一次成功匹配的下一个位置。\n\n例如\n\n```javascript\nlet reg = /\\d+/g;\n\nfunction matchNumber(str){\n    return reg.test(str);\n}\n\nconsole.log(matchNumber('123')); // true\nconsole.log(matchNumber('456')); // false\n```\n\n上面的方法，我们期望返回两个`true`，但实际第一个确实返回`true`，第二个却返回了 `false`，这是因为我们的正则是一个全局变量，所以每次调用之后更改了`lastIndex`， 而每次的匹配都从`lastIndex`开始，所以第二次匹配，传入`456`实际会从第四个字符开始匹配。此时第四个字符为空，所以返回 `false`\n\n```javascript\nlet reg = /\\d+/g;\n\nfunction matchNumber(str){\n    console.log(\"reg.lastIndex is: \", reg.lastIndex);\n    return reg.test(str);\n}\n\nconsole.log(matchNumber('123')); // true\nconsole.log(matchNumber('456')); // false\nconsole.log(matchNumber('4'));\n/**\nreg.lastIndex is:  0\ntrue\n\nreg.lastIndex is:  3\nfalse\n\nreg.lastIndex is:  0\t\ntrue\n*/\n```\n\n\n\n#### 方法\n\n##### test\n\n测试当前字符串是否满足某个模式\n\n参数：`str` 要匹配正则表达式的字符串。\n\n返回：`boolean`值，表示是否匹配成功\n\n例如判断当前字符串是否由11位数字组成：\n\n```javascript\nlet reg = /^\\d{11}$/;\nlet phone_number = '13577898320';\n\nreg.test(phone_number); // true\n```\n\n\n\n##### exec\n\n方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 [`null`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null)。\n\n参数：`str` 要匹配正则表达式的字符串。\n\n返回：一个数组：\n\n| 对象             | 描述                               |\n| ---------------- | ---------------------------------- |\n| `[0]`            | 匹配的全部字符串                   |\n| `[1], ...[*n* ]` | 括号中的分组捕获                   |\n| `index`          | 匹配到的字符位于原始字符串的索引值 |\n| `input`          | 原始字符串                         |\n| `groups`         | 命名捕获对象                       |\n\n⚠️：在js与正则相关的函数中，调用这个函数，会涉及到正则对象的状态。MDN中是这样解释的：\n\n> 在设置了 [`global`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/global) 或 [`sticky`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky) 标志位的情况下（如 `/foo/g` or `/foo/y`），JavaScript [`RegExp`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp) 对象是**有状态**的。他们会将上次成功匹配后的位置记录在 [`lastIndex`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex) 属性中。使用此特性，`exec()` 可用来对单个字符串中的多次匹配结果进行逐条的遍历（包括捕获到的匹配），而相比之下， [`String.prototype.match()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match) 只会返回匹配到的结果。\n\n提取出字符串中所有的数字\n\n```javascript\nlet str = '各科成绩如下:数学: 121;语文: 120;英语: 138'\nlet reg = /\\d+/g;\nlet result = null;\nlet i = 0;\nwhile ((result = reg.exec(str)) !== null) {\n\tconsole.log(`-------------第${++i}次循环开始------------------`)\n\tconsole.log(\"result is: \", result); \n    console.log(\"reg.lastIndex is: \", reg.lastIndex); \n    console.log(`-------------第${++i}次循环结束------------------`)\n}\n\n\n/**\n-------------第1次循环开始------------------\nresult is:  [ '121',\n  index: 11,\n  input: '各科成绩如下:数学: 121;语文: 120;英语: 138',\n  groups: undefined ]\n  \nreg.lastIndex is:  14\n-------------第1次循环结束------------------\n\n-------------第2次循环开始------------------\nresult is:  [ '120',\n  index: 19,\n  input: '各科成绩如下:数学: 121;语文: 120;英语: 138',\n  groups: undefined ]\nreg.lastIndex is:  22\n-------------第2次循环结束------------------\n\n-------------第3次循环开始------------------\nresult is:  [ '138',\n  index: 27,\n  input: '各科成绩如下:数学: 121;语文: 120;英语: 138',\n  groups: undefined ]\n  \nreg.lastIndex is:  30\n-------------第3次循环结束------------------\n*/\n\n```\n\n\n\n### String对象\n\nString对象中涉及到正则的主要有4个方法：\n\n- `search`\n- `match`\n- `replace`\n- `split`\n\n而其中，`match`方法中，正则表达式的 `global` 的不同值会影响返回结果。\n\n\n\n#### search \n\n`search`方法很简单，主要用来查找子串的位置。\n\n- 参数：一个正则表达式，必填\n- 返回：找到的第一个子串在字符串中的索引值，如果没有找到就返回 `-1` \n\n```javascript\nlet str = 'find subString index: subString';\nlet reg1 = /subString/;\nlet reg2 = /substring/;\nlet reg3 = /subString/g;\n\nstr.search(reg1);\t\t// 5\nstr.search(reg1);\t\t// -1\nstr.search(reg1);\t\t// 5 此时有无global都不影响结果\n```\n\n\n\n#### match\n\n`match `方法中，主要用来提取字符串中满足条件的子串。\n\n- 参数：正则表达式，，必填。这个正则表达式的 `global` 标志的值会影响返回结果：\n  - `global == true` ：返回一个数组，包含了整个字符串中所有满足条件的子串。 \n  - `global == false`： 返回\n    - 数组`arr` ：\n      - `arr[0]` 是当前正则匹配到的第一个子串的值\n      - `arr[1] - arr[n]` ：分别是当前分组中捕获到的内容，有多少个分组就有多少项。且按照分组的顺序存储\n    - `index` ：当前匹配到的子串在整个字符串中的索引值\n    - `input` ：源字符串\n    - `groups`：对象，包含了所有命名捕获组匹配到的内容 ，如果没有定义命名捕获组则为`undefined`\n\n```javascript\nlet str = 'find subString index: subString';\nlet reg1 = /subString/;\nlet reg2 = /substring/;\nlet reg3 = /subString/g;\n\nstr.match(reg1);\n/**\n[\n  'subString',\n  index: 5,\n  input: 'find subString index: subString',\n  groups: undefined\n]\n**/\nstr.match(reg2);\t// null\nstr.match(reg3);\t// [ 'subString', 'subString' ]\n```\n\n\n\n#### replace\n\n`replace`方法，就是用指定的值来替换源字符串中一些特定的子串。\n\n- 参数：\n\n  - `pattern`： 模式，指定被替换的子串类型。可以是一个 `String`，也可以是一个 `RegExp` \n\n    -  `String` \n    -  `RegExp`：当为`RegExp`对象时，如果 `global`标志为`false`，则只会替换匹配到的第一个子串。\n\n  - `replacement`： 替换值，用于替换指定的子串。可以是一个 `String`，也可以是一个`Function`\n\n    - `String`：如果pattern是一个`RegExp`，还可以使用一些特殊字符来插入命令：\n\n      - | **`?`** | **插入一个 \"$\"**                 |\n        | -------- | -------------------------------- |\n        | **`$&`** | **插入匹配的子串**               |\n        | **$`**   | **插入当前匹配的子串左边的内容** |\n        | **`$'`** | **插入当前匹配的子串右边的内容** |\n        | **`$n`** | **插入指定的捕获组内容**         |\n\n    - `Function`：替换函数，可以指定返回的新字符串。只有第一个参数为正则时才生效。\n\n      - > 你可以指定一个函数作为第二个参数。在这种情况下，当匹配执行后，该函数就会执行。 函数的返回值作为替换字符串。 (注意：上面提到的特殊替换参数在这里不能被使用。) 另外要注意的是，如果第一个参数是正则表达式，**并且其为全局匹配模式**，那么这个方法将被多次调用，每次匹配都会被调用。（源自MDN）\n\n      - 参数：\n\n        - `match`：每次匹配到的子串。\n        - `p1,p2, ...`：假如`replace` 的 `pattern` 参数是一个 `RegExp`，则这里就是分别指代了各个分组匹配到的内容。\n        - `offset`：匹配到的子字符串在原字符串中的偏移量。\n        - `string`：源字符串。\n        - `NamedCaptureGroup`： 命名捕获组匹配的对象\n\n      - 返回：替换后的新字符串。\n\n- 返回：替换后的新字符串。\n\n\n\n有四种组合方式：\n\n##### 组合一：string + string\n\n```javascript\nlet str = '把名字替换成新的: john';\nlet new_str = str.replace('john', 'jerry');\nconsole.log(\"new_str is: \", new_str);\n// new_str is: 把名字替换成新的：jerry\n```\n\n\n\n##### 组合二：regexp + string\n\n```javascript\nlet str = '把名字替换成新的：john';\nlet new_str = str.replace(/john/, 'jerry');\nconsole.log(\"new_str is: \", new_str);\n// new_str is: 把名字替换成新的：jerry\n```\n\n\n\n##### 组合三：regexp + 特殊符号\n\n```javascript\nlet str = '交换名字：john,jerry'\nlet new_str = str.replace(/(\\w+),(\\w+)/, '$2,$1');\nconsole.log(\"new_str is: \", new_str);\n// new_str is: 交换名字：jerry,john\n```\n\n\n\n##### 组合四：regexp + function\n\n```javascript\nlet str = '交换名字：john,jerry'\nlet new_str = str.replace(/(?<person1>\\w+),(?<person2>\\w+)/, function(match, n1, n2, offset, input, groups){\n    console.log(\"match:\",match);\n    console.log(\"n1:\",n1);\n    console.log(\"n2:\",n2);\n    console.log(\"offset:\",offset);\n    console.log(\"input:\",input);\n    console.log(\"groups:\",groups);\n    return `${n2} && ${n1}`;\n});\nconsole.log(\"new_str is: \", new_str);\n\n/**\n    match: john,jerry\n    n1: john\n    n2: jerry\n    offset: 5\n    input: 交换名字：john,jerry\n    groups: { person1: 'john', person2: 'jerry' }\n    new_str is:  交换名字：jerry && john\n*/\n```\n\n\n\n#### split\n\n`split`方法主要用于分割字符串。\n\n- 参数：\n  - `separator` 分隔符，必填。可以是字符串或者正则表达式\n  - `limit` 限制，可选。限定返回的分割片段数量。\n- 返回：数组`arr`，包含了被分割后的片段。\n\n##### `limit` 限制\n\n```javascript\nlet str = '123,44a,234a,1';\nlet all = str.split(',');\nlet part = str.split(',', 2);\nconsole.log(\"all is: \", all);\nconsole.log(\"part is: \", part);\n// all is:  [ '123', '44a', '234a', '1' ]\n// part is:  [ '123', '44a' ]\n```\n\n\n\n##### 使用正则分割\n\n```javascript\nlet str = 'year4mouth12days';\nlet label = str.split(/\\d+/);\nconsole.log(\"label is: \", label);\n// label is:  [ 'year', 'mouth', 'days' ] \n```\n\n\n\n\n## 参考\n\n[JS正则表达式完整教程（略长）](https://juejin.im/post/6844903487155732494)\n\n[Python 正则表达式操作指南](https://wizardforcel.gitbooks.io/py-re-guide/content/)\n\n[正则表达式30分钟入门教程（正则表达式入门教程）](https://www.bookstack.cn/read/deerchao-regex/README.md)\n\n[正则表达式零宽断言详解](https://www.cnblogs.com/onepixel/articles/7717789.html)\n\n[MDN 正则表达式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions)\n\n[MDN RegExp](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp)\n\n[MDN String](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String)","slug":"JS正则表达式入门","published":1,"updated":"2023-03-03T07:27:45.145Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clesk19g70003dddffkmthmwi","content":"<h2 id=\"简单理解正则表达式\"><a href=\"#简单理解正则表达式\" class=\"headerlink\" title=\"简单理解正则表达式\"></a>简单理解正则表达式</h2><p>正则表达式是用于匹配字符串中字符组合的模式，可以这样定义：</p>\n<blockquote>\n<p>正则表达式是对字符串（包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为“元字符”））操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。正则表达式是一种文本模式，该模式描述在搜索文本时要匹配的一个或多个字符串。</p>\n<p>胡军伟, 秦奕青, 张伟. 正则表达式在Web信息抽取中的应用[J]. 北京信息科技大学学报(自然科学版), 2011, 26(6):86-89.</p>\n</blockquote>\n<p>可以简单理解为，正则表达式就是对字符串操作的一种逻辑公式，就像数学公式一样，通过按照一定的规则，组合使用<code>+ - * / （）=</code> 以及数字或者变量，形成一个表达式。正则表达式也是使用一些具有特殊含义的<strong>特定符号</strong>，来抽象表达符合某种规则的字符串。这种特定符号，我们称之为<strong>元字符</strong>。元字符按功能又可以分为以下几种类型：</p>\n<ul>\n<li>字符</li>\n<li>位置</li>\n<li>量词</li>\n<li>分支</li>\n<li>分组</li>\n<li>引用</li>\n</ul>\n<p>通过对不同类型的元字符进行任意组合，就可以生成一个模式，使用这个模式，就可以在任意字符串中匹配你想要的内容。在js中，我们一般使用 <code>/表达式/ </code>的字面量来表示这是一个正则表达式。</p>\n<h2 id=\"字符类型\"><a href=\"#字符类型\" class=\"headerlink\" title=\"字符类型\"></a>字符类型</h2><p>在一个字符串中，如果我们想要要匹配某个或者某种类型的字符，我们可以选择<strong>精确匹配</strong>和<strong>模糊匹配</strong>。</p>\n<h4 id=\"模糊匹配\"><a href=\"#模糊匹配\" class=\"headerlink\" title=\"模糊匹配\"></a>模糊匹配</h4><p>模糊匹配就是一个<strong>元字符</strong>可以表示某一类字符集。</p>\n<p>下表列出了一些常用的元字符集：</p>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>定义</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>.</code></td>\n<td>通用符</td>\n<td>匹配除换行符（<code>\\n</code>、<code>\\r</code>）之外的任何单个字符</td>\n</tr>\n<tr>\n<td><code>\\s</code></td>\n<td>空白符（space）</td>\n<td>匹配任何<strong>空白字符</strong>，包括<strong>空格</strong>、<strong>换页符</strong>、<strong>换行符</strong>、<strong>回车符</strong>、<strong>制表符</strong>、<strong>垂直制表符</strong><br />等价于 <code>[ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]</code><br />⚠️ 这里有一个空格符号<br />⚠️ 记忆：空格符（十进制、八进制、十六进制） +  表中的特殊符号（十进制、八进制、十六进制）</td>\n</tr>\n<tr>\n<td><code>\\S</code></td>\n<td>非空白符</td>\n<td>匹配任何<strong>非</strong>空白字符<br />等价于<code>[^ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]</code>（这里的<code>^</code>表示<strong>非</strong>的意思）</td>\n</tr>\n<tr>\n<td><code>\\d</code></td>\n<td>数字符（digital）</td>\n<td>匹配一个数字。等价于<code>[0-9]</code></td>\n</tr>\n<tr>\n<td><code>\\D</code></td>\n<td>非数字符</td>\n<td>匹配一个非数字符。等价于<code>[^0-9]</code></td>\n</tr>\n<tr>\n<td><code>\\w</code></td>\n<td>字母、数字、下划线符（word）</td>\n<td>匹配一个单字字符（字母、数字或者下划线）。<br />等价于 <code>[A-Za-z0-9_]</code>。</td>\n</tr>\n<tr>\n<td><code>\\W</code></td>\n<td>非（字母、数字、下划线）符</td>\n<td>匹配一个非单字字符。<br />等价于 <code>[^A-Za-z0-9_]</code>。</td>\n</tr>\n<tr>\n<td><code>\\f</code></td>\n<td>换页符（特殊符号）</td>\n<td></td>\n</tr>\n<tr>\n<td><code>\\n</code></td>\n<td>换行符（特殊符号）</td>\n<td></td>\n</tr>\n<tr>\n<td><code>\\r</code></td>\n<td>回车符（特殊符号）</td>\n<td></td>\n</tr>\n<tr>\n<td><code>\\t</code></td>\n<td>制表符（特殊符号）</td>\n<td></td>\n</tr>\n<tr>\n<td><code>\\v</code></td>\n<td>垂直制表符（特殊符号）</td>\n<td></td>\n</tr>\n<tr>\n<td><code>[xyz]</code></td>\n<td>自定义字符集</td>\n<td>你可以在字符集中任意组合元字符和普通字符，形成一个自定义字符集，从而使字符串去匹配方括号中的任意字符。<br />可以使用 <code>-</code> 破折号代表范围<br />🌰<br /><code>[xyz]</code>：可以匹配<code>x</code> <code>y</code> <code>z</code> 三个字符中的任意一个<br /><code>[0-9a-z]</code>：等价于<code>[0123456789zbcdefghijklmnopqrstuvwxyz]</code> 表示匹配任意一个数字或者小写字母<br /><code>[\\dAa-z]</code> ：表示可以匹配任意一个数字（<code>\\d</code>）或者小写字母(<code>a-z</code>)以及大写字母<code>A</code></td>\n</tr>\n<tr>\n<td><code>[^xyz]</code></td>\n<td>自定义（排除）字符集</td>\n<td>在方括号内部的开头加上<code>^</code>，表示匹配任意一个<strong>不是</strong>自定义字符集内部的字符。如果在中间加上非呢？<br />🌰<br /><code>[^xyz]</code>：匹配<strong>排除</strong><code>x</code> <code>y</code> <code>z</code> 以外的任意一个字符<br /><code>[^\\dAa-z]</code> ：表示可以匹配任意一个 <strong>不是</strong> 数字（<code>\\d</code>） 且<strong>不是</strong>小写字母(<code>a-z</code>)且<strong>不是</strong>大写字母<code>A</code>的字符</td>\n</tr>\n</tbody></table>\n<h4 id=\"精确匹配\"><a href=\"#精确匹配\" class=\"headerlink\" title=\"精确匹配\"></a>精确匹配</h4><p>除<strong>元字符</strong>外，其他任意一个字符，只匹配字符本身。例如<code>/a/</code>，只能匹配字符串<code>abc</code>中的<code>a</code>。</p>\n<p> 如果想要匹配元字符<strong>本身</strong>，使用转义符号<code>\\</code>进行转义。</p>\n<p>🌰 想要匹配 <code>.</code> ，则写成<code>\\.</code></p>\n<p>🌰 想要匹配<code>+</code>（量词类型元字符），则写成<code>\\+</code></p>\n<h4 id=\"单字符匹配\"><a href=\"#单字符匹配\" class=\"headerlink\" title=\"单字符匹配\"></a>单字符匹配</h4><p>⚠️ 无论是模糊匹配还是精确匹配，在<strong>不加量词</strong>的情况下，一个<strong>字符符号</strong>（元字符或者普通符号）只能匹配单个字符。我们可以把正则里面的符号理解为占位符，一个萝卜一个坑。所以只要当前这个符号匹配到了字符，坑就被占了，下一个字符就需要有新的符号去匹配。所以我们如果要匹配多个字符，只要将多个<strong>字符符号</strong>组合在一起，形成一个子串模式，就能匹配一个满足条件的连续字符串。</p>\n<h5 id=\"匹配数字\"><a href=\"#匹配数字\" class=\"headerlink\" title=\"匹配数字\"></a>匹配数字</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;the id is: 123&#x27;</span>;<br><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/\\d/</span>;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str.<span class=\"hljs-title function_\">match</span>(reg)); <br><span class=\"hljs-comment\">// [ &#x27;1&#x27;, index: 11, input: &#x27;the id is: 123&#x27;, groups: undefined ]</span><br><span class=\"hljs-comment\">// match方法返回一个数组，其中数组的第一个元素表示匹配到的内容。</span><br><span class=\"hljs-comment\">// 可以看到每次只匹配一个字符</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"替换空白符号\"><a href=\"#替换空白符号\" class=\"headerlink\" title=\"替换空白符号\"></a>替换空白符号</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;the space is: \\n,\\f,\\r,\\t,\\v&#x27;</span>;<br><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/\\s/g</span>;\t<span class=\"hljs-comment\">// 将整个字符串中的空白符都替换为#</span><br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str.<span class=\"hljs-title function_\">replace</span>(reg, <span class=\"hljs-string\">&#x27;#&#x27;</span>));<br><span class=\"hljs-comment\">// 一次只会匹配成功一个，replace方法的说明在下面</span><br><span class=\"hljs-comment\">//the#space#is:##,#,#,#,#</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"删除所有非单字符\"><a href=\"#删除所有非单字符\" class=\"headerlink\" title=\"删除所有非单字符\"></a>删除所有非单字符</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;删除当前行中非数字(delete not number)123，(not word)非英文字母和非下划线_的符号！&#x27;</span>;<br><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/\\W/g</span>;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str.<span class=\"hljs-title function_\">replace</span>(reg, <span class=\"hljs-string\">&#x27;&#x27;</span>));\t<br><span class=\"hljs-comment\">//deletenotnumber123notword_</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"自定义字符集\"><a href=\"#自定义字符集\" class=\"headerlink\" title=\"自定义字符集\"></a>自定义字符集</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;在字符串中只留下字符集中的字符: 数字123，通配符. 普通英文字母wwwww&#x27;</span>;<br><br><span class=\"hljs-keyword\">let</span> reg1 = <span class=\"hljs-regexp\">/[^\\.数w]/g</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str.<span class=\"hljs-title function_\">replace</span>(reg1, <span class=\"hljs-string\">&#x27;&#x27;</span>));<br><span class=\"hljs-comment\">// 数.wwwww</span><br><br><span class=\"hljs-keyword\">let</span> reg2 = <span class=\"hljs-regexp\">/[\\.数w]/g</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str.<span class=\"hljs-title function_\">replace</span>(reg1, <span class=\"hljs-string\">&#x27;&#x27;</span>));<br><span class=\"hljs-comment\">//在字符串中只留下字符集中的字符: 字123，通配符 普通英文字母</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"位置类型\"><a href=\"#位置类型\" class=\"headerlink\" title=\"位置类型\"></a>位置类型</h2><p>什么是位置，什么又是位置字符呢？</p>\n<p>其实在一个连续的字符串中，相邻字符之间是存在一个位置的，我们可以把这个位置理解为空字符。如图所示（图源网络）：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/5/1731e6ec5794d5c5~tplv-t2oaga2asx-image.image\"></p>\n<p>在正则中，我们除了可以匹配具体字符以外，还可以使用元字符来表示具体要匹配哪个位置。</p>\n<p>在js中，表示位置的元字符分为4类：</p>\n<table>\n<thead>\n<tr>\n<th>位置</th>\n<th>相关元字符</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>开始</td>\n<td><code>^</code></td>\n</tr>\n<tr>\n<td>结尾</td>\n<td><code>$</code></td>\n</tr>\n<tr>\n<td>单词边界</td>\n<td><code>\\b</code> <code>\\B</code></td>\n</tr>\n<tr>\n<td>断言</td>\n<td><code>(?=)</code><br /><code>(?!)</code><br /><code>(?&lt;=)</code><br /><code>(?&lt;!)</code></td>\n</tr>\n</tbody></table>\n<h4 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h4><p>元字符<code>^</code>既可以表示位置，也可以代表非。</p>\n<ul>\n<li>表示位置时：这个元字符写在整个正则表达式的最开始。</li>\n<li>表示非时：写在方括号<code>[]</code>的最开始。</li>\n</ul>\n<p>当表示开始位置，代表当前正则表达式<strong>必须</strong>从字符串的<strong>最开始</strong>进行匹配。如果不存在这个元字符，只要字符串中任意一个子串满足正则表达式即可。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/^\\d/</span>;\t<span class=\"hljs-comment\">// 表示匹配到的字符串必须以数字开头</span><br><span class=\"hljs-keyword\">let</span> str1 = <span class=\"hljs-string\">&quot;abcdefg123&quot;</span>;<br><span class=\"hljs-keyword\">let</span> str2 = <span class=\"hljs-string\">&quot;123abcd&quot;</span>;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(reg.<span class=\"hljs-title function_\">test</span>(str1)) <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(reg.<span class=\"hljs-title function_\">test</span>(str2)) <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p>我们通常情况下都是对一个连续的单行字符串进行匹配，<code>^</code> 表示整个字符串的最开始。如果想要匹配多行文本中每行的开头，需要满足两个条件：</p>\n<ol>\n<li>当前字符串需要使用换行符<code>\\n</code>分割形成多行文本，<code>^</code>表示换行符<strong>后</strong>紧跟的位置</li>\n<li>需要将正则的多行标志<code>multiple</code>置为<code>true</code>（之后说明）</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/^\\d+/mg</span>;\t<span class=\"hljs-comment\">// m表示开启多行匹配。匹配当前多行文本中所有以数字开头的行，并获取开头的数字内容</span><br><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;123ad\\n0abc123\\nabc123&#x27;</span>;<br><span class=\"hljs-keyword\">let</span> a = str.<span class=\"hljs-title function_\">match</span>(reg);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a);<br><br><span class=\"hljs-comment\">//[ &#x27;123&#x27;, &#x27;0&#x27; ]</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"结束\"><a href=\"#结束\" class=\"headerlink\" title=\"结束\"></a>结束</h4><p>元字符 <code>$</code> 表示结束位置。匹配输入的结束。同 <code>^</code> 一样，如果多行标志被设置为 <code>true</code>，那么也匹配换行符<code>\\n</code><strong>前</strong>紧贴的位置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/\\d$/</span>;\t<span class=\"hljs-comment\">// 表示匹配到的字符串必须以数字结尾</span><br><span class=\"hljs-keyword\">let</span> str1 = <span class=\"hljs-string\">&quot;abcdefg123&quot;</span>;<br><span class=\"hljs-keyword\">let</span> str2 = <span class=\"hljs-string\">&quot;123abcd&quot;</span>;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(reg.<span class=\"hljs-title function_\">test</span>(str1)) <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(reg.<span class=\"hljs-title function_\">test</span>(str2)) <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/\\d+$/mg</span>;\t<span class=\"hljs-comment\">// m表示开启多行匹配。匹配当前多行文本中所有以数字开头的行，并获取开头的数字内容</span><br><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;123ad\\n0abc2\\nabc3&#x27;</span>;<br><span class=\"hljs-keyword\">let</span> a = str.<span class=\"hljs-title function_\">match</span>(reg);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a);<br><br><span class=\"hljs-comment\">//[ &#x27;2&#x27;, &#x27;3&#x27; ]</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"单词边界\"><a href=\"#单词边界\" class=\"headerlink\" title=\"单词边界\"></a>单词边界</h4><p>其实在这里，<code>\\b</code> 表示单词边界的位置，<code>\\B</code>表示<strong>非单词边界</strong>的位置。</p>\n<p>那什么是单词呢？我们回到之前的字符类型的元字符表可以看到，<code>\\w</code>其实就是word，连续的word形成了words，就是代表了这里的单词。我们已经知道<code>\\w</code>等价于<code>[A-Za-z0-9_]</code>，所以这里的单词就是指带了这些字符。</p>\n<p>那边界的定义又是什么？</p>\n<p>我们已知，每两个相邻字符之间，都存在一个位置，如果相邻两个字符都属于<code>\\w</code>，那这两个相邻字符之间的位置就叫<strong>非单词边界<code>\\B</code><strong>；如果两个相邻字符</strong>只有一个</strong>字符属于<code>\\w</code>，或者<strong>两个都不属于</strong><code>\\w</code>，那它们之间的位置就叫做**单词边界<code>\\b</code>**。 （<code>b</code>可以理解为<code>break</code>）</p>\n<p>需要注意的一点，字符串的开始和结束，都算作单词边界。可以理解为在字符串的开始和结束，存在一个空字符<code>&quot;&quot;</code> ，那么无论相邻的字符是否属于<code>\\w</code>，都存在一个空字符<code>&quot;&quot;</code>不属于<code>\\w</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> breakReg = <span class=\"hljs-regexp\">/\\b/g</span>,<br>    notBreakReg = <span class=\"hljs-regexp\">/\\B/g</span>;<br><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&quot;word_break.mp3&quot;</span>;<br><span class=\"hljs-keyword\">let</span> bStr = str.<span class=\"hljs-title function_\">replace</span>(breakReg, <span class=\"hljs-string\">&quot;|&quot;</span>);<br><span class=\"hljs-keyword\">let</span> <span class=\"hljs-title class_\">Bstr</span> = str.<span class=\"hljs-title function_\">replace</span>(notBreakReg, <span class=\"hljs-string\">&quot;|&quot;</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;bStr is: &quot;</span>, bStr);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Bstr is: &quot;</span>, <span class=\"hljs-title class_\">Bstr</span>);<br><br><br><span class=\"hljs-comment\">// bStr is:  |word_break|.|mp3|</span><br><span class=\"hljs-comment\">// Bstr is:  w|o|r|d|_|b|r|e|a|k.m|p|3</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"断言\"><a href=\"#断言\" class=\"headerlink\" title=\"断言\"></a>断言</h4><blockquote>\n<p>零宽断言正如它的名字一样，是一种零宽度的匹配，它匹配到的内容不会保存到匹配结果中去，最终匹配结果只是一个位置而已。<br>作用是给指定位置添加一个限定条件，用来规定此位置之前或者之后的字符必须满足限定条件才能使正则中的字表达式匹配成功。</p>\n<p>​                                                          ——源自博客《正则表达式零宽断言详解》</p>\n</blockquote>\n<p>听起来断言很复杂，其实道理很简单。所谓断言，其实就是我们的正则表达式在<strong>匹配位置</strong>的时候，必须要满足一定的条件才行。这里的条件，就是一个子表达式，其中断言又分为：</p>\n<ul>\n<li>先行：<ul>\n<li>正向：<code>(?=子表达式)</code></li>\n<li>负向：<code>(?!子表达式)</code></li>\n</ul>\n</li>\n<li>后行：<ul>\n<li>正向：<code>(?&lt;=子表达式)</code></li>\n<li>负向：<code>(?&lt;!子表达式)</code></li>\n</ul>\n</li>\n</ul>\n<p>在这里，先行和后行为相反组，表示匹配的位置在前还是在后；正向和负向为相反组，表示是否满足条件。组合起来的意思就是：</p>\n<ul>\n<li>正向先行<code>(?=)</code>：匹配<strong>满足</strong>子表达式的字符串<strong>前面</strong>的位置</li>\n<li>正向后行<code>(?&lt;=)</code>：匹配<strong>满足</strong>子表达式的字符串<strong>后面</strong>的位置</li>\n<li>负向先行<code>(?!)</code>：匹配<strong>不满足</strong>子表达式的字符串<strong>前面</strong>的位置</li>\n<li>负向后行<code>(?&lt;!)</code>：匹配<strong>不满足</strong>子表达式的字符串<strong>后面</strong>的位置</li>\n</ul>\n<p>简单记忆：</p>\n<ul>\n<li>正向：满足</li>\n<li>负向：不满足</li>\n<li>先行：前面</li>\n<li>后行：后面</li>\n</ul>\n<h5 id=\"正向（先-后）行\"><a href=\"#正向（先-后）行\" class=\"headerlink\" title=\"正向（先/后）行\"></a>正向（先/后）行</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;在js前面插入===,后面插入---: 前端基础三件套html,css,js; node, npm, react或者vue是新的三件套&#x27;</span>;<br><br><span class=\"hljs-keyword\">let</span> reg1 = <span class=\"hljs-regexp\">/(?=js)/g</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str.<span class=\"hljs-title function_\">replace</span>(reg1, <span class=\"hljs-string\">&#x27;===&#x27;</span>));<br><span class=\"hljs-comment\">// 在===js前面插入===,后面插入---: 前端基础三件套html,css,===js; node, npm, react或者vue是新的三件套</span><br><br><br><span class=\"hljs-keyword\">let</span> reg2 = <span class=\"hljs-regexp\">/(?&lt;=js)/g</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str.<span class=\"hljs-title function_\">replace</span>(reg2, <span class=\"hljs-string\">&#x27;---&#x27;</span>));<br><span class=\"hljs-comment\">// 在js---前面插入===,后面插入---: 前端基础三件套html,css,js---; node, npm, react或者vue是新的三件套</span><br></code></pre></td></tr></table></figure>\n\n\n<h5 id=\"负向（先-后）行\"><a href=\"#负向（先-后）行\" class=\"headerlink\" title=\"负向（先/后）行\"></a>负向（先/后）行</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;the number is 0000&#x27;</span>; <br><span class=\"hljs-comment\">// 在所有非字母和非空白符的字符前插入 ===，后面插入---</span><br><span class=\"hljs-comment\">// 实际上在这个字符串中会有三个字符会匹配成功：数字字符、字符串的开始空字符、结束空字符。</span><br><br><span class=\"hljs-keyword\">let</span> reg1 = <span class=\"hljs-regexp\">/(?![a-zA-Z\\s])/g</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str.<span class=\"hljs-title function_\">replace</span>(reg1, <span class=\"hljs-string\">&#x27;===&#x27;</span>));<br><span class=\"hljs-comment\">// the number is ===0===0===0===0===</span><br><span class=\"hljs-comment\">// 最后一个===实际上是匹配到了结束空字符&#x27;&#x27;，在结束空字符前插入了===</span><br><br><span class=\"hljs-keyword\">let</span> reg2 = <span class=\"hljs-regexp\">/(?&lt;![a-zA-Z\\s])/g</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str.<span class=\"hljs-title function_\">replace</span>(reg2, <span class=\"hljs-string\">&#x27;---&#x27;</span>));<br><span class=\"hljs-comment\">// ---the number is 0---0---0---0---</span><br><span class=\"hljs-comment\">// 第一个---实际上是匹配到了开始空字符&#x27;&#x27;，在开始空字符后插入了---</span><br></code></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"量词类型\"><a href=\"#量词类型\" class=\"headerlink\" title=\"量词类型\"></a>量词类型</h2><p>根据前面的了解，我们知道 一个符号只能匹配一个字符，如果要匹配多个字符，就需要组合多个符号（包括元字符和普通字符）来进行匹配。但是如果要匹配一个连续重复的字符串<code>aaaaaaaaa</code>，按照前面的逻辑，我们的正则表达式要写出 <code>/aaaaaaaaa/</code> 才行。有没有更简便的方法呢？</p>\n<p>答案是有的。</p>\n<p>在正则中，存在这种量词类型的元字符，来简化表达式本身。例如上面的正则表达式我们可以写成<code>/a&#123;9&#125;/</code>，表示当前满足条件，能匹配成功的子串包含9个连续的a。</p>\n<p>量词类型的元字符用来表示重复次数，具体重复的对象，是前面紧跟的子模式。</p>\n<p>其中，量词元字符包括：</p>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>*</code></td>\n<td>重复0到n次</td>\n</tr>\n<tr>\n<td><code>+</code></td>\n<td>重复1到n次</td>\n</tr>\n<tr>\n<td><code>?</code></td>\n<td>出现0次或者1次</td>\n</tr>\n<tr>\n<td><code>&#123;n&#125;</code></td>\n<td>重复n次</td>\n</tr>\n<tr>\n<td><code>&#123;n,&#125;</code></td>\n<td>至少重复n次</td>\n</tr>\n<tr>\n<td><code>&#123;n, m&#125;</code></td>\n<td>重复n到m次</td>\n</tr>\n</tbody></table>\n<p>例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;the number is 0000123122, phone number is 057-9981013&#x27;</span>;<br><br><span class=\"hljs-keyword\">let</span> reg1 = <span class=\"hljs-regexp\">/\\d+/g</span>;<br><span class=\"hljs-keyword\">let</span> reg2 = <span class=\"hljs-regexp\">/[num]&#123;3&#125;/g</span>;<br><span class=\"hljs-keyword\">let</span> reg3 = <span class=\"hljs-regexp\">/0&#123;2,4&#125;/g</span>;<br><span class=\"hljs-keyword\">let</span> reg4 = <span class=\"hljs-regexp\">/,?/</span>;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str.<span class=\"hljs-title function_\">match</span>(reg1))<br><span class=\"hljs-comment\">// [ &#x27;0000123122&#x27;, &#x27;057&#x27;, &#x27;9981013&#x27; ]</span><br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str.<span class=\"hljs-title function_\">match</span>(reg2))<br><span class=\"hljs-comment\">// [ &#x27;num&#x27;, &#x27;num&#x27; ]</span><br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str.<span class=\"hljs-title function_\">match</span>(reg3))<br><span class=\"hljs-comment\">// [ &#x27;0000&#x27; ]</span><br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(reg4.<span class=\"hljs-title function_\">test</span>(str))<br><span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"分组类型\"><a href=\"#分组类型\" class=\"headerlink\" title=\"分组类型\"></a>分组类型</h2><p>我们已知如何匹配一段由一个字符重复n次构成的字符串，例如 <code>aaaaaa</code> 。假如现在我们的字符串是<code>123xyzxyzxyz1axyzxyz</code>，很明显，这串字符中也存在重复的子串，但是并不满足单字符重复的特点，我们无法使用已经学到的东西来写出正则表达式。这个时候，就是分组类型的元字符上场的时候了。</p>\n<p>分组由圆括号 <code>()</code> 来表示。括号内部是子表达式，表示一个子串的匹配模式。说白了，分组就是把一些特殊的单字符组合看作一个单元，我们在匹配时，遇到这样的单元就当做一个整体来处理。具体是哪些特殊字符的组合，就可以任意定义，然后写成子模式。例如上面的字符串，我们把<code>xyz</code>看作一个单元，想要匹配出<code>xyz</code>，就可以这样写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&quot;123xyzxyzxyz1axyzxyz&quot;</span>;<br><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/(xyz)/g</span>;<br><span class=\"hljs-keyword\">let</span> match = str.<span class=\"hljs-title function_\">match</span>(reg);<br><br><span class=\"hljs-comment\">// [ &#x27;xyz&#x27;, &#x27;xyz&#x27;, &#x27;xyz&#x27;, &#x27;xyz&#x27;, &#x27;xyz&#x27; ]</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p>如果把连续的两个甚至多个<code>xyz</code>看作一个单元来匹配，只需要需要在分组后添加量词即可。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&quot;123xyzxyzxyz1axyzxyz&quot;</span>;<br><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/(xyz)+/g</span>;<br><span class=\"hljs-keyword\">let</span> match = str.<span class=\"hljs-title function_\">match</span>(reg);<br><br><span class=\"hljs-comment\">// [ &#x27;xyzxyzxyz&#x27;, &#x27;xyzxyz&#x27; ]</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p>在分组类型的元字符中，有三种类型：</p>\n<table>\n<thead>\n<tr>\n<th><strong>捕获分组</strong></th>\n<th><strong><code>（子表达式）</code></strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>命名捕获分组</strong></td>\n<td><strong>(?<name>子表达式)</strong></td>\n</tr>\n<tr>\n<td><strong>非捕获分组</strong></td>\n<td><strong><code>(?:子表达式)</code></strong></td>\n</tr>\n</tbody></table>\n<h5 id=\"捕获与非捕获\"><a href=\"#捕获与非捕获\" class=\"headerlink\" title=\"捕获与非捕获\"></a>捕获与非捕获</h5><p>其区别就在于，当我们使用捕获分组的时候，每个子表达式匹配到的内容都会被分别记录下来，后面我们可以通过相应的api或者是引用类型的元字符获取到不同分组的匹配项；而非捕获分组就是不记录这个匹配项。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/(\\d+)(?:[a-z]+)/</span>;\t<br><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&quot;123abcd&quot;</span>;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str.<span class=\"hljs-title function_\">match</span>(reg))<br><span class=\"hljs-comment\">// [ &#x27;123abcd&#x27;, &#x27;123&#x27;, index: 0, input: &#x27;123abcd&#x27;, groups: undefined ]</span><br><span class=\"hljs-comment\">// 在这里，123abcd是整个正则匹配到的内容，而123则是我们捕获分组匹配到的内容</span><br><span class=\"hljs-comment\">// 可以看到，此时非捕获分组匹配到的内容并没有被保存下来，我们无法单独获取</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"匿名捕获与命名捕获\"><a href=\"#匿名捕获与命名捕获\" class=\"headerlink\" title=\"匿名捕获与命名捕获\"></a>匿名捕获与命名捕获</h5><p>其中捕获分组又分为命名和匿名分组，匿名分组则使用索引值来获取，而命名分组除了可以使用索引值访问以外，还可以通过指定的属性访问获取。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/(\\d+)(?&lt;char&gt;[a-z]+)/</span>;<br><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&quot;123abcd&quot;</span>;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str.<span class=\"hljs-title function_\">match</span>(reg))<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/5/1731e6ccb87320ec~tplv-t2oaga2asx-image.image\"></p>\n<p>从结果中我们可以看到，使用命名捕获分组匹配到的分组，不但可以通过索引值来获取，还可以通过<code>groups.char</code>获取。</p>\n<h2 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h2><p>引用，其实就是对捕获分组匹配到的内容的引用。</p>\n<p>在两个地方可以使用引用：</p>\n<ul>\n<li>在表达式本式中</li>\n<li>在相关的函数中</li>\n</ul>\n<h5 id=\"表达式中的引用\"><a href=\"#表达式中的引用\" class=\"headerlink\" title=\"表达式中的引用\"></a>表达式中的引用</h5><p>在表达式中，有两种方法来获取引用：</p>\n<table>\n<thead>\n<tr>\n<th>元字符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>\\n</code></td>\n<td>匿名捕获分组的引用。它返回第n个子捕获匹配到的具体的内容(捕获的数目以左括号计数，即不论是否嵌套分组，命名捕获还是匿名捕获，都是按照左括号来计算，第一个左括号捕获的分组就是<code>\\1</code>, 第二个分组就是<code>\\2</code> …)。</td>\n</tr>\n<tr>\n<td><code>\\k&lt;name&gt;</code></td>\n<td>返回具体某个命名捕获分组的内容。</td>\n</tr>\n</tbody></table>\n<p>例如：判断一个字符串数组所有元素是否完全相等</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-string\">&#x27;abc&#x27;</span>, <span class=\"hljs-string\">&#x27;abc&#x27;</span>, <span class=\"hljs-string\">&#x27;abc&#x27;</span>];<br><span class=\"hljs-keyword\">let</span> str = arr.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;,&#x27;</span>); <span class=\"hljs-comment\">// abc,abc,abc</span><br><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/(\\w+),\\1/</span>; <span class=\"hljs-comment\">// 在这里，\\1 就表示了第一个分组获取到的具体内容。</span><br><br><span class=\"hljs-keyword\">let</span> match = reg.<span class=\"hljs-title function_\">test</span>(str);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(match); <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p>当然我们也可以使用命名捕获：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-string\">&#x27;item&#x27;</span>, <span class=\"hljs-string\">&#x27;item&#x27;</span>, <span class=\"hljs-string\">&#x27;item&#x27;</span>];<br><span class=\"hljs-keyword\">let</span> str = arr.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;,&#x27;</span>)+<span class=\"hljs-string\">&#x27;,&#x27;</span>;\t<span class=\"hljs-comment\">// item,item,item,</span><br><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/(?&lt;element&gt;\\w+)(,)\\k&lt;element&gt;\\2/</span>; <span class=\"hljs-comment\">// 等价于/(?&lt;element&gt;\\w+)(,)\\1\\2/</span><br><br><span class=\"hljs-keyword\">let</span> match = reg.<span class=\"hljs-title function_\">test</span>(str);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(match); <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"相关函数中的引用\"><a href=\"#相关函数中的引用\" class=\"headerlink\" title=\"相关函数中的引用\"></a>相关函数中的引用</h5><p>在函数中有两种，一种是特殊字符指代，一种是函数参数。</p>\n<p>例如在<code>string.prototype.replace</code>中，可以使用特殊字符 <code>$n</code> 来指代分组，同样的，数字 <code>n </code>代表分组索引。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 交换位置</span><br><span class=\"hljs-keyword\">let</span> names = <span class=\"hljs-string\">&#x27;john,marry,jerry&#x27;</span>;<br><span class=\"hljs-keyword\">let</span> new_names = names.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/(\\w+),(\\w+),(\\w+)/</span>, <span class=\"hljs-string\">&#x27;$2,$3,$1&#x27;</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(new_names); <br><br><span class=\"hljs-comment\">// marry,jerry,john</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p>也可以在函数参数中使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 交换位置</span><br><span class=\"hljs-keyword\">let</span> names = <span class=\"hljs-string\">&#x27;john,marry,jerry&#x27;</span>;<br><span class=\"hljs-keyword\">let</span> new_names = names.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/(\\w+),(\\w+),(\\w+)/</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">content, n1, n2, n3</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;n3&#125;</span> <span class=\"hljs-subst\">$&#123;n2&#125;</span> <span class=\"hljs-subst\">$&#123;n1&#125;</span>`</span>;<br>&#125;);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(new_names); <br><span class=\"hljs-comment\">// jerry marry john</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p>具体的 <code>replace</code> 方法介绍在下面。</p>\n<h2 id=\"分支类型\"><a href=\"#分支类型\" class=\"headerlink\" title=\"分支类型\"></a>分支类型</h2><p>当我们在匹配一个字符串时，如果存在其中某部分子串，既可以是A，又可以是B，就可以使用分支元字符。</p>\n<table>\n<thead>\n<tr>\n<th>元字符</th>\n<th>定义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>`</td>\n<td>`</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> strArr = [<span class=\"hljs-string\">&#x27;year&#x27;</span>,<span class=\"hljs-string\">&#x27;mouth&#x27;</span>,<span class=\"hljs-string\">&#x27;day&#x27;</span>];<br><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/mouth|day/</span>;\t<span class=\"hljs-comment\">//  匹配mouth或者day</span><br><br>strArr.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">str</span> =&gt;</span> &#123;<br>     <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str, <span class=\"hljs-string\">&quot;: &quot;</span>, reg.<span class=\"hljs-title function_\">test</span>(str));<br>&#125;)<br><br><br><span class=\"hljs-comment\">// year :  false</span><br><span class=\"hljs-comment\">// mouth :  true</span><br><span class=\"hljs-comment\">// day :  true</span><br></code></pre></td></tr></table></figure>\n\n\n\n\n\n<p>如果需要匹配这样一个字符串，既可以是A，又可以是B，同时又要满足C的时候，还可以结合分组来使用</p>\n<p>例如匹配 <code>&quot;window98 / window2000 / window10&quot;</code> 这样一个字符串：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> wins = [<span class=\"hljs-string\">&#x27;window98&#x27;</span>,<span class=\"hljs-string\">&#x27;window2000&#x27;</span>, <span class=\"hljs-string\">&#x27;window10&#x27;</span>, <span class=\"hljs-string\">&#x27;window99&#x27;</span>];<br><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/window(98|2000|10)/</span>;<br><br>wins.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">str</span> =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str, <span class=\"hljs-string\">&quot;: &quot;</span>, reg.<span class=\"hljs-title function_\">test</span>(str));<br>&#125;)<br><br><span class=\"hljs-comment\">// window98 :  true</span><br><span class=\"hljs-comment\">// window2000 :  true</span><br><span class=\"hljs-comment\">// window10 :  true</span><br><span class=\"hljs-comment\">// window99 :  false</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"JS中的正则\"><a href=\"#JS中的正则\" class=\"headerlink\" title=\"JS中的正则\"></a>JS中的正则</h2><p>JS中与正则相关的主要有两种对象，<code>String</code> 对象和 <code>RegExp</code> 对象。</p>\n<h3 id=\"RegExp对象\"><a href=\"#RegExp对象\" class=\"headerlink\" title=\"RegExp对象\"></a>RegExp对象</h3><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/5/1731e6dd6df72f7b~tplv-t2oaga2asx-image.image\"></p>\n<h4 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h4><h5 id=\"字面量\"><a href=\"#字面量\" class=\"headerlink\" title=\"字面量\"></a>字面量</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/\\d/</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RegExp</span>(<span class=\"hljs-string\">&#x27;ab+c&#x27;</span>, <span class=\"hljs-string\">&#x27;i&#x27;</span>); <span class=\"hljs-comment\">// 使用字符串创建</span><br><span class=\"hljs-keyword\">let</span> reg1 =<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RegExp</span>(<span class=\"hljs-regexp\">/ab+c/</span>, <span class=\"hljs-string\">&#x27;i&#x27;</span>); <span class=\"hljs-comment\">// 使用字面量创建</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"工厂函数\"><a href=\"#工厂函数\" class=\"headerlink\" title=\"工厂函数\"></a>工厂函数</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-title class_\">RegExp</span>(<span class=\"hljs-string\">&#x27;ab+c&#x27;</span>, <span class=\"hljs-string\">&#x27;i&#x27;</span>);\t<span class=\"hljs-comment\">// 使用字符串创建</span><br><span class=\"hljs-keyword\">let</span> reg1 =<span class=\"hljs-title class_\">RegExp</span>(<span class=\"hljs-regexp\">/ab+c/</span>, <span class=\"hljs-string\">&#x27;i&#x27;</span>);\t<span class=\"hljs-comment\">// 使用字面量创建</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p>注意：在使用RegExp方法创建正则表达式时，如果想要 <code>string</code> 类型的参数中使用元字符时，需要转义，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 想要构建出 /\\d+/ 这样的表达式</span><br><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-title class_\">RegExp</span>(<span class=\"hljs-string\">&#x27;\\d+&#x27;</span>, <span class=\"hljs-string\">&#x27;i&#x27;</span>);\t<br><span class=\"hljs-comment\">// 此时创建出来的结果是 /d+/ 而不是目标表达式</span><br><br><span class=\"hljs-comment\">// 正确的写法应该是：</span><br><span class=\"hljs-comment\">// RegExp(&#x27;\\\\d+&#x27;, &#x27;i&#x27;);\t</span><br></code></pre></td></tr></table></figure>\n\n\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/5/1731e6e2936db248~tplv-t2oaga2asx-image.image\"></p>\n<h4 id=\"lastIndex\"><a href=\"#lastIndex\" class=\"headerlink\" title=\"lastIndex\"></a>lastIndex</h4><p>保存了当前正则实例上次匹配的位置。表示下次匹配从哪里开始。这个属性只有正则表达式使用了表示全局检索的 “<code>g</code>“ 标志时，该属性才会起作用。所以当我们在使用全局匹配时，需要注意当前这个值是否被修改。<strong>MDN</strong>中是这样定义的：</p>\n<blockquote>\n<ul>\n<li>如果 <code>lastIndex</code> 大于字符串的长度，则 <code>regexp.test</code> 和 <code>regexp.exec</code> 将会匹配失败，然后 <code>lastIndex</code> 被设置为 0。</li>\n<li>如果 <code>lastIndex</code> 等于字符串的长度，且该正则表达式匹配空字符串，则该正则表达式匹配从 <code>lastIndex</code> 开始的字符串。（then the regular expression matches input starting at <code>lastIndex</code>.）</li>\n<li>如果 <code>lastIndex</code> 等于字符串的长度，且该正则表达式不匹配空字符串 ，则该正则表达式不匹配字符串，<code>lastIndex</code> 被设置为 0.。</li>\n<li>否则，<code>lastIndex</code> 被设置为紧随最近一次成功匹配的下一个位置。</li>\n</ul>\n</blockquote>\n<p>例如</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/\\d+/g</span>;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">matchNumber</span>(<span class=\"hljs-params\">str</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> reg.<span class=\"hljs-title function_\">test</span>(str);<br>&#125;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">matchNumber</span>(<span class=\"hljs-string\">&#x27;123&#x27;</span>)); <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">matchNumber</span>(<span class=\"hljs-string\">&#x27;456&#x27;</span>)); <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n\n<p>上面的方法，我们期望返回两个<code>true</code>，但实际第一个确实返回<code>true</code>，第二个却返回了 <code>false</code>，这是因为我们的正则是一个全局变量，所以每次调用之后更改了<code>lastIndex</code>， 而每次的匹配都从<code>lastIndex</code>开始，所以第二次匹配，传入<code>456</code>实际会从第四个字符开始匹配。此时第四个字符为空，所以返回 <code>false</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/\\d+/g</span>;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">matchNumber</span>(<span class=\"hljs-params\">str</span>)&#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;reg.lastIndex is: &quot;</span>, reg.<span class=\"hljs-property\">lastIndex</span>);<br>    <span class=\"hljs-keyword\">return</span> reg.<span class=\"hljs-title function_\">test</span>(str);<br>&#125;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">matchNumber</span>(<span class=\"hljs-string\">&#x27;123&#x27;</span>)); <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">matchNumber</span>(<span class=\"hljs-string\">&#x27;456&#x27;</span>)); <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">matchNumber</span>(<span class=\"hljs-string\">&#x27;4&#x27;</span>));<br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">reg.lastIndex is:  0</span><br><span class=\"hljs-comment\">true</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">reg.lastIndex is:  3</span><br><span class=\"hljs-comment\">false</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">reg.lastIndex is:  0\t</span><br><span class=\"hljs-comment\">true</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h4><h5 id=\"test\"><a href=\"#test\" class=\"headerlink\" title=\"test\"></a>test</h5><p>测试当前字符串是否满足某个模式</p>\n<p>参数：<code>str</code> 要匹配正则表达式的字符串。</p>\n<p>返回：<code>boolean</code>值，表示是否匹配成功</p>\n<p>例如判断当前字符串是否由11位数字组成：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/^\\d&#123;11&#125;$/</span>;<br><span class=\"hljs-keyword\">let</span> phone_number = <span class=\"hljs-string\">&#x27;13577898320&#x27;</span>;<br><br>reg.<span class=\"hljs-title function_\">test</span>(phone_number); <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"exec\"><a href=\"#exec\" class=\"headerlink\" title=\"exec\"></a>exec</h5><p>方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null\"><code>null</code></a>。</p>\n<p>参数：<code>str</code> 要匹配正则表达式的字符串。</p>\n<p>返回：一个数组：</p>\n<table>\n<thead>\n<tr>\n<th>对象</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>[0]</code></td>\n<td>匹配的全部字符串</td>\n</tr>\n<tr>\n<td><code>[1], ...[*n* ]</code></td>\n<td>括号中的分组捕获</td>\n</tr>\n<tr>\n<td><code>index</code></td>\n<td>匹配到的字符位于原始字符串的索引值</td>\n</tr>\n<tr>\n<td><code>input</code></td>\n<td>原始字符串</td>\n</tr>\n<tr>\n<td><code>groups</code></td>\n<td>命名捕获对象</td>\n</tr>\n</tbody></table>\n<p>⚠️：在js与正则相关的函数中，调用这个函数，会涉及到正则对象的状态。MDN中是这样解释的：</p>\n<blockquote>\n<p>在设置了 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/global\"><code>global</code></a> 或 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky\"><code>sticky</code></a> 标志位的情况下（如 <code>/foo/g</code> or <code>/foo/y</code>），JavaScript <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp\"><code>RegExp</code></a> 对象是<strong>有状态</strong>的。他们会将上次成功匹配后的位置记录在 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex\"><code>lastIndex</code></a> 属性中。使用此特性，<code>exec()</code> 可用来对单个字符串中的多次匹配结果进行逐条的遍历（包括捕获到的匹配），而相比之下， <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match\"><code>String.prototype.match()</code></a> 只会返回匹配到的结果。</p>\n</blockquote>\n<p>提取出字符串中所有的数字</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;各科成绩如下:数学: 121;语文: 120;英语: 138&#x27;</span><br><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/\\d+/g</span>;<br><span class=\"hljs-keyword\">let</span> result = <span class=\"hljs-literal\">null</span>;<br><span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">while</span> ((result = reg.<span class=\"hljs-title function_\">exec</span>(str)) !== <span class=\"hljs-literal\">null</span>) &#123;<br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`-------------第<span class=\"hljs-subst\">$&#123;++i&#125;</span>次循环开始------------------`</span>)<br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;result is: &quot;</span>, result); <br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;reg.lastIndex is: &quot;</span>, reg.<span class=\"hljs-property\">lastIndex</span>); <br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`-------------第<span class=\"hljs-subst\">$&#123;++i&#125;</span>次循环结束------------------`</span>)<br>&#125;<br><br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">-------------第1次循环开始------------------</span><br><span class=\"hljs-comment\">result is:  [ &#x27;121&#x27;,</span><br><span class=\"hljs-comment\">  index: 11,</span><br><span class=\"hljs-comment\">  input: &#x27;各科成绩如下:数学: 121;语文: 120;英语: 138&#x27;,</span><br><span class=\"hljs-comment\">  groups: undefined ]</span><br><span class=\"hljs-comment\">  </span><br><span class=\"hljs-comment\">reg.lastIndex is:  14</span><br><span class=\"hljs-comment\">-------------第1次循环结束------------------</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">-------------第2次循环开始------------------</span><br><span class=\"hljs-comment\">result is:  [ &#x27;120&#x27;,</span><br><span class=\"hljs-comment\">  index: 19,</span><br><span class=\"hljs-comment\">  input: &#x27;各科成绩如下:数学: 121;语文: 120;英语: 138&#x27;,</span><br><span class=\"hljs-comment\">  groups: undefined ]</span><br><span class=\"hljs-comment\">reg.lastIndex is:  22</span><br><span class=\"hljs-comment\">-------------第2次循环结束------------------</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">-------------第3次循环开始------------------</span><br><span class=\"hljs-comment\">result is:  [ &#x27;138&#x27;,</span><br><span class=\"hljs-comment\">  index: 27,</span><br><span class=\"hljs-comment\">  input: &#x27;各科成绩如下:数学: 121;语文: 120;英语: 138&#x27;,</span><br><span class=\"hljs-comment\">  groups: undefined ]</span><br><span class=\"hljs-comment\">  </span><br><span class=\"hljs-comment\">reg.lastIndex is:  30</span><br><span class=\"hljs-comment\">-------------第3次循环结束------------------</span><br><span class=\"hljs-comment\">*/</span><br><br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"String对象\"><a href=\"#String对象\" class=\"headerlink\" title=\"String对象\"></a>String对象</h3><p>String对象中涉及到正则的主要有4个方法：</p>\n<ul>\n<li><code>search</code></li>\n<li><code>match</code></li>\n<li><code>replace</code></li>\n<li><code>split</code></li>\n</ul>\n<p>而其中，<code>match</code>方法中，正则表达式的 <code>global</code> 的不同值会影响返回结果。</p>\n<h4 id=\"search\"><a href=\"#search\" class=\"headerlink\" title=\"search\"></a>search</h4><p><code>search</code>方法很简单，主要用来查找子串的位置。</p>\n<ul>\n<li>参数：一个正则表达式，必填</li>\n<li>返回：找到的第一个子串在字符串中的索引值，如果没有找到就返回 <code>-1</code> </li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;find subString index: subString&#x27;</span>;<br><span class=\"hljs-keyword\">let</span> reg1 = <span class=\"hljs-regexp\">/subString/</span>;<br><span class=\"hljs-keyword\">let</span> reg2 = <span class=\"hljs-regexp\">/substring/</span>;<br><span class=\"hljs-keyword\">let</span> reg3 = <span class=\"hljs-regexp\">/subString/g</span>;<br><br>str.<span class=\"hljs-title function_\">search</span>(reg1);\t\t<span class=\"hljs-comment\">// 5</span><br>str.<span class=\"hljs-title function_\">search</span>(reg1);\t\t<span class=\"hljs-comment\">// -1</span><br>str.<span class=\"hljs-title function_\">search</span>(reg1);\t\t<span class=\"hljs-comment\">// 5 此时有无global都不影响结果</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match\"></a>match</h4><p><code>match </code>方法中，主要用来提取字符串中满足条件的子串。</p>\n<ul>\n<li>参数：正则表达式，，必填。这个正则表达式的 <code>global</code> 标志的值会影响返回结果：<ul>\n<li><code>global == true</code> ：返回一个数组，包含了整个字符串中所有满足条件的子串。 </li>\n<li><code>global == false</code>： 返回<ul>\n<li>数组<code>arr</code> ：<ul>\n<li><code>arr[0]</code> 是当前正则匹配到的第一个子串的值</li>\n<li><code>arr[1] - arr[n]</code> ：分别是当前分组中捕获到的内容，有多少个分组就有多少项。且按照分组的顺序存储</li>\n</ul>\n</li>\n<li><code>index</code> ：当前匹配到的子串在整个字符串中的索引值</li>\n<li><code>input</code> ：源字符串</li>\n<li><code>groups</code>：对象，包含了所有命名捕获组匹配到的内容 ，如果没有定义命名捕获组则为<code>undefined</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;find subString index: subString&#x27;</span>;<br><span class=\"hljs-keyword\">let</span> reg1 = <span class=\"hljs-regexp\">/subString/</span>;<br><span class=\"hljs-keyword\">let</span> reg2 = <span class=\"hljs-regexp\">/substring/</span>;<br><span class=\"hljs-keyword\">let</span> reg3 = <span class=\"hljs-regexp\">/subString/g</span>;<br><br>str.<span class=\"hljs-title function_\">match</span>(reg1);<br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">[</span><br><span class=\"hljs-comment\">  &#x27;subString&#x27;,</span><br><span class=\"hljs-comment\">  index: 5,</span><br><span class=\"hljs-comment\">  input: &#x27;find subString index: subString&#x27;,</span><br><span class=\"hljs-comment\">  groups: undefined</span><br><span class=\"hljs-comment\">]</span><br><span class=\"hljs-comment\">**/</span><br>str.<span class=\"hljs-title function_\">match</span>(reg2);\t<span class=\"hljs-comment\">// null</span><br>str.<span class=\"hljs-title function_\">match</span>(reg3);\t<span class=\"hljs-comment\">// [ &#x27;subString&#x27;, &#x27;subString&#x27; ]</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"replace\"><a href=\"#replace\" class=\"headerlink\" title=\"replace\"></a>replace</h4><p><code>replace</code>方法，就是用指定的值来替换源字符串中一些特定的子串。</p>\n<ul>\n<li><p>参数：</p>\n<ul>\n<li><p><code>pattern</code>： 模式，指定被替换的子串类型。可以是一个 <code>String</code>，也可以是一个 <code>RegExp</code> </p>\n<ul>\n<li> <code>String</code> </li>\n<li> <code>RegExp</code>：当为<code>RegExp</code>对象时，如果 <code>global</code>标志为<code>false</code>，则只会替换匹配到的第一个子串。</li>\n</ul>\n</li>\n<li><p><code>replacement</code>： 替换值，用于替换指定的子串。可以是一个 <code>String</code>，也可以是一个<code>Function</code></p>\n<ul>\n<li><p><code>String</code>：如果pattern是一个<code>RegExp</code>，还可以使用一些特殊字符来插入命令：</p>\n<ul>\n<li><table>\n<thead>\n<tr>\n<th><strong><code>?</code></strong></th>\n<th><strong>插入一个 “$”</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><code>$&amp;</code></strong></td>\n<td><strong>插入匹配的子串</strong></td>\n</tr>\n<tr>\n<td><strong>$`</strong></td>\n<td><strong>插入当前匹配的子串左边的内容</strong></td>\n</tr>\n<tr>\n<td><strong><code>$&#39;</code></strong></td>\n<td><strong>插入当前匹配的子串右边的内容</strong></td>\n</tr>\n<tr>\n<td><strong><code>$n</code></strong></td>\n<td><strong>插入指定的捕获组内容</strong></td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n</li>\n<li><p><code>Function</code>：替换函数，可以指定返回的新字符串。只有第一个参数为正则时才生效。</p>\n<ul>\n<li><blockquote>\n<p>你可以指定一个函数作为第二个参数。在这种情况下，当匹配执行后，该函数就会执行。 函数的返回值作为替换字符串。 (注意：上面提到的特殊替换参数在这里不能被使用。) 另外要注意的是，如果第一个参数是正则表达式，<strong>并且其为全局匹配模式</strong>，那么这个方法将被多次调用，每次匹配都会被调用。（源自MDN）</p>\n</blockquote>\n</li>\n<li><p>参数：</p>\n<ul>\n<li><code>match</code>：每次匹配到的子串。</li>\n<li><code>p1,p2, ...</code>：假如<code>replace</code> 的 <code>pattern</code> 参数是一个 <code>RegExp</code>，则这里就是分别指代了各个分组匹配到的内容。</li>\n<li><code>offset</code>：匹配到的子字符串在原字符串中的偏移量。</li>\n<li><code>string</code>：源字符串。</li>\n<li><code>NamedCaptureGroup</code>： 命名捕获组匹配的对象</li>\n</ul>\n</li>\n<li><p>返回：替换后的新字符串。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>返回：替换后的新字符串。</p>\n</li>\n</ul>\n<p>有四种组合方式：</p>\n<h5 id=\"组合一：string-string\"><a href=\"#组合一：string-string\" class=\"headerlink\" title=\"组合一：string + string\"></a>组合一：string + string</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;把名字替换成新的: john&#x27;</span>;<br><span class=\"hljs-keyword\">let</span> new_str = str.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-string\">&#x27;john&#x27;</span>, <span class=\"hljs-string\">&#x27;jerry&#x27;</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;new_str is: &quot;</span>, new_str);<br><span class=\"hljs-comment\">// new_str is: 把名字替换成新的：jerry</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"组合二：regexp-string\"><a href=\"#组合二：regexp-string\" class=\"headerlink\" title=\"组合二：regexp + string\"></a>组合二：regexp + string</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;把名字替换成新的：john&#x27;</span>;<br><span class=\"hljs-keyword\">let</span> new_str = str.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/john/</span>, <span class=\"hljs-string\">&#x27;jerry&#x27;</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;new_str is: &quot;</span>, new_str);<br><span class=\"hljs-comment\">// new_str is: 把名字替换成新的：jerry</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"组合三：regexp-特殊符号\"><a href=\"#组合三：regexp-特殊符号\" class=\"headerlink\" title=\"组合三：regexp + 特殊符号\"></a>组合三：regexp + 特殊符号</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;交换名字：john,jerry&#x27;</span><br><span class=\"hljs-keyword\">let</span> new_str = str.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/(\\w+),(\\w+)/</span>, <span class=\"hljs-string\">&#x27;$2,$1&#x27;</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;new_str is: &quot;</span>, new_str);<br><span class=\"hljs-comment\">// new_str is: 交换名字：jerry,john</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"组合四：regexp-function\"><a href=\"#组合四：regexp-function\" class=\"headerlink\" title=\"组合四：regexp + function\"></a>组合四：regexp + function</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;交换名字：john,jerry&#x27;</span><br><span class=\"hljs-keyword\">let</span> new_str = str.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/(?&lt;person1&gt;\\w+),(?&lt;person2&gt;\\w+)/</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">match, n1, n2, offset, input, groups</span>)&#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;match:&quot;</span>,match);<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;n1:&quot;</span>,n1);<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;n2:&quot;</span>,n2);<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;offset:&quot;</span>,offset);<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;input:&quot;</span>,input);<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;groups:&quot;</span>,groups);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;n2&#125;</span> &amp;&amp; <span class=\"hljs-subst\">$&#123;n1&#125;</span>`</span>;<br>&#125;);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;new_str is: &quot;</span>, new_str);<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">    match: john,jerry</span><br><span class=\"hljs-comment\">    n1: john</span><br><span class=\"hljs-comment\">    n2: jerry</span><br><span class=\"hljs-comment\">    offset: 5</span><br><span class=\"hljs-comment\">    input: 交换名字：john,jerry</span><br><span class=\"hljs-comment\">    groups: &#123; person1: &#x27;john&#x27;, person2: &#x27;jerry&#x27; &#125;</span><br><span class=\"hljs-comment\">    new_str is:  交换名字：jerry &amp;&amp; john</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"split\"><a href=\"#split\" class=\"headerlink\" title=\"split\"></a>split</h4><p><code>split</code>方法主要用于分割字符串。</p>\n<ul>\n<li>参数：<ul>\n<li><code>separator</code> 分隔符，必填。可以是字符串或者正则表达式</li>\n<li><code>limit</code> 限制，可选。限定返回的分割片段数量。</li>\n</ul>\n</li>\n<li>返回：数组<code>arr</code>，包含了被分割后的片段。</li>\n</ul>\n<h5 id=\"limit-限制\"><a href=\"#limit-限制\" class=\"headerlink\" title=\"limit 限制\"></a><code>limit</code> 限制</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;123,44a,234a,1&#x27;</span>;<br><span class=\"hljs-keyword\">let</span> all = str.<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">&#x27;,&#x27;</span>);<br><span class=\"hljs-keyword\">let</span> part = str.<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">&#x27;,&#x27;</span>, <span class=\"hljs-number\">2</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;all is: &quot;</span>, all);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;part is: &quot;</span>, part);<br><span class=\"hljs-comment\">// all is:  [ &#x27;123&#x27;, &#x27;44a&#x27;, &#x27;234a&#x27;, &#x27;1&#x27; ]</span><br><span class=\"hljs-comment\">// part is:  [ &#x27;123&#x27;, &#x27;44a&#x27; ]</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"使用正则分割\"><a href=\"#使用正则分割\" class=\"headerlink\" title=\"使用正则分割\"></a>使用正则分割</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;year4mouth12days&#x27;</span>;<br><span class=\"hljs-keyword\">let</span> label = str.<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-regexp\">/\\d+/</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;label is: &quot;</span>, label);<br><span class=\"hljs-comment\">// label is:  [ &#x27;year&#x27;, &#x27;mouth&#x27;, &#x27;days&#x27; ] </span><br></code></pre></td></tr></table></figure>\n\n\n\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://juejin.im/post/6844903487155732494\">JS正则表达式完整教程（略长）</a></p>\n<p><a href=\"https://wizardforcel.gitbooks.io/py-re-guide/content/\">Python 正则表达式操作指南</a></p>\n<p><a href=\"https://www.bookstack.cn/read/deerchao-regex/README.md\">正则表达式30分钟入门教程（正则表达式入门教程）</a></p>\n<p><a href=\"https://www.cnblogs.com/onepixel/articles/7717789.html\">正则表达式零宽断言详解</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions\">MDN 正则表达式</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp\">MDN RegExp</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String\">MDN String</a></p>\n","site":{"data":{"languages/zh-CN":{"name":"简体中文","home":{"menu":"首页","title":"首页"},"archive":{"menu":"归档","title":"归档","subtitle":"归档","post_total":"共计 %d 篇文章"},"category":{"menu":"分类","title":"分类","subtitle":"分类","post_total":"共计 %d 篇文章","more":"More..."},"tag":{"menu":"标签","title":"标签","subtitle":"标签","post_total":"共计 %d 篇文章"},"about":{"menu":"关于","title":"关于","subtitle":"关于"},"links":{"menu":"友链","title":"友链","subtitle":"友情链接"},"page404":{"menu":"页面不存在","title":"页面不存在","subtitle":"页面不存在"},"post":{"toc":"目录","prev_post":"上一篇","next_post":"下一篇","updated":"本文最后更新于：%s","meta":{"wordcount":"%s 字","min2read":"%s 分钟","views":"{} 次"},"copyright":{"author":"作者","posted":"发布于","updated":"更新于","licensed":"许可协议","CC":"CC - 知识共享许可协议","BY":"BY - 署名","SA":"SA - 相同方式共享","NC":"NC - 非商业性使用","ND":"ND - 禁止演绎"}},"footer":{"pv":"总访问量 {} 次","uv":"总访客数 {} 人"},"search":{"title":"搜索","keyword":"关键词"},"noscript_warning":"博客在允许 JavaScript 运行的环境下浏览效果更佳"}}},"more":"<h2 id=\"简单理解正则表达式\"><a href=\"#简单理解正则表达式\" class=\"headerlink\" title=\"简单理解正则表达式\"></a>简单理解正则表达式</h2><p>正则表达式是用于匹配字符串中字符组合的模式，可以这样定义：</p>\n<blockquote>\n<p>正则表达式是对字符串（包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为“元字符”））操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。正则表达式是一种文本模式，该模式描述在搜索文本时要匹配的一个或多个字符串。</p>\n<p>胡军伟, 秦奕青, 张伟. 正则表达式在Web信息抽取中的应用[J]. 北京信息科技大学学报(自然科学版), 2011, 26(6):86-89.</p>\n</blockquote>\n<p>可以简单理解为，正则表达式就是对字符串操作的一种逻辑公式，就像数学公式一样，通过按照一定的规则，组合使用<code>+ - * / （）=</code> 以及数字或者变量，形成一个表达式。正则表达式也是使用一些具有特殊含义的<strong>特定符号</strong>，来抽象表达符合某种规则的字符串。这种特定符号，我们称之为<strong>元字符</strong>。元字符按功能又可以分为以下几种类型：</p>\n<ul>\n<li>字符</li>\n<li>位置</li>\n<li>量词</li>\n<li>分支</li>\n<li>分组</li>\n<li>引用</li>\n</ul>\n<p>通过对不同类型的元字符进行任意组合，就可以生成一个模式，使用这个模式，就可以在任意字符串中匹配你想要的内容。在js中，我们一般使用 <code>/表达式/ </code>的字面量来表示这是一个正则表达式。</p>\n<h2 id=\"字符类型\"><a href=\"#字符类型\" class=\"headerlink\" title=\"字符类型\"></a>字符类型</h2><p>在一个字符串中，如果我们想要要匹配某个或者某种类型的字符，我们可以选择<strong>精确匹配</strong>和<strong>模糊匹配</strong>。</p>\n<h4 id=\"模糊匹配\"><a href=\"#模糊匹配\" class=\"headerlink\" title=\"模糊匹配\"></a>模糊匹配</h4><p>模糊匹配就是一个<strong>元字符</strong>可以表示某一类字符集。</p>\n<p>下表列出了一些常用的元字符集：</p>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>定义</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>.</code></td>\n<td>通用符</td>\n<td>匹配除换行符（<code>\\n</code>、<code>\\r</code>）之外的任何单个字符</td>\n</tr>\n<tr>\n<td><code>\\s</code></td>\n<td>空白符（space）</td>\n<td>匹配任何<strong>空白字符</strong>，包括<strong>空格</strong>、<strong>换页符</strong>、<strong>换行符</strong>、<strong>回车符</strong>、<strong>制表符</strong>、<strong>垂直制表符</strong><br />等价于 <code>[ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]</code><br />⚠️ 这里有一个空格符号<br />⚠️ 记忆：空格符（十进制、八进制、十六进制） +  表中的特殊符号（十进制、八进制、十六进制）</td>\n</tr>\n<tr>\n<td><code>\\S</code></td>\n<td>非空白符</td>\n<td>匹配任何<strong>非</strong>空白字符<br />等价于<code>[^ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]</code>（这里的<code>^</code>表示<strong>非</strong>的意思）</td>\n</tr>\n<tr>\n<td><code>\\d</code></td>\n<td>数字符（digital）</td>\n<td>匹配一个数字。等价于<code>[0-9]</code></td>\n</tr>\n<tr>\n<td><code>\\D</code></td>\n<td>非数字符</td>\n<td>匹配一个非数字符。等价于<code>[^0-9]</code></td>\n</tr>\n<tr>\n<td><code>\\w</code></td>\n<td>字母、数字、下划线符（word）</td>\n<td>匹配一个单字字符（字母、数字或者下划线）。<br />等价于 <code>[A-Za-z0-9_]</code>。</td>\n</tr>\n<tr>\n<td><code>\\W</code></td>\n<td>非（字母、数字、下划线）符</td>\n<td>匹配一个非单字字符。<br />等价于 <code>[^A-Za-z0-9_]</code>。</td>\n</tr>\n<tr>\n<td><code>\\f</code></td>\n<td>换页符（特殊符号）</td>\n<td></td>\n</tr>\n<tr>\n<td><code>\\n</code></td>\n<td>换行符（特殊符号）</td>\n<td></td>\n</tr>\n<tr>\n<td><code>\\r</code></td>\n<td>回车符（特殊符号）</td>\n<td></td>\n</tr>\n<tr>\n<td><code>\\t</code></td>\n<td>制表符（特殊符号）</td>\n<td></td>\n</tr>\n<tr>\n<td><code>\\v</code></td>\n<td>垂直制表符（特殊符号）</td>\n<td></td>\n</tr>\n<tr>\n<td><code>[xyz]</code></td>\n<td>自定义字符集</td>\n<td>你可以在字符集中任意组合元字符和普通字符，形成一个自定义字符集，从而使字符串去匹配方括号中的任意字符。<br />可以使用 <code>-</code> 破折号代表范围<br />🌰<br /><code>[xyz]</code>：可以匹配<code>x</code> <code>y</code> <code>z</code> 三个字符中的任意一个<br /><code>[0-9a-z]</code>：等价于<code>[0123456789zbcdefghijklmnopqrstuvwxyz]</code> 表示匹配任意一个数字或者小写字母<br /><code>[\\dAa-z]</code> ：表示可以匹配任意一个数字（<code>\\d</code>）或者小写字母(<code>a-z</code>)以及大写字母<code>A</code></td>\n</tr>\n<tr>\n<td><code>[^xyz]</code></td>\n<td>自定义（排除）字符集</td>\n<td>在方括号内部的开头加上<code>^</code>，表示匹配任意一个<strong>不是</strong>自定义字符集内部的字符。如果在中间加上非呢？<br />🌰<br /><code>[^xyz]</code>：匹配<strong>排除</strong><code>x</code> <code>y</code> <code>z</code> 以外的任意一个字符<br /><code>[^\\dAa-z]</code> ：表示可以匹配任意一个 <strong>不是</strong> 数字（<code>\\d</code>） 且<strong>不是</strong>小写字母(<code>a-z</code>)且<strong>不是</strong>大写字母<code>A</code>的字符</td>\n</tr>\n</tbody></table>\n<h4 id=\"精确匹配\"><a href=\"#精确匹配\" class=\"headerlink\" title=\"精确匹配\"></a>精确匹配</h4><p>除<strong>元字符</strong>外，其他任意一个字符，只匹配字符本身。例如<code>/a/</code>，只能匹配字符串<code>abc</code>中的<code>a</code>。</p>\n<p> 如果想要匹配元字符<strong>本身</strong>，使用转义符号<code>\\</code>进行转义。</p>\n<p>🌰 想要匹配 <code>.</code> ，则写成<code>\\.</code></p>\n<p>🌰 想要匹配<code>+</code>（量词类型元字符），则写成<code>\\+</code></p>\n<h4 id=\"单字符匹配\"><a href=\"#单字符匹配\" class=\"headerlink\" title=\"单字符匹配\"></a>单字符匹配</h4><p>⚠️ 无论是模糊匹配还是精确匹配，在<strong>不加量词</strong>的情况下，一个<strong>字符符号</strong>（元字符或者普通符号）只能匹配单个字符。我们可以把正则里面的符号理解为占位符，一个萝卜一个坑。所以只要当前这个符号匹配到了字符，坑就被占了，下一个字符就需要有新的符号去匹配。所以我们如果要匹配多个字符，只要将多个<strong>字符符号</strong>组合在一起，形成一个子串模式，就能匹配一个满足条件的连续字符串。</p>\n<h5 id=\"匹配数字\"><a href=\"#匹配数字\" class=\"headerlink\" title=\"匹配数字\"></a>匹配数字</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;the id is: 123&#x27;</span>;<br><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/\\d/</span>;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str.<span class=\"hljs-title function_\">match</span>(reg)); <br><span class=\"hljs-comment\">// [ &#x27;1&#x27;, index: 11, input: &#x27;the id is: 123&#x27;, groups: undefined ]</span><br><span class=\"hljs-comment\">// match方法返回一个数组，其中数组的第一个元素表示匹配到的内容。</span><br><span class=\"hljs-comment\">// 可以看到每次只匹配一个字符</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"替换空白符号\"><a href=\"#替换空白符号\" class=\"headerlink\" title=\"替换空白符号\"></a>替换空白符号</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;the space is: \\n,\\f,\\r,\\t,\\v&#x27;</span>;<br><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/\\s/g</span>;\t<span class=\"hljs-comment\">// 将整个字符串中的空白符都替换为#</span><br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str.<span class=\"hljs-title function_\">replace</span>(reg, <span class=\"hljs-string\">&#x27;#&#x27;</span>));<br><span class=\"hljs-comment\">// 一次只会匹配成功一个，replace方法的说明在下面</span><br><span class=\"hljs-comment\">//the#space#is:##,#,#,#,#</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"删除所有非单字符\"><a href=\"#删除所有非单字符\" class=\"headerlink\" title=\"删除所有非单字符\"></a>删除所有非单字符</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;删除当前行中非数字(delete not number)123，(not word)非英文字母和非下划线_的符号！&#x27;</span>;<br><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/\\W/g</span>;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str.<span class=\"hljs-title function_\">replace</span>(reg, <span class=\"hljs-string\">&#x27;&#x27;</span>));\t<br><span class=\"hljs-comment\">//deletenotnumber123notword_</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"自定义字符集\"><a href=\"#自定义字符集\" class=\"headerlink\" title=\"自定义字符集\"></a>自定义字符集</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;在字符串中只留下字符集中的字符: 数字123，通配符. 普通英文字母wwwww&#x27;</span>;<br><br><span class=\"hljs-keyword\">let</span> reg1 = <span class=\"hljs-regexp\">/[^\\.数w]/g</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str.<span class=\"hljs-title function_\">replace</span>(reg1, <span class=\"hljs-string\">&#x27;&#x27;</span>));<br><span class=\"hljs-comment\">// 数.wwwww</span><br><br><span class=\"hljs-keyword\">let</span> reg2 = <span class=\"hljs-regexp\">/[\\.数w]/g</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str.<span class=\"hljs-title function_\">replace</span>(reg1, <span class=\"hljs-string\">&#x27;&#x27;</span>));<br><span class=\"hljs-comment\">//在字符串中只留下字符集中的字符: 字123，通配符 普通英文字母</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"位置类型\"><a href=\"#位置类型\" class=\"headerlink\" title=\"位置类型\"></a>位置类型</h2><p>什么是位置，什么又是位置字符呢？</p>\n<p>其实在一个连续的字符串中，相邻字符之间是存在一个位置的，我们可以把这个位置理解为空字符。如图所示（图源网络）：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/5/1731e6ec5794d5c5~tplv-t2oaga2asx-image.image\"></p>\n<p>在正则中，我们除了可以匹配具体字符以外，还可以使用元字符来表示具体要匹配哪个位置。</p>\n<p>在js中，表示位置的元字符分为4类：</p>\n<table>\n<thead>\n<tr>\n<th>位置</th>\n<th>相关元字符</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>开始</td>\n<td><code>^</code></td>\n</tr>\n<tr>\n<td>结尾</td>\n<td><code>$</code></td>\n</tr>\n<tr>\n<td>单词边界</td>\n<td><code>\\b</code> <code>\\B</code></td>\n</tr>\n<tr>\n<td>断言</td>\n<td><code>(?=)</code><br /><code>(?!)</code><br /><code>(?&lt;=)</code><br /><code>(?&lt;!)</code></td>\n</tr>\n</tbody></table>\n<h4 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h4><p>元字符<code>^</code>既可以表示位置，也可以代表非。</p>\n<ul>\n<li>表示位置时：这个元字符写在整个正则表达式的最开始。</li>\n<li>表示非时：写在方括号<code>[]</code>的最开始。</li>\n</ul>\n<p>当表示开始位置，代表当前正则表达式<strong>必须</strong>从字符串的<strong>最开始</strong>进行匹配。如果不存在这个元字符，只要字符串中任意一个子串满足正则表达式即可。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/^\\d/</span>;\t<span class=\"hljs-comment\">// 表示匹配到的字符串必须以数字开头</span><br><span class=\"hljs-keyword\">let</span> str1 = <span class=\"hljs-string\">&quot;abcdefg123&quot;</span>;<br><span class=\"hljs-keyword\">let</span> str2 = <span class=\"hljs-string\">&quot;123abcd&quot;</span>;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(reg.<span class=\"hljs-title function_\">test</span>(str1)) <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(reg.<span class=\"hljs-title function_\">test</span>(str2)) <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p>我们通常情况下都是对一个连续的单行字符串进行匹配，<code>^</code> 表示整个字符串的最开始。如果想要匹配多行文本中每行的开头，需要满足两个条件：</p>\n<ol>\n<li>当前字符串需要使用换行符<code>\\n</code>分割形成多行文本，<code>^</code>表示换行符<strong>后</strong>紧跟的位置</li>\n<li>需要将正则的多行标志<code>multiple</code>置为<code>true</code>（之后说明）</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/^\\d+/mg</span>;\t<span class=\"hljs-comment\">// m表示开启多行匹配。匹配当前多行文本中所有以数字开头的行，并获取开头的数字内容</span><br><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;123ad\\n0abc123\\nabc123&#x27;</span>;<br><span class=\"hljs-keyword\">let</span> a = str.<span class=\"hljs-title function_\">match</span>(reg);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a);<br><br><span class=\"hljs-comment\">//[ &#x27;123&#x27;, &#x27;0&#x27; ]</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"结束\"><a href=\"#结束\" class=\"headerlink\" title=\"结束\"></a>结束</h4><p>元字符 <code>$</code> 表示结束位置。匹配输入的结束。同 <code>^</code> 一样，如果多行标志被设置为 <code>true</code>，那么也匹配换行符<code>\\n</code><strong>前</strong>紧贴的位置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/\\d$/</span>;\t<span class=\"hljs-comment\">// 表示匹配到的字符串必须以数字结尾</span><br><span class=\"hljs-keyword\">let</span> str1 = <span class=\"hljs-string\">&quot;abcdefg123&quot;</span>;<br><span class=\"hljs-keyword\">let</span> str2 = <span class=\"hljs-string\">&quot;123abcd&quot;</span>;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(reg.<span class=\"hljs-title function_\">test</span>(str1)) <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(reg.<span class=\"hljs-title function_\">test</span>(str2)) <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/\\d+$/mg</span>;\t<span class=\"hljs-comment\">// m表示开启多行匹配。匹配当前多行文本中所有以数字开头的行，并获取开头的数字内容</span><br><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;123ad\\n0abc2\\nabc3&#x27;</span>;<br><span class=\"hljs-keyword\">let</span> a = str.<span class=\"hljs-title function_\">match</span>(reg);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a);<br><br><span class=\"hljs-comment\">//[ &#x27;2&#x27;, &#x27;3&#x27; ]</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"单词边界\"><a href=\"#单词边界\" class=\"headerlink\" title=\"单词边界\"></a>单词边界</h4><p>其实在这里，<code>\\b</code> 表示单词边界的位置，<code>\\B</code>表示<strong>非单词边界</strong>的位置。</p>\n<p>那什么是单词呢？我们回到之前的字符类型的元字符表可以看到，<code>\\w</code>其实就是word，连续的word形成了words，就是代表了这里的单词。我们已经知道<code>\\w</code>等价于<code>[A-Za-z0-9_]</code>，所以这里的单词就是指带了这些字符。</p>\n<p>那边界的定义又是什么？</p>\n<p>我们已知，每两个相邻字符之间，都存在一个位置，如果相邻两个字符都属于<code>\\w</code>，那这两个相邻字符之间的位置就叫<strong>非单词边界<code>\\B</code><strong>；如果两个相邻字符</strong>只有一个</strong>字符属于<code>\\w</code>，或者<strong>两个都不属于</strong><code>\\w</code>，那它们之间的位置就叫做**单词边界<code>\\b</code>**。 （<code>b</code>可以理解为<code>break</code>）</p>\n<p>需要注意的一点，字符串的开始和结束，都算作单词边界。可以理解为在字符串的开始和结束，存在一个空字符<code>&quot;&quot;</code> ，那么无论相邻的字符是否属于<code>\\w</code>，都存在一个空字符<code>&quot;&quot;</code>不属于<code>\\w</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> breakReg = <span class=\"hljs-regexp\">/\\b/g</span>,<br>    notBreakReg = <span class=\"hljs-regexp\">/\\B/g</span>;<br><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&quot;word_break.mp3&quot;</span>;<br><span class=\"hljs-keyword\">let</span> bStr = str.<span class=\"hljs-title function_\">replace</span>(breakReg, <span class=\"hljs-string\">&quot;|&quot;</span>);<br><span class=\"hljs-keyword\">let</span> <span class=\"hljs-title class_\">Bstr</span> = str.<span class=\"hljs-title function_\">replace</span>(notBreakReg, <span class=\"hljs-string\">&quot;|&quot;</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;bStr is: &quot;</span>, bStr);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Bstr is: &quot;</span>, <span class=\"hljs-title class_\">Bstr</span>);<br><br><br><span class=\"hljs-comment\">// bStr is:  |word_break|.|mp3|</span><br><span class=\"hljs-comment\">// Bstr is:  w|o|r|d|_|b|r|e|a|k.m|p|3</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"断言\"><a href=\"#断言\" class=\"headerlink\" title=\"断言\"></a>断言</h4><blockquote>\n<p>零宽断言正如它的名字一样，是一种零宽度的匹配，它匹配到的内容不会保存到匹配结果中去，最终匹配结果只是一个位置而已。<br>作用是给指定位置添加一个限定条件，用来规定此位置之前或者之后的字符必须满足限定条件才能使正则中的字表达式匹配成功。</p>\n<p>​                                                          ——源自博客《正则表达式零宽断言详解》</p>\n</blockquote>\n<p>听起来断言很复杂，其实道理很简单。所谓断言，其实就是我们的正则表达式在<strong>匹配位置</strong>的时候，必须要满足一定的条件才行。这里的条件，就是一个子表达式，其中断言又分为：</p>\n<ul>\n<li>先行：<ul>\n<li>正向：<code>(?=子表达式)</code></li>\n<li>负向：<code>(?!子表达式)</code></li>\n</ul>\n</li>\n<li>后行：<ul>\n<li>正向：<code>(?&lt;=子表达式)</code></li>\n<li>负向：<code>(?&lt;!子表达式)</code></li>\n</ul>\n</li>\n</ul>\n<p>在这里，先行和后行为相反组，表示匹配的位置在前还是在后；正向和负向为相反组，表示是否满足条件。组合起来的意思就是：</p>\n<ul>\n<li>正向先行<code>(?=)</code>：匹配<strong>满足</strong>子表达式的字符串<strong>前面</strong>的位置</li>\n<li>正向后行<code>(?&lt;=)</code>：匹配<strong>满足</strong>子表达式的字符串<strong>后面</strong>的位置</li>\n<li>负向先行<code>(?!)</code>：匹配<strong>不满足</strong>子表达式的字符串<strong>前面</strong>的位置</li>\n<li>负向后行<code>(?&lt;!)</code>：匹配<strong>不满足</strong>子表达式的字符串<strong>后面</strong>的位置</li>\n</ul>\n<p>简单记忆：</p>\n<ul>\n<li>正向：满足</li>\n<li>负向：不满足</li>\n<li>先行：前面</li>\n<li>后行：后面</li>\n</ul>\n<h5 id=\"正向（先-后）行\"><a href=\"#正向（先-后）行\" class=\"headerlink\" title=\"正向（先/后）行\"></a>正向（先/后）行</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;在js前面插入===,后面插入---: 前端基础三件套html,css,js; node, npm, react或者vue是新的三件套&#x27;</span>;<br><br><span class=\"hljs-keyword\">let</span> reg1 = <span class=\"hljs-regexp\">/(?=js)/g</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str.<span class=\"hljs-title function_\">replace</span>(reg1, <span class=\"hljs-string\">&#x27;===&#x27;</span>));<br><span class=\"hljs-comment\">// 在===js前面插入===,后面插入---: 前端基础三件套html,css,===js; node, npm, react或者vue是新的三件套</span><br><br><br><span class=\"hljs-keyword\">let</span> reg2 = <span class=\"hljs-regexp\">/(?&lt;=js)/g</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str.<span class=\"hljs-title function_\">replace</span>(reg2, <span class=\"hljs-string\">&#x27;---&#x27;</span>));<br><span class=\"hljs-comment\">// 在js---前面插入===,后面插入---: 前端基础三件套html,css,js---; node, npm, react或者vue是新的三件套</span><br></code></pre></td></tr></table></figure>\n\n\n<h5 id=\"负向（先-后）行\"><a href=\"#负向（先-后）行\" class=\"headerlink\" title=\"负向（先/后）行\"></a>负向（先/后）行</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;the number is 0000&#x27;</span>; <br><span class=\"hljs-comment\">// 在所有非字母和非空白符的字符前插入 ===，后面插入---</span><br><span class=\"hljs-comment\">// 实际上在这个字符串中会有三个字符会匹配成功：数字字符、字符串的开始空字符、结束空字符。</span><br><br><span class=\"hljs-keyword\">let</span> reg1 = <span class=\"hljs-regexp\">/(?![a-zA-Z\\s])/g</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str.<span class=\"hljs-title function_\">replace</span>(reg1, <span class=\"hljs-string\">&#x27;===&#x27;</span>));<br><span class=\"hljs-comment\">// the number is ===0===0===0===0===</span><br><span class=\"hljs-comment\">// 最后一个===实际上是匹配到了结束空字符&#x27;&#x27;，在结束空字符前插入了===</span><br><br><span class=\"hljs-keyword\">let</span> reg2 = <span class=\"hljs-regexp\">/(?&lt;![a-zA-Z\\s])/g</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str.<span class=\"hljs-title function_\">replace</span>(reg2, <span class=\"hljs-string\">&#x27;---&#x27;</span>));<br><span class=\"hljs-comment\">// ---the number is 0---0---0---0---</span><br><span class=\"hljs-comment\">// 第一个---实际上是匹配到了开始空字符&#x27;&#x27;，在开始空字符后插入了---</span><br></code></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"量词类型\"><a href=\"#量词类型\" class=\"headerlink\" title=\"量词类型\"></a>量词类型</h2><p>根据前面的了解，我们知道 一个符号只能匹配一个字符，如果要匹配多个字符，就需要组合多个符号（包括元字符和普通字符）来进行匹配。但是如果要匹配一个连续重复的字符串<code>aaaaaaaaa</code>，按照前面的逻辑，我们的正则表达式要写出 <code>/aaaaaaaaa/</code> 才行。有没有更简便的方法呢？</p>\n<p>答案是有的。</p>\n<p>在正则中，存在这种量词类型的元字符，来简化表达式本身。例如上面的正则表达式我们可以写成<code>/a&#123;9&#125;/</code>，表示当前满足条件，能匹配成功的子串包含9个连续的a。</p>\n<p>量词类型的元字符用来表示重复次数，具体重复的对象，是前面紧跟的子模式。</p>\n<p>其中，量词元字符包括：</p>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>*</code></td>\n<td>重复0到n次</td>\n</tr>\n<tr>\n<td><code>+</code></td>\n<td>重复1到n次</td>\n</tr>\n<tr>\n<td><code>?</code></td>\n<td>出现0次或者1次</td>\n</tr>\n<tr>\n<td><code>&#123;n&#125;</code></td>\n<td>重复n次</td>\n</tr>\n<tr>\n<td><code>&#123;n,&#125;</code></td>\n<td>至少重复n次</td>\n</tr>\n<tr>\n<td><code>&#123;n, m&#125;</code></td>\n<td>重复n到m次</td>\n</tr>\n</tbody></table>\n<p>例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;the number is 0000123122, phone number is 057-9981013&#x27;</span>;<br><br><span class=\"hljs-keyword\">let</span> reg1 = <span class=\"hljs-regexp\">/\\d+/g</span>;<br><span class=\"hljs-keyword\">let</span> reg2 = <span class=\"hljs-regexp\">/[num]&#123;3&#125;/g</span>;<br><span class=\"hljs-keyword\">let</span> reg3 = <span class=\"hljs-regexp\">/0&#123;2,4&#125;/g</span>;<br><span class=\"hljs-keyword\">let</span> reg4 = <span class=\"hljs-regexp\">/,?/</span>;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str.<span class=\"hljs-title function_\">match</span>(reg1))<br><span class=\"hljs-comment\">// [ &#x27;0000123122&#x27;, &#x27;057&#x27;, &#x27;9981013&#x27; ]</span><br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str.<span class=\"hljs-title function_\">match</span>(reg2))<br><span class=\"hljs-comment\">// [ &#x27;num&#x27;, &#x27;num&#x27; ]</span><br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str.<span class=\"hljs-title function_\">match</span>(reg3))<br><span class=\"hljs-comment\">// [ &#x27;0000&#x27; ]</span><br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(reg4.<span class=\"hljs-title function_\">test</span>(str))<br><span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"分组类型\"><a href=\"#分组类型\" class=\"headerlink\" title=\"分组类型\"></a>分组类型</h2><p>我们已知如何匹配一段由一个字符重复n次构成的字符串，例如 <code>aaaaaa</code> 。假如现在我们的字符串是<code>123xyzxyzxyz1axyzxyz</code>，很明显，这串字符中也存在重复的子串，但是并不满足单字符重复的特点，我们无法使用已经学到的东西来写出正则表达式。这个时候，就是分组类型的元字符上场的时候了。</p>\n<p>分组由圆括号 <code>()</code> 来表示。括号内部是子表达式，表示一个子串的匹配模式。说白了，分组就是把一些特殊的单字符组合看作一个单元，我们在匹配时，遇到这样的单元就当做一个整体来处理。具体是哪些特殊字符的组合，就可以任意定义，然后写成子模式。例如上面的字符串，我们把<code>xyz</code>看作一个单元，想要匹配出<code>xyz</code>，就可以这样写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&quot;123xyzxyzxyz1axyzxyz&quot;</span>;<br><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/(xyz)/g</span>;<br><span class=\"hljs-keyword\">let</span> match = str.<span class=\"hljs-title function_\">match</span>(reg);<br><br><span class=\"hljs-comment\">// [ &#x27;xyz&#x27;, &#x27;xyz&#x27;, &#x27;xyz&#x27;, &#x27;xyz&#x27;, &#x27;xyz&#x27; ]</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p>如果把连续的两个甚至多个<code>xyz</code>看作一个单元来匹配，只需要需要在分组后添加量词即可。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&quot;123xyzxyzxyz1axyzxyz&quot;</span>;<br><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/(xyz)+/g</span>;<br><span class=\"hljs-keyword\">let</span> match = str.<span class=\"hljs-title function_\">match</span>(reg);<br><br><span class=\"hljs-comment\">// [ &#x27;xyzxyzxyz&#x27;, &#x27;xyzxyz&#x27; ]</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p>在分组类型的元字符中，有三种类型：</p>\n<table>\n<thead>\n<tr>\n<th><strong>捕获分组</strong></th>\n<th><strong><code>（子表达式）</code></strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>命名捕获分组</strong></td>\n<td><strong>(?<name>子表达式)</strong></td>\n</tr>\n<tr>\n<td><strong>非捕获分组</strong></td>\n<td><strong><code>(?:子表达式)</code></strong></td>\n</tr>\n</tbody></table>\n<h5 id=\"捕获与非捕获\"><a href=\"#捕获与非捕获\" class=\"headerlink\" title=\"捕获与非捕获\"></a>捕获与非捕获</h5><p>其区别就在于，当我们使用捕获分组的时候，每个子表达式匹配到的内容都会被分别记录下来，后面我们可以通过相应的api或者是引用类型的元字符获取到不同分组的匹配项；而非捕获分组就是不记录这个匹配项。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/(\\d+)(?:[a-z]+)/</span>;\t<br><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&quot;123abcd&quot;</span>;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str.<span class=\"hljs-title function_\">match</span>(reg))<br><span class=\"hljs-comment\">// [ &#x27;123abcd&#x27;, &#x27;123&#x27;, index: 0, input: &#x27;123abcd&#x27;, groups: undefined ]</span><br><span class=\"hljs-comment\">// 在这里，123abcd是整个正则匹配到的内容，而123则是我们捕获分组匹配到的内容</span><br><span class=\"hljs-comment\">// 可以看到，此时非捕获分组匹配到的内容并没有被保存下来，我们无法单独获取</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"匿名捕获与命名捕获\"><a href=\"#匿名捕获与命名捕获\" class=\"headerlink\" title=\"匿名捕获与命名捕获\"></a>匿名捕获与命名捕获</h5><p>其中捕获分组又分为命名和匿名分组，匿名分组则使用索引值来获取，而命名分组除了可以使用索引值访问以外，还可以通过指定的属性访问获取。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/(\\d+)(?&lt;char&gt;[a-z]+)/</span>;<br><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&quot;123abcd&quot;</span>;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str.<span class=\"hljs-title function_\">match</span>(reg))<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/5/1731e6ccb87320ec~tplv-t2oaga2asx-image.image\"></p>\n<p>从结果中我们可以看到，使用命名捕获分组匹配到的分组，不但可以通过索引值来获取，还可以通过<code>groups.char</code>获取。</p>\n<h2 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h2><p>引用，其实就是对捕获分组匹配到的内容的引用。</p>\n<p>在两个地方可以使用引用：</p>\n<ul>\n<li>在表达式本式中</li>\n<li>在相关的函数中</li>\n</ul>\n<h5 id=\"表达式中的引用\"><a href=\"#表达式中的引用\" class=\"headerlink\" title=\"表达式中的引用\"></a>表达式中的引用</h5><p>在表达式中，有两种方法来获取引用：</p>\n<table>\n<thead>\n<tr>\n<th>元字符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>\\n</code></td>\n<td>匿名捕获分组的引用。它返回第n个子捕获匹配到的具体的内容(捕获的数目以左括号计数，即不论是否嵌套分组，命名捕获还是匿名捕获，都是按照左括号来计算，第一个左括号捕获的分组就是<code>\\1</code>, 第二个分组就是<code>\\2</code> …)。</td>\n</tr>\n<tr>\n<td><code>\\k&lt;name&gt;</code></td>\n<td>返回具体某个命名捕获分组的内容。</td>\n</tr>\n</tbody></table>\n<p>例如：判断一个字符串数组所有元素是否完全相等</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-string\">&#x27;abc&#x27;</span>, <span class=\"hljs-string\">&#x27;abc&#x27;</span>, <span class=\"hljs-string\">&#x27;abc&#x27;</span>];<br><span class=\"hljs-keyword\">let</span> str = arr.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;,&#x27;</span>); <span class=\"hljs-comment\">// abc,abc,abc</span><br><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/(\\w+),\\1/</span>; <span class=\"hljs-comment\">// 在这里，\\1 就表示了第一个分组获取到的具体内容。</span><br><br><span class=\"hljs-keyword\">let</span> match = reg.<span class=\"hljs-title function_\">test</span>(str);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(match); <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p>当然我们也可以使用命名捕获：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-string\">&#x27;item&#x27;</span>, <span class=\"hljs-string\">&#x27;item&#x27;</span>, <span class=\"hljs-string\">&#x27;item&#x27;</span>];<br><span class=\"hljs-keyword\">let</span> str = arr.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;,&#x27;</span>)+<span class=\"hljs-string\">&#x27;,&#x27;</span>;\t<span class=\"hljs-comment\">// item,item,item,</span><br><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/(?&lt;element&gt;\\w+)(,)\\k&lt;element&gt;\\2/</span>; <span class=\"hljs-comment\">// 等价于/(?&lt;element&gt;\\w+)(,)\\1\\2/</span><br><br><span class=\"hljs-keyword\">let</span> match = reg.<span class=\"hljs-title function_\">test</span>(str);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(match); <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"相关函数中的引用\"><a href=\"#相关函数中的引用\" class=\"headerlink\" title=\"相关函数中的引用\"></a>相关函数中的引用</h5><p>在函数中有两种，一种是特殊字符指代，一种是函数参数。</p>\n<p>例如在<code>string.prototype.replace</code>中，可以使用特殊字符 <code>$n</code> 来指代分组，同样的，数字 <code>n </code>代表分组索引。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 交换位置</span><br><span class=\"hljs-keyword\">let</span> names = <span class=\"hljs-string\">&#x27;john,marry,jerry&#x27;</span>;<br><span class=\"hljs-keyword\">let</span> new_names = names.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/(\\w+),(\\w+),(\\w+)/</span>, <span class=\"hljs-string\">&#x27;$2,$3,$1&#x27;</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(new_names); <br><br><span class=\"hljs-comment\">// marry,jerry,john</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p>也可以在函数参数中使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 交换位置</span><br><span class=\"hljs-keyword\">let</span> names = <span class=\"hljs-string\">&#x27;john,marry,jerry&#x27;</span>;<br><span class=\"hljs-keyword\">let</span> new_names = names.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/(\\w+),(\\w+),(\\w+)/</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">content, n1, n2, n3</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;n3&#125;</span> <span class=\"hljs-subst\">$&#123;n2&#125;</span> <span class=\"hljs-subst\">$&#123;n1&#125;</span>`</span>;<br>&#125;);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(new_names); <br><span class=\"hljs-comment\">// jerry marry john</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p>具体的 <code>replace</code> 方法介绍在下面。</p>\n<h2 id=\"分支类型\"><a href=\"#分支类型\" class=\"headerlink\" title=\"分支类型\"></a>分支类型</h2><p>当我们在匹配一个字符串时，如果存在其中某部分子串，既可以是A，又可以是B，就可以使用分支元字符。</p>\n<table>\n<thead>\n<tr>\n<th>元字符</th>\n<th>定义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>`</td>\n<td>`</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> strArr = [<span class=\"hljs-string\">&#x27;year&#x27;</span>,<span class=\"hljs-string\">&#x27;mouth&#x27;</span>,<span class=\"hljs-string\">&#x27;day&#x27;</span>];<br><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/mouth|day/</span>;\t<span class=\"hljs-comment\">//  匹配mouth或者day</span><br><br>strArr.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">str</span> =&gt;</span> &#123;<br>     <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str, <span class=\"hljs-string\">&quot;: &quot;</span>, reg.<span class=\"hljs-title function_\">test</span>(str));<br>&#125;)<br><br><br><span class=\"hljs-comment\">// year :  false</span><br><span class=\"hljs-comment\">// mouth :  true</span><br><span class=\"hljs-comment\">// day :  true</span><br></code></pre></td></tr></table></figure>\n\n\n\n\n\n<p>如果需要匹配这样一个字符串，既可以是A，又可以是B，同时又要满足C的时候，还可以结合分组来使用</p>\n<p>例如匹配 <code>&quot;window98 / window2000 / window10&quot;</code> 这样一个字符串：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> wins = [<span class=\"hljs-string\">&#x27;window98&#x27;</span>,<span class=\"hljs-string\">&#x27;window2000&#x27;</span>, <span class=\"hljs-string\">&#x27;window10&#x27;</span>, <span class=\"hljs-string\">&#x27;window99&#x27;</span>];<br><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/window(98|2000|10)/</span>;<br><br>wins.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">str</span> =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str, <span class=\"hljs-string\">&quot;: &quot;</span>, reg.<span class=\"hljs-title function_\">test</span>(str));<br>&#125;)<br><br><span class=\"hljs-comment\">// window98 :  true</span><br><span class=\"hljs-comment\">// window2000 :  true</span><br><span class=\"hljs-comment\">// window10 :  true</span><br><span class=\"hljs-comment\">// window99 :  false</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"JS中的正则\"><a href=\"#JS中的正则\" class=\"headerlink\" title=\"JS中的正则\"></a>JS中的正则</h2><p>JS中与正则相关的主要有两种对象，<code>String</code> 对象和 <code>RegExp</code> 对象。</p>\n<h3 id=\"RegExp对象\"><a href=\"#RegExp对象\" class=\"headerlink\" title=\"RegExp对象\"></a>RegExp对象</h3><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/5/1731e6dd6df72f7b~tplv-t2oaga2asx-image.image\"></p>\n<h4 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h4><h5 id=\"字面量\"><a href=\"#字面量\" class=\"headerlink\" title=\"字面量\"></a>字面量</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/\\d/</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RegExp</span>(<span class=\"hljs-string\">&#x27;ab+c&#x27;</span>, <span class=\"hljs-string\">&#x27;i&#x27;</span>); <span class=\"hljs-comment\">// 使用字符串创建</span><br><span class=\"hljs-keyword\">let</span> reg1 =<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RegExp</span>(<span class=\"hljs-regexp\">/ab+c/</span>, <span class=\"hljs-string\">&#x27;i&#x27;</span>); <span class=\"hljs-comment\">// 使用字面量创建</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"工厂函数\"><a href=\"#工厂函数\" class=\"headerlink\" title=\"工厂函数\"></a>工厂函数</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-title class_\">RegExp</span>(<span class=\"hljs-string\">&#x27;ab+c&#x27;</span>, <span class=\"hljs-string\">&#x27;i&#x27;</span>);\t<span class=\"hljs-comment\">// 使用字符串创建</span><br><span class=\"hljs-keyword\">let</span> reg1 =<span class=\"hljs-title class_\">RegExp</span>(<span class=\"hljs-regexp\">/ab+c/</span>, <span class=\"hljs-string\">&#x27;i&#x27;</span>);\t<span class=\"hljs-comment\">// 使用字面量创建</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p>注意：在使用RegExp方法创建正则表达式时，如果想要 <code>string</code> 类型的参数中使用元字符时，需要转义，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 想要构建出 /\\d+/ 这样的表达式</span><br><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-title class_\">RegExp</span>(<span class=\"hljs-string\">&#x27;\\d+&#x27;</span>, <span class=\"hljs-string\">&#x27;i&#x27;</span>);\t<br><span class=\"hljs-comment\">// 此时创建出来的结果是 /d+/ 而不是目标表达式</span><br><br><span class=\"hljs-comment\">// 正确的写法应该是：</span><br><span class=\"hljs-comment\">// RegExp(&#x27;\\\\d+&#x27;, &#x27;i&#x27;);\t</span><br></code></pre></td></tr></table></figure>\n\n\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/5/1731e6e2936db248~tplv-t2oaga2asx-image.image\"></p>\n<h4 id=\"lastIndex\"><a href=\"#lastIndex\" class=\"headerlink\" title=\"lastIndex\"></a>lastIndex</h4><p>保存了当前正则实例上次匹配的位置。表示下次匹配从哪里开始。这个属性只有正则表达式使用了表示全局检索的 “<code>g</code>“ 标志时，该属性才会起作用。所以当我们在使用全局匹配时，需要注意当前这个值是否被修改。<strong>MDN</strong>中是这样定义的：</p>\n<blockquote>\n<ul>\n<li>如果 <code>lastIndex</code> 大于字符串的长度，则 <code>regexp.test</code> 和 <code>regexp.exec</code> 将会匹配失败，然后 <code>lastIndex</code> 被设置为 0。</li>\n<li>如果 <code>lastIndex</code> 等于字符串的长度，且该正则表达式匹配空字符串，则该正则表达式匹配从 <code>lastIndex</code> 开始的字符串。（then the regular expression matches input starting at <code>lastIndex</code>.）</li>\n<li>如果 <code>lastIndex</code> 等于字符串的长度，且该正则表达式不匹配空字符串 ，则该正则表达式不匹配字符串，<code>lastIndex</code> 被设置为 0.。</li>\n<li>否则，<code>lastIndex</code> 被设置为紧随最近一次成功匹配的下一个位置。</li>\n</ul>\n</blockquote>\n<p>例如</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/\\d+/g</span>;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">matchNumber</span>(<span class=\"hljs-params\">str</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> reg.<span class=\"hljs-title function_\">test</span>(str);<br>&#125;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">matchNumber</span>(<span class=\"hljs-string\">&#x27;123&#x27;</span>)); <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">matchNumber</span>(<span class=\"hljs-string\">&#x27;456&#x27;</span>)); <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n\n<p>上面的方法，我们期望返回两个<code>true</code>，但实际第一个确实返回<code>true</code>，第二个却返回了 <code>false</code>，这是因为我们的正则是一个全局变量，所以每次调用之后更改了<code>lastIndex</code>， 而每次的匹配都从<code>lastIndex</code>开始，所以第二次匹配，传入<code>456</code>实际会从第四个字符开始匹配。此时第四个字符为空，所以返回 <code>false</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/\\d+/g</span>;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">matchNumber</span>(<span class=\"hljs-params\">str</span>)&#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;reg.lastIndex is: &quot;</span>, reg.<span class=\"hljs-property\">lastIndex</span>);<br>    <span class=\"hljs-keyword\">return</span> reg.<span class=\"hljs-title function_\">test</span>(str);<br>&#125;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">matchNumber</span>(<span class=\"hljs-string\">&#x27;123&#x27;</span>)); <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">matchNumber</span>(<span class=\"hljs-string\">&#x27;456&#x27;</span>)); <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">matchNumber</span>(<span class=\"hljs-string\">&#x27;4&#x27;</span>));<br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">reg.lastIndex is:  0</span><br><span class=\"hljs-comment\">true</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">reg.lastIndex is:  3</span><br><span class=\"hljs-comment\">false</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">reg.lastIndex is:  0\t</span><br><span class=\"hljs-comment\">true</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h4><h5 id=\"test\"><a href=\"#test\" class=\"headerlink\" title=\"test\"></a>test</h5><p>测试当前字符串是否满足某个模式</p>\n<p>参数：<code>str</code> 要匹配正则表达式的字符串。</p>\n<p>返回：<code>boolean</code>值，表示是否匹配成功</p>\n<p>例如判断当前字符串是否由11位数字组成：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/^\\d&#123;11&#125;$/</span>;<br><span class=\"hljs-keyword\">let</span> phone_number = <span class=\"hljs-string\">&#x27;13577898320&#x27;</span>;<br><br>reg.<span class=\"hljs-title function_\">test</span>(phone_number); <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"exec\"><a href=\"#exec\" class=\"headerlink\" title=\"exec\"></a>exec</h5><p>方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null\"><code>null</code></a>。</p>\n<p>参数：<code>str</code> 要匹配正则表达式的字符串。</p>\n<p>返回：一个数组：</p>\n<table>\n<thead>\n<tr>\n<th>对象</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>[0]</code></td>\n<td>匹配的全部字符串</td>\n</tr>\n<tr>\n<td><code>[1], ...[*n* ]</code></td>\n<td>括号中的分组捕获</td>\n</tr>\n<tr>\n<td><code>index</code></td>\n<td>匹配到的字符位于原始字符串的索引值</td>\n</tr>\n<tr>\n<td><code>input</code></td>\n<td>原始字符串</td>\n</tr>\n<tr>\n<td><code>groups</code></td>\n<td>命名捕获对象</td>\n</tr>\n</tbody></table>\n<p>⚠️：在js与正则相关的函数中，调用这个函数，会涉及到正则对象的状态。MDN中是这样解释的：</p>\n<blockquote>\n<p>在设置了 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/global\"><code>global</code></a> 或 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky\"><code>sticky</code></a> 标志位的情况下（如 <code>/foo/g</code> or <code>/foo/y</code>），JavaScript <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp\"><code>RegExp</code></a> 对象是<strong>有状态</strong>的。他们会将上次成功匹配后的位置记录在 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex\"><code>lastIndex</code></a> 属性中。使用此特性，<code>exec()</code> 可用来对单个字符串中的多次匹配结果进行逐条的遍历（包括捕获到的匹配），而相比之下， <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match\"><code>String.prototype.match()</code></a> 只会返回匹配到的结果。</p>\n</blockquote>\n<p>提取出字符串中所有的数字</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;各科成绩如下:数学: 121;语文: 120;英语: 138&#x27;</span><br><span class=\"hljs-keyword\">let</span> reg = <span class=\"hljs-regexp\">/\\d+/g</span>;<br><span class=\"hljs-keyword\">let</span> result = <span class=\"hljs-literal\">null</span>;<br><span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">while</span> ((result = reg.<span class=\"hljs-title function_\">exec</span>(str)) !== <span class=\"hljs-literal\">null</span>) &#123;<br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`-------------第<span class=\"hljs-subst\">$&#123;++i&#125;</span>次循环开始------------------`</span>)<br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;result is: &quot;</span>, result); <br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;reg.lastIndex is: &quot;</span>, reg.<span class=\"hljs-property\">lastIndex</span>); <br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`-------------第<span class=\"hljs-subst\">$&#123;++i&#125;</span>次循环结束------------------`</span>)<br>&#125;<br><br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">-------------第1次循环开始------------------</span><br><span class=\"hljs-comment\">result is:  [ &#x27;121&#x27;,</span><br><span class=\"hljs-comment\">  index: 11,</span><br><span class=\"hljs-comment\">  input: &#x27;各科成绩如下:数学: 121;语文: 120;英语: 138&#x27;,</span><br><span class=\"hljs-comment\">  groups: undefined ]</span><br><span class=\"hljs-comment\">  </span><br><span class=\"hljs-comment\">reg.lastIndex is:  14</span><br><span class=\"hljs-comment\">-------------第1次循环结束------------------</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">-------------第2次循环开始------------------</span><br><span class=\"hljs-comment\">result is:  [ &#x27;120&#x27;,</span><br><span class=\"hljs-comment\">  index: 19,</span><br><span class=\"hljs-comment\">  input: &#x27;各科成绩如下:数学: 121;语文: 120;英语: 138&#x27;,</span><br><span class=\"hljs-comment\">  groups: undefined ]</span><br><span class=\"hljs-comment\">reg.lastIndex is:  22</span><br><span class=\"hljs-comment\">-------------第2次循环结束------------------</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">-------------第3次循环开始------------------</span><br><span class=\"hljs-comment\">result is:  [ &#x27;138&#x27;,</span><br><span class=\"hljs-comment\">  index: 27,</span><br><span class=\"hljs-comment\">  input: &#x27;各科成绩如下:数学: 121;语文: 120;英语: 138&#x27;,</span><br><span class=\"hljs-comment\">  groups: undefined ]</span><br><span class=\"hljs-comment\">  </span><br><span class=\"hljs-comment\">reg.lastIndex is:  30</span><br><span class=\"hljs-comment\">-------------第3次循环结束------------------</span><br><span class=\"hljs-comment\">*/</span><br><br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"String对象\"><a href=\"#String对象\" class=\"headerlink\" title=\"String对象\"></a>String对象</h3><p>String对象中涉及到正则的主要有4个方法：</p>\n<ul>\n<li><code>search</code></li>\n<li><code>match</code></li>\n<li><code>replace</code></li>\n<li><code>split</code></li>\n</ul>\n<p>而其中，<code>match</code>方法中，正则表达式的 <code>global</code> 的不同值会影响返回结果。</p>\n<h4 id=\"search\"><a href=\"#search\" class=\"headerlink\" title=\"search\"></a>search</h4><p><code>search</code>方法很简单，主要用来查找子串的位置。</p>\n<ul>\n<li>参数：一个正则表达式，必填</li>\n<li>返回：找到的第一个子串在字符串中的索引值，如果没有找到就返回 <code>-1</code> </li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;find subString index: subString&#x27;</span>;<br><span class=\"hljs-keyword\">let</span> reg1 = <span class=\"hljs-regexp\">/subString/</span>;<br><span class=\"hljs-keyword\">let</span> reg2 = <span class=\"hljs-regexp\">/substring/</span>;<br><span class=\"hljs-keyword\">let</span> reg3 = <span class=\"hljs-regexp\">/subString/g</span>;<br><br>str.<span class=\"hljs-title function_\">search</span>(reg1);\t\t<span class=\"hljs-comment\">// 5</span><br>str.<span class=\"hljs-title function_\">search</span>(reg1);\t\t<span class=\"hljs-comment\">// -1</span><br>str.<span class=\"hljs-title function_\">search</span>(reg1);\t\t<span class=\"hljs-comment\">// 5 此时有无global都不影响结果</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match\"></a>match</h4><p><code>match </code>方法中，主要用来提取字符串中满足条件的子串。</p>\n<ul>\n<li>参数：正则表达式，，必填。这个正则表达式的 <code>global</code> 标志的值会影响返回结果：<ul>\n<li><code>global == true</code> ：返回一个数组，包含了整个字符串中所有满足条件的子串。 </li>\n<li><code>global == false</code>： 返回<ul>\n<li>数组<code>arr</code> ：<ul>\n<li><code>arr[0]</code> 是当前正则匹配到的第一个子串的值</li>\n<li><code>arr[1] - arr[n]</code> ：分别是当前分组中捕获到的内容，有多少个分组就有多少项。且按照分组的顺序存储</li>\n</ul>\n</li>\n<li><code>index</code> ：当前匹配到的子串在整个字符串中的索引值</li>\n<li><code>input</code> ：源字符串</li>\n<li><code>groups</code>：对象，包含了所有命名捕获组匹配到的内容 ，如果没有定义命名捕获组则为<code>undefined</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;find subString index: subString&#x27;</span>;<br><span class=\"hljs-keyword\">let</span> reg1 = <span class=\"hljs-regexp\">/subString/</span>;<br><span class=\"hljs-keyword\">let</span> reg2 = <span class=\"hljs-regexp\">/substring/</span>;<br><span class=\"hljs-keyword\">let</span> reg3 = <span class=\"hljs-regexp\">/subString/g</span>;<br><br>str.<span class=\"hljs-title function_\">match</span>(reg1);<br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">[</span><br><span class=\"hljs-comment\">  &#x27;subString&#x27;,</span><br><span class=\"hljs-comment\">  index: 5,</span><br><span class=\"hljs-comment\">  input: &#x27;find subString index: subString&#x27;,</span><br><span class=\"hljs-comment\">  groups: undefined</span><br><span class=\"hljs-comment\">]</span><br><span class=\"hljs-comment\">**/</span><br>str.<span class=\"hljs-title function_\">match</span>(reg2);\t<span class=\"hljs-comment\">// null</span><br>str.<span class=\"hljs-title function_\">match</span>(reg3);\t<span class=\"hljs-comment\">// [ &#x27;subString&#x27;, &#x27;subString&#x27; ]</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"replace\"><a href=\"#replace\" class=\"headerlink\" title=\"replace\"></a>replace</h4><p><code>replace</code>方法，就是用指定的值来替换源字符串中一些特定的子串。</p>\n<ul>\n<li><p>参数：</p>\n<ul>\n<li><p><code>pattern</code>： 模式，指定被替换的子串类型。可以是一个 <code>String</code>，也可以是一个 <code>RegExp</code> </p>\n<ul>\n<li> <code>String</code> </li>\n<li> <code>RegExp</code>：当为<code>RegExp</code>对象时，如果 <code>global</code>标志为<code>false</code>，则只会替换匹配到的第一个子串。</li>\n</ul>\n</li>\n<li><p><code>replacement</code>： 替换值，用于替换指定的子串。可以是一个 <code>String</code>，也可以是一个<code>Function</code></p>\n<ul>\n<li><p><code>String</code>：如果pattern是一个<code>RegExp</code>，还可以使用一些特殊字符来插入命令：</p>\n<ul>\n<li><table>\n<thead>\n<tr>\n<th><strong><code>?</code></strong></th>\n<th><strong>插入一个 “$”</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><code>$&amp;</code></strong></td>\n<td><strong>插入匹配的子串</strong></td>\n</tr>\n<tr>\n<td><strong>$`</strong></td>\n<td><strong>插入当前匹配的子串左边的内容</strong></td>\n</tr>\n<tr>\n<td><strong><code>$&#39;</code></strong></td>\n<td><strong>插入当前匹配的子串右边的内容</strong></td>\n</tr>\n<tr>\n<td><strong><code>$n</code></strong></td>\n<td><strong>插入指定的捕获组内容</strong></td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n</li>\n<li><p><code>Function</code>：替换函数，可以指定返回的新字符串。只有第一个参数为正则时才生效。</p>\n<ul>\n<li><blockquote>\n<p>你可以指定一个函数作为第二个参数。在这种情况下，当匹配执行后，该函数就会执行。 函数的返回值作为替换字符串。 (注意：上面提到的特殊替换参数在这里不能被使用。) 另外要注意的是，如果第一个参数是正则表达式，<strong>并且其为全局匹配模式</strong>，那么这个方法将被多次调用，每次匹配都会被调用。（源自MDN）</p>\n</blockquote>\n</li>\n<li><p>参数：</p>\n<ul>\n<li><code>match</code>：每次匹配到的子串。</li>\n<li><code>p1,p2, ...</code>：假如<code>replace</code> 的 <code>pattern</code> 参数是一个 <code>RegExp</code>，则这里就是分别指代了各个分组匹配到的内容。</li>\n<li><code>offset</code>：匹配到的子字符串在原字符串中的偏移量。</li>\n<li><code>string</code>：源字符串。</li>\n<li><code>NamedCaptureGroup</code>： 命名捕获组匹配的对象</li>\n</ul>\n</li>\n<li><p>返回：替换后的新字符串。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>返回：替换后的新字符串。</p>\n</li>\n</ul>\n<p>有四种组合方式：</p>\n<h5 id=\"组合一：string-string\"><a href=\"#组合一：string-string\" class=\"headerlink\" title=\"组合一：string + string\"></a>组合一：string + string</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;把名字替换成新的: john&#x27;</span>;<br><span class=\"hljs-keyword\">let</span> new_str = str.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-string\">&#x27;john&#x27;</span>, <span class=\"hljs-string\">&#x27;jerry&#x27;</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;new_str is: &quot;</span>, new_str);<br><span class=\"hljs-comment\">// new_str is: 把名字替换成新的：jerry</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"组合二：regexp-string\"><a href=\"#组合二：regexp-string\" class=\"headerlink\" title=\"组合二：regexp + string\"></a>组合二：regexp + string</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;把名字替换成新的：john&#x27;</span>;<br><span class=\"hljs-keyword\">let</span> new_str = str.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/john/</span>, <span class=\"hljs-string\">&#x27;jerry&#x27;</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;new_str is: &quot;</span>, new_str);<br><span class=\"hljs-comment\">// new_str is: 把名字替换成新的：jerry</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"组合三：regexp-特殊符号\"><a href=\"#组合三：regexp-特殊符号\" class=\"headerlink\" title=\"组合三：regexp + 特殊符号\"></a>组合三：regexp + 特殊符号</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;交换名字：john,jerry&#x27;</span><br><span class=\"hljs-keyword\">let</span> new_str = str.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/(\\w+),(\\w+)/</span>, <span class=\"hljs-string\">&#x27;$2,$1&#x27;</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;new_str is: &quot;</span>, new_str);<br><span class=\"hljs-comment\">// new_str is: 交换名字：jerry,john</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"组合四：regexp-function\"><a href=\"#组合四：regexp-function\" class=\"headerlink\" title=\"组合四：regexp + function\"></a>组合四：regexp + function</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;交换名字：john,jerry&#x27;</span><br><span class=\"hljs-keyword\">let</span> new_str = str.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/(?&lt;person1&gt;\\w+),(?&lt;person2&gt;\\w+)/</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">match, n1, n2, offset, input, groups</span>)&#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;match:&quot;</span>,match);<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;n1:&quot;</span>,n1);<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;n2:&quot;</span>,n2);<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;offset:&quot;</span>,offset);<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;input:&quot;</span>,input);<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;groups:&quot;</span>,groups);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;n2&#125;</span> &amp;&amp; <span class=\"hljs-subst\">$&#123;n1&#125;</span>`</span>;<br>&#125;);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;new_str is: &quot;</span>, new_str);<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">    match: john,jerry</span><br><span class=\"hljs-comment\">    n1: john</span><br><span class=\"hljs-comment\">    n2: jerry</span><br><span class=\"hljs-comment\">    offset: 5</span><br><span class=\"hljs-comment\">    input: 交换名字：john,jerry</span><br><span class=\"hljs-comment\">    groups: &#123; person1: &#x27;john&#x27;, person2: &#x27;jerry&#x27; &#125;</span><br><span class=\"hljs-comment\">    new_str is:  交换名字：jerry &amp;&amp; john</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"split\"><a href=\"#split\" class=\"headerlink\" title=\"split\"></a>split</h4><p><code>split</code>方法主要用于分割字符串。</p>\n<ul>\n<li>参数：<ul>\n<li><code>separator</code> 分隔符，必填。可以是字符串或者正则表达式</li>\n<li><code>limit</code> 限制，可选。限定返回的分割片段数量。</li>\n</ul>\n</li>\n<li>返回：数组<code>arr</code>，包含了被分割后的片段。</li>\n</ul>\n<h5 id=\"limit-限制\"><a href=\"#limit-限制\" class=\"headerlink\" title=\"limit 限制\"></a><code>limit</code> 限制</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;123,44a,234a,1&#x27;</span>;<br><span class=\"hljs-keyword\">let</span> all = str.<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">&#x27;,&#x27;</span>);<br><span class=\"hljs-keyword\">let</span> part = str.<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">&#x27;,&#x27;</span>, <span class=\"hljs-number\">2</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;all is: &quot;</span>, all);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;part is: &quot;</span>, part);<br><span class=\"hljs-comment\">// all is:  [ &#x27;123&#x27;, &#x27;44a&#x27;, &#x27;234a&#x27;, &#x27;1&#x27; ]</span><br><span class=\"hljs-comment\">// part is:  [ &#x27;123&#x27;, &#x27;44a&#x27; ]</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"使用正则分割\"><a href=\"#使用正则分割\" class=\"headerlink\" title=\"使用正则分割\"></a>使用正则分割</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&#x27;year4mouth12days&#x27;</span>;<br><span class=\"hljs-keyword\">let</span> label = str.<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-regexp\">/\\d+/</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;label is: &quot;</span>, label);<br><span class=\"hljs-comment\">// label is:  [ &#x27;year&#x27;, &#x27;mouth&#x27;, &#x27;days&#x27; ] </span><br></code></pre></td></tr></table></figure>\n\n\n\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://juejin.im/post/6844903487155732494\">JS正则表达式完整教程（略长）</a></p>\n<p><a href=\"https://wizardforcel.gitbooks.io/py-re-guide/content/\">Python 正则表达式操作指南</a></p>\n<p><a href=\"https://www.bookstack.cn/read/deerchao-regex/README.md\">正则表达式30分钟入门教程（正则表达式入门教程）</a></p>\n<p><a href=\"https://www.cnblogs.com/onepixel/articles/7717789.html\">正则表达式零宽断言详解</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions\">MDN 正则表达式</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp\">MDN RegExp</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String\">MDN String</a></p>\n"},{"title":"this指针和箭头函数","date":"2023-02-28T13:10:23.000Z","excerpt":"this是一个引用，指向当前函数执行的上下文对象。是在运行时绑定的。","_content":"# 什么是`this`？\n\n`this`是一个引用，指向当前函数执行的**上下文对象**。是在运行时绑定的。\n\n>💡 执行上下文\n当 JS 引擎解析到可执行代码片段（通常是函数调用阶段）的时候，就会先做一些执行前的准备工作，这个 “准备工作”，就叫做 \"**执行上下文(execution context 简称 EC)**\" 或者也可以叫做 **执行环境**。\n执行上下文 为我们的可执行代码块提供了执行前的必要准备工作，例如变量对象的定义、作用域链的扩展、提供调用者的对象引用等信息。\n\n\n\n\n![this.png](this.png)\n\n# this的绑定规则\n\n优先级：`new` > 显示绑定 > 隐式绑定 > 默认绑定\n\n## 默认绑定\n\n当函数被**独立调用**时，默认函数的`this`指向**全局对象**，此时在浏览器运行环境中，能获取到全局对象下使用[var操作符定义的变量，但不能获取到let定义的变量](https://www.notion.so/c80e2b095b104f7f8c53c745185de9d0)。\n\n当在[严格模式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode)下时，`this`不能获取到全局对象下的变量。\n\n```jsx\n// 浏览器运行环境下\nfunction foo(){\n\tconsole.log('name is: ', this.name);\n\tconsole.log('age is: ', this.age);\n}\n\nvar name = 'kira';\nlet age = 3;\n\nfoo();\n// name is:  kira\n// age is:  undefined\n```\n\n```jsx\n// 严格模式\n\"use strict\";\nfunction foo(){\n\tconsole.log('name is: ', this.name);\n\tconsole.log('age is: ', this.age);\n\n}\n\nvar name = 'kira';\nlet age = 3;\n\nfoo();\n/* \n   Uncaught TypeError: Cannot read property 'name' of undefined at foo \n*/\n```\n\n## 隐式绑定\n\n使用**对象调用**时，函数的`this`会指向当前调用的对象。\n\n`this` 指向链式调用的最后一层\n\n```jsx\nfunction foo(){\n\tconsole.log('name is: ', this.name);\n\tconsole.log('age is: ', this.age);\n\n}\n\nconst person = {\n\tname: 'kira',\n\tage: 3,\n\tfoo: foo\n}\n\nperson.foo();\n// name is:  kira\n// age is:  3\n```\n\n**还需要注意的是隐式绑定丢失：**\n\n当把对象 `o` 的方法 `o.method` 赋值给一个变量 `fn`，然后再调用这个变量 `fn` 的时候，`this` 不会指向这个对象 `o`，而会指向全局对象。\n这是因为，赋值语句是静态执行，而 `this` 绑定是动态绑定。\n当我们把一个函数，无论是【对象的方法】还是【普通函数】赋值给一个变量的时候，实际上我们是把当前函数的引用（也就是函数存放的地址）赋值给这个变量。\n而当我们真正调用的时候，才会绑定 `this` ，此时对于这个函数变量来说，就是以独立的形式被调用了，所以此时 `this` 为默认绑定。\n\n这种隐式丢失的情况有2种：\n1. 直接把对象方法赋值给一个变量\n2. 把一个对象方法作为参数传给另一个函数，这里因为存在给参数变量隐式赋值的步骤，所以也会丢失\n\n```jsx\nconst obj = {\n\tname: 'kira',\n\tfoo(){\n\t\tconsole.log('name is: ',this.name);\n\t}\n}\nvar name = 'window';\nvar windowFoo = obj.foo;  // 隐式丢失：情况1\n\nfunction showFoo(fn){\n\tfn();  // 隐式丢失：情况2\n}\n\nobj.foo();\nwindowFoo();\nshowFoo(obj.foo);\nsetTimeout(obj.foo, 1000) // 隐式丢失： 情况2\n\n// name is:  kira\n// name is:  window\n// name is:  window\n// name is:  window\n```\n\n## 显示绑定\n\n显示绑定是指给函数直接指定上下文参数（`context`）。显示绑定有4种方式：\n\n- `call`\n- `apply`\n- `bind` ：关于`bind`绑定，要注意以下2点：\n    - 使用`bind`绑定过的函数，只有使用`new`方法调用才可以更改函数的`this`值\n- `js`内置函数中的参数传递：例如数组原型方法中的可选参数`context`，会把**回调函数** [ 非箭头函数 ] 的`this`指向传入的`context`\n  \n    \n\n- 这4种方式中，关于指定的`context` 的类型，`this`的指向：\n    - `undefined`  `null` : 指向全局对象\n    - `string` `number` `bool` ：指向当前值类型的原型实例\n    - `function`：指向函数本身\n    - 引用类型 `object` `array`：指向引用对象\n\n```jsx\n// js中内置函数参数传递\nlet arr = ['context'];\narr.forEach(function(){console.log('this', this)}, {name: '非箭头函数'});\narr.forEach(() => {console.log('this', this)}, {name: '箭头函数'});\n```\n\n![显示绑定：数组传入上下文](1.png)\n\n```jsx\n// 传入各种类型的context\n// call, apply, bind, 内置函数中的参数传递同理\nfunction getContext(){\n    console.log('当前函数的上下文对象 this是：', this);\n}\n\nfunction fnContext(){\n    console.log('fnContext函数作为上下文对象')\n}\n\nlet arr = ['array', 'context'];\nlet obj = {\n    name: 'objContext'\n}\n\ngetContext.call(undefined) // window\ngetContext.call(null) // window\ngetContext.call('string') // String\ngetContext.call(123) // Number\ngetContext.call(true) // Boolean\ngetContext.call(fnContext) // fnContext\ngetContext.call(arr) // arr\ngetContext.call(obj) // obj\n```\n控制台打印结果：\n![传入各种类型的上下文](2.png)\n\n## new绑定\n\n`new` 操作符的步骤\n![new操作步骤](3.png)\n\n注意，使用`new`创建对象时，如果构造函数返回的是引用类型，则`new`操作生成的对象会被这个引用类型取代。\n\n```jsx\n  function Foo(value){\n      this.name = 'foo';\n      this.value = value;\n      return value;\n  }\n\n  let obj = {type: 'object'};\n  let arr = [];\n  let fn = function(){console.log('this is a function')}\n  console.log(new Foo());\n  console.log(new Foo(null));\n  console.log(new Foo(undefined));\n  console.log(new Foo(1));\n  console.log(new Foo(true));\n  console.log(new Foo('string'));\n  console.log(new Foo(obj), obj);\n  console.log(new Foo(arr), arr);\n  console.log(new Foo(fn), fn);\n```\n\n![new创建对象，构造函数返回不同类型时的结果](7.png)\n\n# 箭头函数\n## 箭头函数`this`对象\n箭头函数没有`this`对象，或者说箭头函数的`this`对象早在词法分析时就已经被“绑定”为上层词法作用域（也就是函数声明时所在的作用域）的`this`了。\n\n例如下面这个例子：\n1. 当`outer`调用时，`this`对象被绑定为`obj`；\n2. 因为箭头函数是在`outer`方法中声明的，所以此时返回的箭头函数的`this`被“绑定”为`outer`实际执行时的`this`对象。所以无论该箭头函数在何处被调用，都不会发生改变。\n3. 而如果返回的是普通函数，那么该函数的`this`对象就会根据调用方式而发生变化。\n```jsx\n  function outer() {\n      let arrowFn = () => {\n          console.log('当前在global环境下调用箭头函数，this：', this)\n      }\n      let fn = function () {\n          console.log('当前在global环境下调用普通函数，this：', this)\n      }\n      return [arrowFn, fn];\n  }\n\n  let obj = { name: 'obj' };\n  let obj1 = {name: 'obj1'};\n  // 将outer的this绑定为obj\n  let [arrowFn, fn] = outer.call(obj);\n  arrowFn();\n  fn();\n\n  //绑定this\n  arrowFn.call(obj1);\n  fn.call(obj1);\n```\n控制台打印\n\n![箭头函数与普通函数的this值对比](8.png)\n\n\n## 箭头函数与普通函数的区别\n（1）箭头函数的 `this` 值等于**箭头函数**在**声明**时所在的**上层函数**在**调用**时所绑定的`this`值。示例如上。\n\n（2）箭头函数没有自己的 `this` `prototype` `arguments` `super` 和 `new.target`\n```jsx\n// 箭头函数和普通函数\nlet arrowFn = (arg1) => {};\nfunction fn(arg1){};\nconsole.dir(arrowFn)\nconsole.dir(fn)\n```\n控制台打印：\n\n![箭头函数没有this等属性](4.png)\n\n\n（3）箭头函数的不能用作构造函数\n\n![new一个箭头函数会报错](5.png)\n\n\n\n# 总结\n1. 对 `this` 对象的理解\nthis 是一个引用，指向当前函数的调用对象。对于非箭头函数来说，\n   1. 当独立调用函数时，`this`指向全局对象；\n   2. 当函数作为对象的方法调用时，`this`指向这个当前对象；\n   3. 当函数以`call`，`apply`，`bind`调用，或者对于一些内置的函数例如数组的`forEach`，`map`方法，传入指定的上下文对象时，`this`指向绑定的上下文对象。其中根据传入的上下文对象类型，`this`会指向不同的对象：\n      1. 如果传入是`null`或者`undefined`，则this指向全局对象；\n      2. 如果传入的是`number`, `string`, `boolean`值，js会将当前值实例化，并将`this`指向其实例。（根据当前基本类型的原型对象创建实例，并将当前值作为value参数传入构造函数）；\n      3. 如果传入的是函数，则会指向函数对象本身；\n      4. 如果传入的是引用类型，则直接指向该引用对象。\n   4. 如果用`new`调用函数，则`this`会指向该函数原型的实例对象。\n\n2. 箭头函数和普通函数的区别？\n箭头函数没有自己的 `this` `arguments` `prototype` `super`和`new.target` 以及箭头函数不能作为构造函数使用\n\n3. 箭头函数的 `this` 指向哪里？\n箭头函数的this等于其函数**声明**时所在的**上级函数被调用**时的`this`\n\n4. 如果`new` 一个箭头函数，会发生什么？\n会报错，提示箭头函数没有构造函数","source":"_posts/this指针.md","raw":"---\ntitle: this指针和箭头函数\ndate: 2023-02-28 21:10:23\ncategory: [Web前端, Javascript]\nexcerpt: this是一个引用，指向当前函数执行的上下文对象。是在运行时绑定的。\ntags: <span class=\"label label-primary\">this</span> <span class=\"label label-primary\">箭头函数</span>\n---\n# 什么是`this`？\n\n`this`是一个引用，指向当前函数执行的**上下文对象**。是在运行时绑定的。\n\n>💡 执行上下文\n当 JS 引擎解析到可执行代码片段（通常是函数调用阶段）的时候，就会先做一些执行前的准备工作，这个 “准备工作”，就叫做 \"**执行上下文(execution context 简称 EC)**\" 或者也可以叫做 **执行环境**。\n执行上下文 为我们的可执行代码块提供了执行前的必要准备工作，例如变量对象的定义、作用域链的扩展、提供调用者的对象引用等信息。\n\n\n\n\n![this.png](this.png)\n\n# this的绑定规则\n\n优先级：`new` > 显示绑定 > 隐式绑定 > 默认绑定\n\n## 默认绑定\n\n当函数被**独立调用**时，默认函数的`this`指向**全局对象**，此时在浏览器运行环境中，能获取到全局对象下使用[var操作符定义的变量，但不能获取到let定义的变量](https://www.notion.so/c80e2b095b104f7f8c53c745185de9d0)。\n\n当在[严格模式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode)下时，`this`不能获取到全局对象下的变量。\n\n```jsx\n// 浏览器运行环境下\nfunction foo(){\n\tconsole.log('name is: ', this.name);\n\tconsole.log('age is: ', this.age);\n}\n\nvar name = 'kira';\nlet age = 3;\n\nfoo();\n// name is:  kira\n// age is:  undefined\n```\n\n```jsx\n// 严格模式\n\"use strict\";\nfunction foo(){\n\tconsole.log('name is: ', this.name);\n\tconsole.log('age is: ', this.age);\n\n}\n\nvar name = 'kira';\nlet age = 3;\n\nfoo();\n/* \n   Uncaught TypeError: Cannot read property 'name' of undefined at foo \n*/\n```\n\n## 隐式绑定\n\n使用**对象调用**时，函数的`this`会指向当前调用的对象。\n\n`this` 指向链式调用的最后一层\n\n```jsx\nfunction foo(){\n\tconsole.log('name is: ', this.name);\n\tconsole.log('age is: ', this.age);\n\n}\n\nconst person = {\n\tname: 'kira',\n\tage: 3,\n\tfoo: foo\n}\n\nperson.foo();\n// name is:  kira\n// age is:  3\n```\n\n**还需要注意的是隐式绑定丢失：**\n\n当把对象 `o` 的方法 `o.method` 赋值给一个变量 `fn`，然后再调用这个变量 `fn` 的时候，`this` 不会指向这个对象 `o`，而会指向全局对象。\n这是因为，赋值语句是静态执行，而 `this` 绑定是动态绑定。\n当我们把一个函数，无论是【对象的方法】还是【普通函数】赋值给一个变量的时候，实际上我们是把当前函数的引用（也就是函数存放的地址）赋值给这个变量。\n而当我们真正调用的时候，才会绑定 `this` ，此时对于这个函数变量来说，就是以独立的形式被调用了，所以此时 `this` 为默认绑定。\n\n这种隐式丢失的情况有2种：\n1. 直接把对象方法赋值给一个变量\n2. 把一个对象方法作为参数传给另一个函数，这里因为存在给参数变量隐式赋值的步骤，所以也会丢失\n\n```jsx\nconst obj = {\n\tname: 'kira',\n\tfoo(){\n\t\tconsole.log('name is: ',this.name);\n\t}\n}\nvar name = 'window';\nvar windowFoo = obj.foo;  // 隐式丢失：情况1\n\nfunction showFoo(fn){\n\tfn();  // 隐式丢失：情况2\n}\n\nobj.foo();\nwindowFoo();\nshowFoo(obj.foo);\nsetTimeout(obj.foo, 1000) // 隐式丢失： 情况2\n\n// name is:  kira\n// name is:  window\n// name is:  window\n// name is:  window\n```\n\n## 显示绑定\n\n显示绑定是指给函数直接指定上下文参数（`context`）。显示绑定有4种方式：\n\n- `call`\n- `apply`\n- `bind` ：关于`bind`绑定，要注意以下2点：\n    - 使用`bind`绑定过的函数，只有使用`new`方法调用才可以更改函数的`this`值\n- `js`内置函数中的参数传递：例如数组原型方法中的可选参数`context`，会把**回调函数** [ 非箭头函数 ] 的`this`指向传入的`context`\n  \n    \n\n- 这4种方式中，关于指定的`context` 的类型，`this`的指向：\n    - `undefined`  `null` : 指向全局对象\n    - `string` `number` `bool` ：指向当前值类型的原型实例\n    - `function`：指向函数本身\n    - 引用类型 `object` `array`：指向引用对象\n\n```jsx\n// js中内置函数参数传递\nlet arr = ['context'];\narr.forEach(function(){console.log('this', this)}, {name: '非箭头函数'});\narr.forEach(() => {console.log('this', this)}, {name: '箭头函数'});\n```\n\n![显示绑定：数组传入上下文](1.png)\n\n```jsx\n// 传入各种类型的context\n// call, apply, bind, 内置函数中的参数传递同理\nfunction getContext(){\n    console.log('当前函数的上下文对象 this是：', this);\n}\n\nfunction fnContext(){\n    console.log('fnContext函数作为上下文对象')\n}\n\nlet arr = ['array', 'context'];\nlet obj = {\n    name: 'objContext'\n}\n\ngetContext.call(undefined) // window\ngetContext.call(null) // window\ngetContext.call('string') // String\ngetContext.call(123) // Number\ngetContext.call(true) // Boolean\ngetContext.call(fnContext) // fnContext\ngetContext.call(arr) // arr\ngetContext.call(obj) // obj\n```\n控制台打印结果：\n![传入各种类型的上下文](2.png)\n\n## new绑定\n\n`new` 操作符的步骤\n![new操作步骤](3.png)\n\n注意，使用`new`创建对象时，如果构造函数返回的是引用类型，则`new`操作生成的对象会被这个引用类型取代。\n\n```jsx\n  function Foo(value){\n      this.name = 'foo';\n      this.value = value;\n      return value;\n  }\n\n  let obj = {type: 'object'};\n  let arr = [];\n  let fn = function(){console.log('this is a function')}\n  console.log(new Foo());\n  console.log(new Foo(null));\n  console.log(new Foo(undefined));\n  console.log(new Foo(1));\n  console.log(new Foo(true));\n  console.log(new Foo('string'));\n  console.log(new Foo(obj), obj);\n  console.log(new Foo(arr), arr);\n  console.log(new Foo(fn), fn);\n```\n\n![new创建对象，构造函数返回不同类型时的结果](7.png)\n\n# 箭头函数\n## 箭头函数`this`对象\n箭头函数没有`this`对象，或者说箭头函数的`this`对象早在词法分析时就已经被“绑定”为上层词法作用域（也就是函数声明时所在的作用域）的`this`了。\n\n例如下面这个例子：\n1. 当`outer`调用时，`this`对象被绑定为`obj`；\n2. 因为箭头函数是在`outer`方法中声明的，所以此时返回的箭头函数的`this`被“绑定”为`outer`实际执行时的`this`对象。所以无论该箭头函数在何处被调用，都不会发生改变。\n3. 而如果返回的是普通函数，那么该函数的`this`对象就会根据调用方式而发生变化。\n```jsx\n  function outer() {\n      let arrowFn = () => {\n          console.log('当前在global环境下调用箭头函数，this：', this)\n      }\n      let fn = function () {\n          console.log('当前在global环境下调用普通函数，this：', this)\n      }\n      return [arrowFn, fn];\n  }\n\n  let obj = { name: 'obj' };\n  let obj1 = {name: 'obj1'};\n  // 将outer的this绑定为obj\n  let [arrowFn, fn] = outer.call(obj);\n  arrowFn();\n  fn();\n\n  //绑定this\n  arrowFn.call(obj1);\n  fn.call(obj1);\n```\n控制台打印\n\n![箭头函数与普通函数的this值对比](8.png)\n\n\n## 箭头函数与普通函数的区别\n（1）箭头函数的 `this` 值等于**箭头函数**在**声明**时所在的**上层函数**在**调用**时所绑定的`this`值。示例如上。\n\n（2）箭头函数没有自己的 `this` `prototype` `arguments` `super` 和 `new.target`\n```jsx\n// 箭头函数和普通函数\nlet arrowFn = (arg1) => {};\nfunction fn(arg1){};\nconsole.dir(arrowFn)\nconsole.dir(fn)\n```\n控制台打印：\n\n![箭头函数没有this等属性](4.png)\n\n\n（3）箭头函数的不能用作构造函数\n\n![new一个箭头函数会报错](5.png)\n\n\n\n# 总结\n1. 对 `this` 对象的理解\nthis 是一个引用，指向当前函数的调用对象。对于非箭头函数来说，\n   1. 当独立调用函数时，`this`指向全局对象；\n   2. 当函数作为对象的方法调用时，`this`指向这个当前对象；\n   3. 当函数以`call`，`apply`，`bind`调用，或者对于一些内置的函数例如数组的`forEach`，`map`方法，传入指定的上下文对象时，`this`指向绑定的上下文对象。其中根据传入的上下文对象类型，`this`会指向不同的对象：\n      1. 如果传入是`null`或者`undefined`，则this指向全局对象；\n      2. 如果传入的是`number`, `string`, `boolean`值，js会将当前值实例化，并将`this`指向其实例。（根据当前基本类型的原型对象创建实例，并将当前值作为value参数传入构造函数）；\n      3. 如果传入的是函数，则会指向函数对象本身；\n      4. 如果传入的是引用类型，则直接指向该引用对象。\n   4. 如果用`new`调用函数，则`this`会指向该函数原型的实例对象。\n\n2. 箭头函数和普通函数的区别？\n箭头函数没有自己的 `this` `arguments` `prototype` `super`和`new.target` 以及箭头函数不能作为构造函数使用\n\n3. 箭头函数的 `this` 指向哪里？\n箭头函数的this等于其函数**声明**时所在的**上级函数被调用**时的`this`\n\n4. 如果`new` 一个箭头函数，会发生什么？\n会报错，提示箭头函数没有构造函数","slug":"this指针","published":1,"updated":"2023-02-28T14:11:06.990Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clesk19gg0006dddf8ug88ob6","content":"<h1 id=\"什么是this？\"><a href=\"#什么是this？\" class=\"headerlink\" title=\"什么是this？\"></a>什么是<code>this</code>？</h1><p><code>this</code>是一个引用，指向当前函数执行的<strong>上下文对象</strong>。是在运行时绑定的。</p>\n<blockquote>\n<p>💡 执行上下文<br>当 JS 引擎解析到可执行代码片段（通常是函数调用阶段）的时候，就会先做一些执行前的准备工作，这个 “准备工作”，就叫做 “<strong>执行上下文(execution context 简称 EC)</strong>“ 或者也可以叫做 <strong>执行环境</strong>。<br>执行上下文 为我们的可执行代码块提供了执行前的必要准备工作，例如变量对象的定义、作用域链的扩展、提供调用者的对象引用等信息。</p>\n</blockquote>\n<p><img src=\"this.png\" alt=\"this.png\"></p>\n<h1 id=\"this的绑定规则\"><a href=\"#this的绑定规则\" class=\"headerlink\" title=\"this的绑定规则\"></a>this的绑定规则</h1><p>优先级：<code>new</code> &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定</p>\n<h2 id=\"默认绑定\"><a href=\"#默认绑定\" class=\"headerlink\" title=\"默认绑定\"></a>默认绑定</h2><p>当函数被<strong>独立调用</strong>时，默认函数的<code>this</code>指向<strong>全局对象</strong>，此时在浏览器运行环境中，能获取到全局对象下使用<a href=\"https://www.notion.so/c80e2b095b104f7f8c53c745185de9d0\">var操作符定义的变量，但不能获取到let定义的变量</a>。</p>\n<p>当在<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode\">严格模式</a>下时，<code>this</code>不能获取到全局对象下的变量。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// 浏览器运行环境下</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>)&#123;<br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;name is: &#x27;</span>, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>);<br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;age is: &#x27;</span>, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">age</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">&#x27;kira&#x27;</span>;<br><span class=\"hljs-keyword\">let</span> age = <span class=\"hljs-number\">3</span>;<br><br><span class=\"hljs-title function_\">foo</span>();<br><span class=\"hljs-comment\">// name is:  kira</span><br><span class=\"hljs-comment\">// age is:  undefined</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// 严格模式</span><br><span class=\"hljs-meta\">&quot;use strict&quot;</span>;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>)&#123;<br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;name is: &#x27;</span>, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>);<br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;age is: &#x27;</span>, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">age</span>);<br><br>&#125;<br><br><span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">&#x27;kira&#x27;</span>;<br><span class=\"hljs-keyword\">let</span> age = <span class=\"hljs-number\">3</span>;<br><br><span class=\"hljs-title function_\">foo</span>();<br><span class=\"hljs-comment\">/* </span><br><span class=\"hljs-comment\">   Uncaught TypeError: Cannot read property &#x27;name&#x27; of undefined at foo </span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"隐式绑定\"><a href=\"#隐式绑定\" class=\"headerlink\" title=\"隐式绑定\"></a>隐式绑定</h2><p>使用<strong>对象调用</strong>时，函数的<code>this</code>会指向当前调用的对象。</p>\n<p><code>this</code> 指向链式调用的最后一层</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>)&#123;<br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;name is: &#x27;</span>, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>);<br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;age is: &#x27;</span>, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">age</span>);<br><br>&#125;<br><br><span class=\"hljs-keyword\">const</span> person = &#123;<br>\t<span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;kira&#x27;</span>,<br>\t<span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">3</span>,<br>\t<span class=\"hljs-attr\">foo</span>: foo<br>&#125;<br><br>person.<span class=\"hljs-title function_\">foo</span>();<br><span class=\"hljs-comment\">// name is:  kira</span><br><span class=\"hljs-comment\">// age is:  3</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>还需要注意的是隐式绑定丢失：</strong></p>\n<p>当把对象 <code>o</code> 的方法 <code>o.method</code> 赋值给一个变量 <code>fn</code>，然后再调用这个变量 <code>fn</code> 的时候，<code>this</code> 不会指向这个对象 <code>o</code>，而会指向全局对象。<br>这是因为，赋值语句是静态执行，而 <code>this</code> 绑定是动态绑定。<br>当我们把一个函数，无论是【对象的方法】还是【普通函数】赋值给一个变量的时候，实际上我们是把当前函数的引用（也就是函数存放的地址）赋值给这个变量。<br>而当我们真正调用的时候，才会绑定 <code>this</code> ，此时对于这个函数变量来说，就是以独立的形式被调用了，所以此时 <code>this</code> 为默认绑定。</p>\n<p>这种隐式丢失的情况有2种：</p>\n<ol>\n<li>直接把对象方法赋值给一个变量</li>\n<li>把一个对象方法作为参数传给另一个函数，这里因为存在给参数变量隐式赋值的步骤，所以也会丢失</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> obj = &#123;<br>\t<span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;kira&#x27;</span>,<br>\t<span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>)&#123;<br>\t\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;name is: &#x27;</span>,<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>);<br>\t&#125;<br>&#125;<br><span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">&#x27;window&#x27;</span>;<br><span class=\"hljs-keyword\">var</span> windowFoo = obj.<span class=\"hljs-property\">foo</span>;  <span class=\"hljs-comment\">// 隐式丢失：情况1</span><br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">showFoo</span>(<span class=\"hljs-params\">fn</span>)&#123;<br>\t<span class=\"hljs-title function_\">fn</span>();  <span class=\"hljs-comment\">// 隐式丢失：情况2</span><br>&#125;<br><br>obj.<span class=\"hljs-title function_\">foo</span>();<br><span class=\"hljs-title function_\">windowFoo</span>();<br><span class=\"hljs-title function_\">showFoo</span>(obj.<span class=\"hljs-property\">foo</span>);<br><span class=\"hljs-built_in\">setTimeout</span>(obj.<span class=\"hljs-property\">foo</span>, <span class=\"hljs-number\">1000</span>) <span class=\"hljs-comment\">// 隐式丢失： 情况2</span><br><br><span class=\"hljs-comment\">// name is:  kira</span><br><span class=\"hljs-comment\">// name is:  window</span><br><span class=\"hljs-comment\">// name is:  window</span><br><span class=\"hljs-comment\">// name is:  window</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"显示绑定\"><a href=\"#显示绑定\" class=\"headerlink\" title=\"显示绑定\"></a>显示绑定</h2><p>显示绑定是指给函数直接指定上下文参数（<code>context</code>）。显示绑定有4种方式：</p>\n<ul>\n<li><p><code>call</code></p>\n</li>\n<li><p><code>apply</code></p>\n</li>\n<li><p><code>bind</code> ：关于<code>bind</code>绑定，要注意以下2点：</p>\n<ul>\n<li>使用<code>bind</code>绑定过的函数，只有使用<code>new</code>方法调用才可以更改函数的<code>this</code>值</li>\n</ul>\n</li>\n<li><p><code>js</code>内置函数中的参数传递：例如数组原型方法中的可选参数<code>context</code>，会把<strong>回调函数</strong> [ 非箭头函数 ] 的<code>this</code>指向传入的<code>context</code></p>\n</li>\n<li><p>这4种方式中，关于指定的<code>context</code> 的类型，<code>this</code>的指向：</p>\n<ul>\n<li><code>undefined</code>  <code>null</code> : 指向全局对象</li>\n<li><code>string</code> <code>number</code> <code>bool</code> ：指向当前值类型的原型实例</li>\n<li><code>function</code>：指向函数本身</li>\n<li>引用类型 <code>object</code> <code>array</code>：指向引用对象</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// js中内置函数参数传递</span><br><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-string\">&#x27;context&#x27;</span>];<br>arr.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;this&#x27;</span>, <span class=\"hljs-variable language_\">this</span>)&#125;, &#123;<span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;非箭头函数&#x27;</span>&#125;);<br>arr.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;this&#x27;</span>, <span class=\"hljs-variable language_\">this</span>)&#125;, &#123;<span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;箭头函数&#x27;</span>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"1.png\" alt=\"显示绑定：数组传入上下文\"></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// 传入各种类型的context</span><br><span class=\"hljs-comment\">// call, apply, bind, 内置函数中的参数传递同理</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-params\"></span>)&#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;当前函数的上下文对象 this是：&#x27;</span>, <span class=\"hljs-variable language_\">this</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fnContext</span>(<span class=\"hljs-params\"></span>)&#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;fnContext函数作为上下文对象&#x27;</span>)<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-string\">&#x27;array&#x27;</span>, <span class=\"hljs-string\">&#x27;context&#x27;</span>];<br><span class=\"hljs-keyword\">let</span> obj = &#123;<br>    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;objContext&#x27;</span><br>&#125;<br><br>getContext.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-literal\">undefined</span>) <span class=\"hljs-comment\">// window</span><br>getContext.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-literal\">null</span>) <span class=\"hljs-comment\">// window</span><br>getContext.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-string\">&#x27;string&#x27;</span>) <span class=\"hljs-comment\">// String</span><br>getContext.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-number\">123</span>) <span class=\"hljs-comment\">// Number</span><br>getContext.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-literal\">true</span>) <span class=\"hljs-comment\">// Boolean</span><br>getContext.<span class=\"hljs-title function_\">call</span>(fnContext) <span class=\"hljs-comment\">// fnContext</span><br>getContext.<span class=\"hljs-title function_\">call</span>(arr) <span class=\"hljs-comment\">// arr</span><br>getContext.<span class=\"hljs-title function_\">call</span>(obj) <span class=\"hljs-comment\">// obj</span><br></code></pre></td></tr></table></figure>\n<p>控制台打印结果：<br><img src=\"2.png\" alt=\"传入各种类型的上下文\"></p>\n<h2 id=\"new绑定\"><a href=\"#new绑定\" class=\"headerlink\" title=\"new绑定\"></a>new绑定</h2><p><code>new</code> 操作符的步骤<br><img src=\"3.png\" alt=\"new操作步骤\"></p>\n<p>注意，使用<code>new</code>创建对象时，如果构造函数返回的是引用类型，则<code>new</code>操作生成的对象会被这个引用类型取代。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Foo</span>(<span class=\"hljs-params\">value</span>)&#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = <span class=\"hljs-string\">&#x27;foo&#x27;</span>;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span> = value;<br>    <span class=\"hljs-keyword\">return</span> value;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> obj = &#123;<span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;object&#x27;</span>&#125;;<br><span class=\"hljs-keyword\">let</span> arr = [];<br><span class=\"hljs-keyword\">let</span> fn = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;this is a function&#x27;</span>)&#125;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Foo</span>());<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Foo</span>(<span class=\"hljs-literal\">null</span>));<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Foo</span>(<span class=\"hljs-literal\">undefined</span>));<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Foo</span>(<span class=\"hljs-number\">1</span>));<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Foo</span>(<span class=\"hljs-literal\">true</span>));<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Foo</span>(<span class=\"hljs-string\">&#x27;string&#x27;</span>));<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Foo</span>(obj), obj);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Foo</span>(arr), arr);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Foo</span>(fn), fn);<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"7.png\" alt=\"new创建对象，构造函数返回不同类型时的结果\"></p>\n<h1 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h1><h2 id=\"箭头函数this对象\"><a href=\"#箭头函数this对象\" class=\"headerlink\" title=\"箭头函数this对象\"></a>箭头函数<code>this</code>对象</h2><p>箭头函数没有<code>this</code>对象，或者说箭头函数的<code>this</code>对象早在词法分析时就已经被“绑定”为上层词法作用域（也就是函数声明时所在的作用域）的<code>this</code>了。</p>\n<p>例如下面这个例子：</p>\n<ol>\n<li>当<code>outer</code>调用时，<code>this</code>对象被绑定为<code>obj</code>；</li>\n<li>因为箭头函数是在<code>outer</code>方法中声明的，所以此时返回的箭头函数的<code>this</code>被“绑定”为<code>outer</code>实际执行时的<code>this</code>对象。所以无论该箭头函数在何处被调用，都不会发生改变。</li>\n<li>而如果返回的是普通函数，那么该函数的<code>this</code>对象就会根据调用方式而发生变化。<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">outer</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-title function_\">arrowFn</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;当前在global环境下调用箭头函数，this：&#x27;</span>, <span class=\"hljs-variable language_\">this</span>)<br>    &#125;<br>    <span class=\"hljs-keyword\">let</span> fn = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;当前在global环境下调用普通函数，this：&#x27;</span>, <span class=\"hljs-variable language_\">this</span>)<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> [arrowFn, fn];<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> obj = &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;obj&#x27;</span> &#125;;<br><span class=\"hljs-keyword\">let</span> obj1 = &#123;<span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;obj1&#x27;</span>&#125;;<br><span class=\"hljs-comment\">// 将outer的this绑定为obj</span><br><span class=\"hljs-keyword\">let</span> [arrowFn, fn] = outer.<span class=\"hljs-title function_\">call</span>(obj);<br><span class=\"hljs-title function_\">arrowFn</span>();<br><span class=\"hljs-title function_\">fn</span>();<br><br><span class=\"hljs-comment\">//绑定this</span><br>arrowFn.<span class=\"hljs-title function_\">call</span>(obj1);<br>fn.<span class=\"hljs-title function_\">call</span>(obj1);<br></code></pre></td></tr></table></figure>\n控制台打印</li>\n</ol>\n<p><img src=\"8.png\" alt=\"箭头函数与普通函数的this值对比\"></p>\n<h2 id=\"箭头函数与普通函数的区别\"><a href=\"#箭头函数与普通函数的区别\" class=\"headerlink\" title=\"箭头函数与普通函数的区别\"></a>箭头函数与普通函数的区别</h2><p>（1）箭头函数的 <code>this</code> 值等于<strong>箭头函数</strong>在<strong>声明</strong>时所在的<strong>上层函数</strong>在<strong>调用</strong>时所绑定的<code>this</code>值。示例如上。</p>\n<p>（2）箭头函数没有自己的 <code>this</code> <code>prototype</code> <code>arguments</code> <code>super</code> 和 <code>new.target</code></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// 箭头函数和普通函数</span><br><span class=\"hljs-keyword\">let</span> <span class=\"hljs-title function_\">arrowFn</span> = (<span class=\"hljs-params\">arg1</span>) =&gt; &#123;&#125;;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fn</span>(<span class=\"hljs-params\">arg1</span>)&#123;&#125;;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">dir</span>(arrowFn)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">dir</span>(fn)<br></code></pre></td></tr></table></figure>\n<p>控制台打印：</p>\n<p><img src=\"4.png\" alt=\"箭头函数没有this等属性\"></p>\n<p>（3）箭头函数的不能用作构造函数</p>\n<p><img src=\"5.png\" alt=\"new一个箭头函数会报错\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li><p>对 <code>this</code> 对象的理解<br>this 是一个引用，指向当前函数的调用对象。对于非箭头函数来说，</p>\n<ol>\n<li>当独立调用函数时，<code>this</code>指向全局对象；</li>\n<li>当函数作为对象的方法调用时，<code>this</code>指向这个当前对象；</li>\n<li>当函数以<code>call</code>，<code>apply</code>，<code>bind</code>调用，或者对于一些内置的函数例如数组的<code>forEach</code>，<code>map</code>方法，传入指定的上下文对象时，<code>this</code>指向绑定的上下文对象。其中根据传入的上下文对象类型，<code>this</code>会指向不同的对象：<ol>\n<li>如果传入是<code>null</code>或者<code>undefined</code>，则this指向全局对象；</li>\n<li>如果传入的是<code>number</code>, <code>string</code>, <code>boolean</code>值，js会将当前值实例化，并将<code>this</code>指向其实例。（根据当前基本类型的原型对象创建实例，并将当前值作为value参数传入构造函数）；</li>\n<li>如果传入的是函数，则会指向函数对象本身；</li>\n<li>如果传入的是引用类型，则直接指向该引用对象。</li>\n</ol>\n</li>\n<li>如果用<code>new</code>调用函数，则<code>this</code>会指向该函数原型的实例对象。</li>\n</ol>\n</li>\n<li><p>箭头函数和普通函数的区别？<br>箭头函数没有自己的 <code>this</code> <code>arguments</code> <code>prototype</code> <code>super</code>和<code>new.target</code> 以及箭头函数不能作为构造函数使用</p>\n</li>\n<li><p>箭头函数的 <code>this</code> 指向哪里？<br>箭头函数的this等于其函数<strong>声明</strong>时所在的<strong>上级函数被调用</strong>时的<code>this</code></p>\n</li>\n<li><p>如果<code>new</code> 一个箭头函数，会发生什么？<br>会报错，提示箭头函数没有构造函数</p>\n</li>\n</ol>\n","site":{"data":{"languages/zh-CN":{"name":"简体中文","home":{"menu":"首页","title":"首页"},"archive":{"menu":"归档","title":"归档","subtitle":"归档","post_total":"共计 %d 篇文章"},"category":{"menu":"分类","title":"分类","subtitle":"分类","post_total":"共计 %d 篇文章","more":"More..."},"tag":{"menu":"标签","title":"标签","subtitle":"标签","post_total":"共计 %d 篇文章"},"about":{"menu":"关于","title":"关于","subtitle":"关于"},"links":{"menu":"友链","title":"友链","subtitle":"友情链接"},"page404":{"menu":"页面不存在","title":"页面不存在","subtitle":"页面不存在"},"post":{"toc":"目录","prev_post":"上一篇","next_post":"下一篇","updated":"本文最后更新于：%s","meta":{"wordcount":"%s 字","min2read":"%s 分钟","views":"{} 次"},"copyright":{"author":"作者","posted":"发布于","updated":"更新于","licensed":"许可协议","CC":"CC - 知识共享许可协议","BY":"BY - 署名","SA":"SA - 相同方式共享","NC":"NC - 非商业性使用","ND":"ND - 禁止演绎"}},"footer":{"pv":"总访问量 {} 次","uv":"总访客数 {} 人"},"search":{"title":"搜索","keyword":"关键词"},"noscript_warning":"博客在允许 JavaScript 运行的环境下浏览效果更佳"}}},"more":"<h1 id=\"什么是this？\"><a href=\"#什么是this？\" class=\"headerlink\" title=\"什么是this？\"></a>什么是<code>this</code>？</h1><p><code>this</code>是一个引用，指向当前函数执行的<strong>上下文对象</strong>。是在运行时绑定的。</p>\n<blockquote>\n<p>💡 执行上下文<br>当 JS 引擎解析到可执行代码片段（通常是函数调用阶段）的时候，就会先做一些执行前的准备工作，这个 “准备工作”，就叫做 “<strong>执行上下文(execution context 简称 EC)</strong>“ 或者也可以叫做 <strong>执行环境</strong>。<br>执行上下文 为我们的可执行代码块提供了执行前的必要准备工作，例如变量对象的定义、作用域链的扩展、提供调用者的对象引用等信息。</p>\n</blockquote>\n<p><img src=\"this.png\" alt=\"this.png\"></p>\n<h1 id=\"this的绑定规则\"><a href=\"#this的绑定规则\" class=\"headerlink\" title=\"this的绑定规则\"></a>this的绑定规则</h1><p>优先级：<code>new</code> &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定</p>\n<h2 id=\"默认绑定\"><a href=\"#默认绑定\" class=\"headerlink\" title=\"默认绑定\"></a>默认绑定</h2><p>当函数被<strong>独立调用</strong>时，默认函数的<code>this</code>指向<strong>全局对象</strong>，此时在浏览器运行环境中，能获取到全局对象下使用<a href=\"https://www.notion.so/c80e2b095b104f7f8c53c745185de9d0\">var操作符定义的变量，但不能获取到let定义的变量</a>。</p>\n<p>当在<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode\">严格模式</a>下时，<code>this</code>不能获取到全局对象下的变量。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// 浏览器运行环境下</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>)&#123;<br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;name is: &#x27;</span>, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>);<br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;age is: &#x27;</span>, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">age</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">&#x27;kira&#x27;</span>;<br><span class=\"hljs-keyword\">let</span> age = <span class=\"hljs-number\">3</span>;<br><br><span class=\"hljs-title function_\">foo</span>();<br><span class=\"hljs-comment\">// name is:  kira</span><br><span class=\"hljs-comment\">// age is:  undefined</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// 严格模式</span><br><span class=\"hljs-meta\">&quot;use strict&quot;</span>;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>)&#123;<br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;name is: &#x27;</span>, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>);<br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;age is: &#x27;</span>, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">age</span>);<br><br>&#125;<br><br><span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">&#x27;kira&#x27;</span>;<br><span class=\"hljs-keyword\">let</span> age = <span class=\"hljs-number\">3</span>;<br><br><span class=\"hljs-title function_\">foo</span>();<br><span class=\"hljs-comment\">/* </span><br><span class=\"hljs-comment\">   Uncaught TypeError: Cannot read property &#x27;name&#x27; of undefined at foo </span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"隐式绑定\"><a href=\"#隐式绑定\" class=\"headerlink\" title=\"隐式绑定\"></a>隐式绑定</h2><p>使用<strong>对象调用</strong>时，函数的<code>this</code>会指向当前调用的对象。</p>\n<p><code>this</code> 指向链式调用的最后一层</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>)&#123;<br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;name is: &#x27;</span>, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>);<br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;age is: &#x27;</span>, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">age</span>);<br><br>&#125;<br><br><span class=\"hljs-keyword\">const</span> person = &#123;<br>\t<span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;kira&#x27;</span>,<br>\t<span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">3</span>,<br>\t<span class=\"hljs-attr\">foo</span>: foo<br>&#125;<br><br>person.<span class=\"hljs-title function_\">foo</span>();<br><span class=\"hljs-comment\">// name is:  kira</span><br><span class=\"hljs-comment\">// age is:  3</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>还需要注意的是隐式绑定丢失：</strong></p>\n<p>当把对象 <code>o</code> 的方法 <code>o.method</code> 赋值给一个变量 <code>fn</code>，然后再调用这个变量 <code>fn</code> 的时候，<code>this</code> 不会指向这个对象 <code>o</code>，而会指向全局对象。<br>这是因为，赋值语句是静态执行，而 <code>this</code> 绑定是动态绑定。<br>当我们把一个函数，无论是【对象的方法】还是【普通函数】赋值给一个变量的时候，实际上我们是把当前函数的引用（也就是函数存放的地址）赋值给这个变量。<br>而当我们真正调用的时候，才会绑定 <code>this</code> ，此时对于这个函数变量来说，就是以独立的形式被调用了，所以此时 <code>this</code> 为默认绑定。</p>\n<p>这种隐式丢失的情况有2种：</p>\n<ol>\n<li>直接把对象方法赋值给一个变量</li>\n<li>把一个对象方法作为参数传给另一个函数，这里因为存在给参数变量隐式赋值的步骤，所以也会丢失</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> obj = &#123;<br>\t<span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;kira&#x27;</span>,<br>\t<span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>)&#123;<br>\t\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;name is: &#x27;</span>,<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>);<br>\t&#125;<br>&#125;<br><span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">&#x27;window&#x27;</span>;<br><span class=\"hljs-keyword\">var</span> windowFoo = obj.<span class=\"hljs-property\">foo</span>;  <span class=\"hljs-comment\">// 隐式丢失：情况1</span><br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">showFoo</span>(<span class=\"hljs-params\">fn</span>)&#123;<br>\t<span class=\"hljs-title function_\">fn</span>();  <span class=\"hljs-comment\">// 隐式丢失：情况2</span><br>&#125;<br><br>obj.<span class=\"hljs-title function_\">foo</span>();<br><span class=\"hljs-title function_\">windowFoo</span>();<br><span class=\"hljs-title function_\">showFoo</span>(obj.<span class=\"hljs-property\">foo</span>);<br><span class=\"hljs-built_in\">setTimeout</span>(obj.<span class=\"hljs-property\">foo</span>, <span class=\"hljs-number\">1000</span>) <span class=\"hljs-comment\">// 隐式丢失： 情况2</span><br><br><span class=\"hljs-comment\">// name is:  kira</span><br><span class=\"hljs-comment\">// name is:  window</span><br><span class=\"hljs-comment\">// name is:  window</span><br><span class=\"hljs-comment\">// name is:  window</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"显示绑定\"><a href=\"#显示绑定\" class=\"headerlink\" title=\"显示绑定\"></a>显示绑定</h2><p>显示绑定是指给函数直接指定上下文参数（<code>context</code>）。显示绑定有4种方式：</p>\n<ul>\n<li><p><code>call</code></p>\n</li>\n<li><p><code>apply</code></p>\n</li>\n<li><p><code>bind</code> ：关于<code>bind</code>绑定，要注意以下2点：</p>\n<ul>\n<li>使用<code>bind</code>绑定过的函数，只有使用<code>new</code>方法调用才可以更改函数的<code>this</code>值</li>\n</ul>\n</li>\n<li><p><code>js</code>内置函数中的参数传递：例如数组原型方法中的可选参数<code>context</code>，会把<strong>回调函数</strong> [ 非箭头函数 ] 的<code>this</code>指向传入的<code>context</code></p>\n</li>\n<li><p>这4种方式中，关于指定的<code>context</code> 的类型，<code>this</code>的指向：</p>\n<ul>\n<li><code>undefined</code>  <code>null</code> : 指向全局对象</li>\n<li><code>string</code> <code>number</code> <code>bool</code> ：指向当前值类型的原型实例</li>\n<li><code>function</code>：指向函数本身</li>\n<li>引用类型 <code>object</code> <code>array</code>：指向引用对象</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// js中内置函数参数传递</span><br><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-string\">&#x27;context&#x27;</span>];<br>arr.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;this&#x27;</span>, <span class=\"hljs-variable language_\">this</span>)&#125;, &#123;<span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;非箭头函数&#x27;</span>&#125;);<br>arr.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;this&#x27;</span>, <span class=\"hljs-variable language_\">this</span>)&#125;, &#123;<span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;箭头函数&#x27;</span>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"1.png\" alt=\"显示绑定：数组传入上下文\"></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// 传入各种类型的context</span><br><span class=\"hljs-comment\">// call, apply, bind, 内置函数中的参数传递同理</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-params\"></span>)&#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;当前函数的上下文对象 this是：&#x27;</span>, <span class=\"hljs-variable language_\">this</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fnContext</span>(<span class=\"hljs-params\"></span>)&#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;fnContext函数作为上下文对象&#x27;</span>)<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-string\">&#x27;array&#x27;</span>, <span class=\"hljs-string\">&#x27;context&#x27;</span>];<br><span class=\"hljs-keyword\">let</span> obj = &#123;<br>    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;objContext&#x27;</span><br>&#125;<br><br>getContext.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-literal\">undefined</span>) <span class=\"hljs-comment\">// window</span><br>getContext.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-literal\">null</span>) <span class=\"hljs-comment\">// window</span><br>getContext.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-string\">&#x27;string&#x27;</span>) <span class=\"hljs-comment\">// String</span><br>getContext.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-number\">123</span>) <span class=\"hljs-comment\">// Number</span><br>getContext.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-literal\">true</span>) <span class=\"hljs-comment\">// Boolean</span><br>getContext.<span class=\"hljs-title function_\">call</span>(fnContext) <span class=\"hljs-comment\">// fnContext</span><br>getContext.<span class=\"hljs-title function_\">call</span>(arr) <span class=\"hljs-comment\">// arr</span><br>getContext.<span class=\"hljs-title function_\">call</span>(obj) <span class=\"hljs-comment\">// obj</span><br></code></pre></td></tr></table></figure>\n<p>控制台打印结果：<br><img src=\"2.png\" alt=\"传入各种类型的上下文\"></p>\n<h2 id=\"new绑定\"><a href=\"#new绑定\" class=\"headerlink\" title=\"new绑定\"></a>new绑定</h2><p><code>new</code> 操作符的步骤<br><img src=\"3.png\" alt=\"new操作步骤\"></p>\n<p>注意，使用<code>new</code>创建对象时，如果构造函数返回的是引用类型，则<code>new</code>操作生成的对象会被这个引用类型取代。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Foo</span>(<span class=\"hljs-params\">value</span>)&#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = <span class=\"hljs-string\">&#x27;foo&#x27;</span>;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span> = value;<br>    <span class=\"hljs-keyword\">return</span> value;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> obj = &#123;<span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;object&#x27;</span>&#125;;<br><span class=\"hljs-keyword\">let</span> arr = [];<br><span class=\"hljs-keyword\">let</span> fn = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;this is a function&#x27;</span>)&#125;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Foo</span>());<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Foo</span>(<span class=\"hljs-literal\">null</span>));<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Foo</span>(<span class=\"hljs-literal\">undefined</span>));<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Foo</span>(<span class=\"hljs-number\">1</span>));<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Foo</span>(<span class=\"hljs-literal\">true</span>));<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Foo</span>(<span class=\"hljs-string\">&#x27;string&#x27;</span>));<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Foo</span>(obj), obj);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Foo</span>(arr), arr);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Foo</span>(fn), fn);<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"7.png\" alt=\"new创建对象，构造函数返回不同类型时的结果\"></p>\n<h1 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h1><h2 id=\"箭头函数this对象\"><a href=\"#箭头函数this对象\" class=\"headerlink\" title=\"箭头函数this对象\"></a>箭头函数<code>this</code>对象</h2><p>箭头函数没有<code>this</code>对象，或者说箭头函数的<code>this</code>对象早在词法分析时就已经被“绑定”为上层词法作用域（也就是函数声明时所在的作用域）的<code>this</code>了。</p>\n<p>例如下面这个例子：</p>\n<ol>\n<li>当<code>outer</code>调用时，<code>this</code>对象被绑定为<code>obj</code>；</li>\n<li>因为箭头函数是在<code>outer</code>方法中声明的，所以此时返回的箭头函数的<code>this</code>被“绑定”为<code>outer</code>实际执行时的<code>this</code>对象。所以无论该箭头函数在何处被调用，都不会发生改变。</li>\n<li>而如果返回的是普通函数，那么该函数的<code>this</code>对象就会根据调用方式而发生变化。<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">outer</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-title function_\">arrowFn</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;当前在global环境下调用箭头函数，this：&#x27;</span>, <span class=\"hljs-variable language_\">this</span>)<br>    &#125;<br>    <span class=\"hljs-keyword\">let</span> fn = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;当前在global环境下调用普通函数，this：&#x27;</span>, <span class=\"hljs-variable language_\">this</span>)<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> [arrowFn, fn];<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> obj = &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;obj&#x27;</span> &#125;;<br><span class=\"hljs-keyword\">let</span> obj1 = &#123;<span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;obj1&#x27;</span>&#125;;<br><span class=\"hljs-comment\">// 将outer的this绑定为obj</span><br><span class=\"hljs-keyword\">let</span> [arrowFn, fn] = outer.<span class=\"hljs-title function_\">call</span>(obj);<br><span class=\"hljs-title function_\">arrowFn</span>();<br><span class=\"hljs-title function_\">fn</span>();<br><br><span class=\"hljs-comment\">//绑定this</span><br>arrowFn.<span class=\"hljs-title function_\">call</span>(obj1);<br>fn.<span class=\"hljs-title function_\">call</span>(obj1);<br></code></pre></td></tr></table></figure>\n控制台打印</li>\n</ol>\n<p><img src=\"8.png\" alt=\"箭头函数与普通函数的this值对比\"></p>\n<h2 id=\"箭头函数与普通函数的区别\"><a href=\"#箭头函数与普通函数的区别\" class=\"headerlink\" title=\"箭头函数与普通函数的区别\"></a>箭头函数与普通函数的区别</h2><p>（1）箭头函数的 <code>this</code> 值等于<strong>箭头函数</strong>在<strong>声明</strong>时所在的<strong>上层函数</strong>在<strong>调用</strong>时所绑定的<code>this</code>值。示例如上。</p>\n<p>（2）箭头函数没有自己的 <code>this</code> <code>prototype</code> <code>arguments</code> <code>super</code> 和 <code>new.target</code></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// 箭头函数和普通函数</span><br><span class=\"hljs-keyword\">let</span> <span class=\"hljs-title function_\">arrowFn</span> = (<span class=\"hljs-params\">arg1</span>) =&gt; &#123;&#125;;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fn</span>(<span class=\"hljs-params\">arg1</span>)&#123;&#125;;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">dir</span>(arrowFn)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">dir</span>(fn)<br></code></pre></td></tr></table></figure>\n<p>控制台打印：</p>\n<p><img src=\"4.png\" alt=\"箭头函数没有this等属性\"></p>\n<p>（3）箭头函数的不能用作构造函数</p>\n<p><img src=\"5.png\" alt=\"new一个箭头函数会报错\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li><p>对 <code>this</code> 对象的理解<br>this 是一个引用，指向当前函数的调用对象。对于非箭头函数来说，</p>\n<ol>\n<li>当独立调用函数时，<code>this</code>指向全局对象；</li>\n<li>当函数作为对象的方法调用时，<code>this</code>指向这个当前对象；</li>\n<li>当函数以<code>call</code>，<code>apply</code>，<code>bind</code>调用，或者对于一些内置的函数例如数组的<code>forEach</code>，<code>map</code>方法，传入指定的上下文对象时，<code>this</code>指向绑定的上下文对象。其中根据传入的上下文对象类型，<code>this</code>会指向不同的对象：<ol>\n<li>如果传入是<code>null</code>或者<code>undefined</code>，则this指向全局对象；</li>\n<li>如果传入的是<code>number</code>, <code>string</code>, <code>boolean</code>值，js会将当前值实例化，并将<code>this</code>指向其实例。（根据当前基本类型的原型对象创建实例，并将当前值作为value参数传入构造函数）；</li>\n<li>如果传入的是函数，则会指向函数对象本身；</li>\n<li>如果传入的是引用类型，则直接指向该引用对象。</li>\n</ol>\n</li>\n<li>如果用<code>new</code>调用函数，则<code>this</code>会指向该函数原型的实例对象。</li>\n</ol>\n</li>\n<li><p>箭头函数和普通函数的区别？<br>箭头函数没有自己的 <code>this</code> <code>arguments</code> <code>prototype</code> <code>super</code>和<code>new.target</code> 以及箭头函数不能作为构造函数使用</p>\n</li>\n<li><p>箭头函数的 <code>this</code> 指向哪里？<br>箭头函数的this等于其函数<strong>声明</strong>时所在的<strong>上级函数被调用</strong>时的<code>this</code></p>\n</li>\n<li><p>如果<code>new</code> 一个箭头函数，会发生什么？<br>会报错，提示箭头函数没有构造函数</p>\n</li>\n</ol>\n"},{"title":"meetOrSlice算法","date":"2023-03-03T07:11:28.000Z","excerpt":"本文重点是实现preserveAspectRatio中<meetOrSlice>参数的效果，也是background-size中值为cover，contain属性效果。","_content":"\n# 一、前言\n\n本文重点是实现`preserveAspectRatio`中`<meetOrSlice>`参数的效果，也是`background-size`中值为`cover`，`contain`属性效果。在实现之前，简单介绍一下**SVG**中的`viewport`, `viewBox`和`preserveAspectRatio`的关系。\n\n## 画布\n\n 当我们创建SVG标签时，实际上是创建了一个**隐形的无限延伸**的画布。\n\n\n\n## 视窗（viewport）\n\n 画布是无限延伸的，但是人的视野是有限的，我们需要设置一个固定的区域，然后在这个固定的区域去绘制图形，使其可见。所以我们通过给SVG设置`width`和`height`属性（或者通过css设置宽高）设置一个可见区域，这个区域就是**viewport**，也就是视窗。这个区域是初始坐标系。\n\n 在不做任何坐标系转换 (transform) 的情况下，我们绘制一个SVG图形，实际是绘制在画布上，但是是以**viewport**的坐标系为参考坐标系绘制的。可以理解为画布是绘制实体，视窗是用来确定具体绘制的位置和尺寸的。\n\n\n## viewBox\n\n\n 什么是**viewBox**呢？\n\n 可以理解为我们手里有一个任意尺寸的方形框，即**viewBox**，这个框可以在视窗的区域内任意位置游走。我们通过设置**viewBox**的属性值，可以指定这个框的尺寸（width, height），以及具体游走在视窗的那个位置（x, y）。\n\n 在框内的画面就是我们最终看到的画面，我们将框内的区域“裁剪”出来，然后通过缩放填充整个视窗。而具体的缩放规则就要看**preserveAspectRatio**属性设置的值。\n\n\n\n\n## preserveAspectRatio\n\n 我们通过**viewBox**裁剪了一个区域，然后将这个区域缩放填充整个视窗。为了便于理解，我们将通过viewBox裁剪出来的区域称为**content**，将视窗称为**box**。\n\n 为了使**content**在缩放过程不变形，我们需要保持**content**的宽高比，如果**content**和**box**的宽高比相等，则**content**通过缩放可以刚好填满整个**box**。但是如果宽高比不相等，那应该如何填充？\n\n **preserveAspectRatio**就是为了解决这个问题而产生的。**preserveAspectRatio**中有两个参数`<align>`和`<meetOrSlice>`，一个值决定**content**按照什么规则缩放，一个值决定缩放后的**content**与**box**的对齐方式。\n\n 其中`<meetOrSlice>`属性值的效果和`background-size`中`cover`和`contain` 类似。\n\n\n\n\n关于更详细的SVG坐标系的解释，参考这两篇文章：\n\n[理解SVG坐标系统和变换： 建立新视窗](<https://www.w3cplus.com/html5/nesting-svgs.html>)\n\n[理解SVG坐标系和变换：视窗,viewBox和preserveAspectRatio](<https://www.w3cplus.com/html5/svg-coordinate-systems.html>)\n\n接下来就详细介绍一下`<meetOrSlice>`是如何控制填充效果的。\n\n\n\n# 二、meetOrSlice定义\n\n为了行文方便，仍然用**content**和**box**分别代指用于填充的矩形图和被填充的盒子。因为本文重点在于探索和实现**preserveAspectRatio**的`<meetOrSlice>`效果，在这里就不对`<align>`参数展开介绍了。\n\n\n\n`<meetOrSlice>`参数有两个值：`meet`和`slice`，其中`meet`类似于`background-size`中的`contain`，`slice`类似于`background-size`中的`cover`。\n\n在[MDN preserveAspectRatio](<https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/preserveAspectRatio>)对这两个属性值是这样描述的：\n\n\n\n> - meet (默认值)  图形将缩放到:\n>   - 宽高比将会被保留\n>   - 整个SVG的viewbox在视图范围内是可见的\n>   - 尽可能的放大SVG的viewbox，同时仍然满足其他的条件。\n>\n> 在这种情况下，如果图形的宽高比和视图窗口不匹配，则某些视图将会超出viewbox范围（即SVG的viewbox视图将会比可视窗口小）。\n>\n> - slice 图形将缩放到:\n>   - 宽高比将会被保留\n>   - 整个视图窗口将覆盖viewbox\n>   - SVG的viewbox属性将会被尽可能的缩小，但是仍然符合其他标准。\n>\n> 在这种情况下，如果SVG的viewbox宽高比与可视区域不匹配，则viewbox的某些区域将会延伸到视图窗口外部（即SVG的viewbox将会比可视窗口大）。\n\n简单概括就是两句话，在保持**content**宽高比不变的情况下：\n\n`meet / contain `：缩放，使**box**包含(contain)完整的**content**，**box**内部可能产生空白。重点：不产生“越界”现象\n\n`slice / cover`：缩放，使**content**覆盖(cover)**box**全部区域，**content**可能会超出**box**区域。重点：不产生空白区域\n\n\n\n# 三、理解meetOrSlice的填充规则\n\n 在了解了这个两个属性值的含义之后，我们再来探究这两个值的具体计算规则。**box**和**content**都是矩形，我们将矩形分为三类：正方形、竖向矩形、横向矩形：\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c1618d33f9c79~tplv-t2oaga2asx-image.image)\n**box**和**content**分别有可能是其中的任意一类，通过排列组合可以得到9种对应关系（相等，同向，异向）：\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c161e53a40906~tplv-t2oaga2asx-image.image)\n\n为了更精确的对比所有尺寸得到的结果，我们分别设置三种类型的**box**尺寸，以及三种类型的**content**尺寸，如下：\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c16219b143378~tplv-t2oaga2asx-image.image)\n\n\n在**SVG**中，设置`meet`和`slice`，得到的结果如下（SVG缩放中会影响到矩形的边框宽度，所以同样的边框宽度因为缩放比例不同会导致最终的视觉宽度不同）：\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c162390e34466~tplv-t2oaga2asx-image.image)\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c1625c3a49f49~tplv-t2oaga2asx-image.image)\n\n\n\n根据定义和实验结果，我们可以发现：\n\n- `meet`模式下，为了使 **content**最大程度的被完整包含在**box**内部，总是**content**的**长边**与**box**对应边对齐。\n\n- `slice`模式下，为了使**box**被填满，总是**content**的**短边**与**box**对应边对齐。\n\n但这两点并不能包含全部情况，我们看👇例子：\n\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c1632ee3c06e3~tplv-t2oaga2asx-image.image)\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c16354a9da897~tplv-t2oaga2asx-image.image)\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c16379452d7e0~tplv-t2oaga2asx-image.image)\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c1639f03b62ff~tplv-t2oaga2asx-image.image)\n\n\n\n从上面的4个例子中可以发现，当**box**和**content**都是同向的矩形（均为横向或者竖向）时，`meet`情况下，还需要继续判断短边的长度；而在`slice`的情况下还需要继续判断长边的长度。\n\n所以我们可以这样描述：\n\n- `meet`：总是比较两者的**长边**：\n\n  - 长边同边（同边：都是横向或者竖向矩形）：假设都为横向矩形，根据宽高比计算在**同一个宽度**下两者的高度，判断哪个的高度更高（反之同理）：\n    - 如果`contentHeight > boxHeight`（此时**box**更“扁”）：为了使**content**被完整包含在**box**里，需要让**content**的高等于**box**的高（对齐高）\n    - 如果`boxHeight > contentHeight`（此时**content**更“扁”）：使**content**的宽等于**box**的宽（对齐宽）\n\n  - 长边异边（异边：一个为横向另一个为竖向）：假设**content**为横向，长边为宽，**box**为竖向，长边为高（可以理解为content更扁一点），则使**content**的宽等于**box**的宽（对齐宽），反之同理。\n\n\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c17e213819216~tplv-t2oaga2asx-image.image)\n\n- `slice`：总是比较两者的**短边**：\n  - 短边同边（同边：同上描述）：假设都为横向矩形，根据宽高比计算在**同一个宽度**下两者的高度，判断哪个的高度更高：\n    - 如果`contentHeight > boxHeight`（此时box更“扁”） ：使**content**的宽等于**box**的宽（对齐宽）\n    - 如果`boxHeight > contentHeight`（此时content更“扁”）：使**content**的高等于**box**的高（对齐高）\n  - 短边异边（异边：同上描述）：假设**content**为横向，短边为高，**box**为竖向，短边为宽，（content更扁），使**content**的高等于**box**的高（对齐高），反之同理。\n  \n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/29/171c18c514237275~tplv-t2oaga2asx-image.image)\n\n\n现在，我们已经知道`meet`和`slice`的缩放规律，根据图，我们可以进一步归纳逻辑。在这里，根据矩形形状的特点，使用“扁”作为统一标准：同宽情况下，高度越小，越扁。\n\n在保持**content**宽高比缩放的情况下，比较**content**和**box**的“扁”度：\n\n- meet\n  - box > content  => 对齐高：**content**的宽高同时乘以一个值使**content**的高等于**box**高\n  - box < content => 对齐宽：**content**的宽高同时乘以一个值使**content**的宽等于**box**宽\n\n- slice\n  - box > content  => 对齐宽：同上\n  - box < content =>对齐高： 同上\n\n伪代码可以这样描述：\n\n```\nif(type == 'meet'){\n  if(box_扁 > content_扁){\n   content_高 * scale = box_高;\n   content_宽 * scale = new_content_宽;\n  }else{\n\tcontent_宽 * scale = box_宽;\n\tcontent_高 * scale = new_content_高;\n  }\n}else if(type == 'slice'){\n if(box_扁 > content_扁){\n\tcontent_宽 * scale = box_宽;\n\tcontent_高 * scale = new_content_高;\n  }else{\n\tcontent_高 * scale = box_高;\n   \tcontent_宽 * scale = new_content_宽;\n  }\n}\n```\n\n\n\n# 四、实现meetOrSlice方法\n\n根据伪代码的描述，为了真正实现这个算法，我们需要：\n\n- 得到一个矩形的“**扁**”度\n\n- 得到**scale**值\n\n其实上面两点非常容易获取：\n\n- 如果一个矩形越扁，意味着宽高比越大，所以可以通过宽高比 `width / height` 来获取“扁”度。\n\n- 而**scale**，在伪代码中其实已经能发现scale的计算方法（假设对齐宽）：\n\n```\ncontentW * scale = boxW;\nscale = boxW / contentW;\n\n\n所以缩放后的content宽高为：\nnewContentW = scale * contentW;\nnewContentH = scale * contentH;\n```\n\n\n\n由此，我们就可以写出`meet`和`slice`方法了：\n\n```javascript\nfunction meetOrSlice(type, boxW, boxH, contentW, contentH){\n    let boxRadio = boxW / boxH,\n        contentRadio = contentW / contentH,\n        scaleW = (boxW / contentW) || 1,\n        scaleH = (boxH / contentH) || 1,\n        scale = 1;\n    if(type == 'meet'){\n        scale = boxRadio >= contentRadio ? scaleH : scaleW;\n    }else if(type == 'slice'){\n        scale = boxRadio >= contentRadio ? scaleW : scaleH;\n    }\n    \n    return {\n        w: scale * contentW,\n        h: scale * contentH\n    }\n}\n```\n\n\n最后和SVG对比一下效果，其中关于边框的两个问题： \n\n- svg中边框宽度不一致：是因为SVG缩放中会连同边框一起缩放 \n- svg中部分 部分边框被裁切：是因为svg内部矩形的x,y定位，是以边框的中线为标准计算的，所以当坐标点为`(0,0)`时，会有一半的边框超出svg的窗口范围，导致被截断。\n\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c1656567c3728~tplv-t2oaga2asx-image.image)\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c165994da0a5e~tplv-t2oaga2asx-image.image)\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c165af0998dc9~tplv-t2oaga2asx-image.image)\n\n\n\n[点击查看源码](https://github.com/kkkkira/demo/blob/master/meetOrSlice/index.html)\n\n完结，撒花🎉。\n\n\n\n### 参考\n\n[理解SVG坐标系统和变换： 建立新视窗](<https://www.w3cplus.com/html5/nesting-svgs.html>)\n\n[理解SVG坐标系和变换：视窗,viewBox和preserveAspectRatio](<https://www.w3cplus.com/html5/svg-coordinate-systems.html>)\n\n[MDN preserveAspectRatio](<https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/preserveAspectRatio>)","source":"_posts/meetOrSlice算法.md","raw":"---\ntitle: meetOrSlice算法\ndate: 2023-03-03 15:11:28\ncategory: [Web前端, SVG]\nexcerpt: 本文重点是实现preserveAspectRatio中<meetOrSlice>参数的效果，也是background-size中值为cover，contain属性效果。\ntags: <span class=\"label label-primary\">正则表达式</span>\n---\n\n# 一、前言\n\n本文重点是实现`preserveAspectRatio`中`<meetOrSlice>`参数的效果，也是`background-size`中值为`cover`，`contain`属性效果。在实现之前，简单介绍一下**SVG**中的`viewport`, `viewBox`和`preserveAspectRatio`的关系。\n\n## 画布\n\n 当我们创建SVG标签时，实际上是创建了一个**隐形的无限延伸**的画布。\n\n\n\n## 视窗（viewport）\n\n 画布是无限延伸的，但是人的视野是有限的，我们需要设置一个固定的区域，然后在这个固定的区域去绘制图形，使其可见。所以我们通过给SVG设置`width`和`height`属性（或者通过css设置宽高）设置一个可见区域，这个区域就是**viewport**，也就是视窗。这个区域是初始坐标系。\n\n 在不做任何坐标系转换 (transform) 的情况下，我们绘制一个SVG图形，实际是绘制在画布上，但是是以**viewport**的坐标系为参考坐标系绘制的。可以理解为画布是绘制实体，视窗是用来确定具体绘制的位置和尺寸的。\n\n\n## viewBox\n\n\n 什么是**viewBox**呢？\n\n 可以理解为我们手里有一个任意尺寸的方形框，即**viewBox**，这个框可以在视窗的区域内任意位置游走。我们通过设置**viewBox**的属性值，可以指定这个框的尺寸（width, height），以及具体游走在视窗的那个位置（x, y）。\n\n 在框内的画面就是我们最终看到的画面，我们将框内的区域“裁剪”出来，然后通过缩放填充整个视窗。而具体的缩放规则就要看**preserveAspectRatio**属性设置的值。\n\n\n\n\n## preserveAspectRatio\n\n 我们通过**viewBox**裁剪了一个区域，然后将这个区域缩放填充整个视窗。为了便于理解，我们将通过viewBox裁剪出来的区域称为**content**，将视窗称为**box**。\n\n 为了使**content**在缩放过程不变形，我们需要保持**content**的宽高比，如果**content**和**box**的宽高比相等，则**content**通过缩放可以刚好填满整个**box**。但是如果宽高比不相等，那应该如何填充？\n\n **preserveAspectRatio**就是为了解决这个问题而产生的。**preserveAspectRatio**中有两个参数`<align>`和`<meetOrSlice>`，一个值决定**content**按照什么规则缩放，一个值决定缩放后的**content**与**box**的对齐方式。\n\n 其中`<meetOrSlice>`属性值的效果和`background-size`中`cover`和`contain` 类似。\n\n\n\n\n关于更详细的SVG坐标系的解释，参考这两篇文章：\n\n[理解SVG坐标系统和变换： 建立新视窗](<https://www.w3cplus.com/html5/nesting-svgs.html>)\n\n[理解SVG坐标系和变换：视窗,viewBox和preserveAspectRatio](<https://www.w3cplus.com/html5/svg-coordinate-systems.html>)\n\n接下来就详细介绍一下`<meetOrSlice>`是如何控制填充效果的。\n\n\n\n# 二、meetOrSlice定义\n\n为了行文方便，仍然用**content**和**box**分别代指用于填充的矩形图和被填充的盒子。因为本文重点在于探索和实现**preserveAspectRatio**的`<meetOrSlice>`效果，在这里就不对`<align>`参数展开介绍了。\n\n\n\n`<meetOrSlice>`参数有两个值：`meet`和`slice`，其中`meet`类似于`background-size`中的`contain`，`slice`类似于`background-size`中的`cover`。\n\n在[MDN preserveAspectRatio](<https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/preserveAspectRatio>)对这两个属性值是这样描述的：\n\n\n\n> - meet (默认值)  图形将缩放到:\n>   - 宽高比将会被保留\n>   - 整个SVG的viewbox在视图范围内是可见的\n>   - 尽可能的放大SVG的viewbox，同时仍然满足其他的条件。\n>\n> 在这种情况下，如果图形的宽高比和视图窗口不匹配，则某些视图将会超出viewbox范围（即SVG的viewbox视图将会比可视窗口小）。\n>\n> - slice 图形将缩放到:\n>   - 宽高比将会被保留\n>   - 整个视图窗口将覆盖viewbox\n>   - SVG的viewbox属性将会被尽可能的缩小，但是仍然符合其他标准。\n>\n> 在这种情况下，如果SVG的viewbox宽高比与可视区域不匹配，则viewbox的某些区域将会延伸到视图窗口外部（即SVG的viewbox将会比可视窗口大）。\n\n简单概括就是两句话，在保持**content**宽高比不变的情况下：\n\n`meet / contain `：缩放，使**box**包含(contain)完整的**content**，**box**内部可能产生空白。重点：不产生“越界”现象\n\n`slice / cover`：缩放，使**content**覆盖(cover)**box**全部区域，**content**可能会超出**box**区域。重点：不产生空白区域\n\n\n\n# 三、理解meetOrSlice的填充规则\n\n 在了解了这个两个属性值的含义之后，我们再来探究这两个值的具体计算规则。**box**和**content**都是矩形，我们将矩形分为三类：正方形、竖向矩形、横向矩形：\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c1618d33f9c79~tplv-t2oaga2asx-image.image)\n**box**和**content**分别有可能是其中的任意一类，通过排列组合可以得到9种对应关系（相等，同向，异向）：\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c161e53a40906~tplv-t2oaga2asx-image.image)\n\n为了更精确的对比所有尺寸得到的结果，我们分别设置三种类型的**box**尺寸，以及三种类型的**content**尺寸，如下：\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c16219b143378~tplv-t2oaga2asx-image.image)\n\n\n在**SVG**中，设置`meet`和`slice`，得到的结果如下（SVG缩放中会影响到矩形的边框宽度，所以同样的边框宽度因为缩放比例不同会导致最终的视觉宽度不同）：\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c162390e34466~tplv-t2oaga2asx-image.image)\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c1625c3a49f49~tplv-t2oaga2asx-image.image)\n\n\n\n根据定义和实验结果，我们可以发现：\n\n- `meet`模式下，为了使 **content**最大程度的被完整包含在**box**内部，总是**content**的**长边**与**box**对应边对齐。\n\n- `slice`模式下，为了使**box**被填满，总是**content**的**短边**与**box**对应边对齐。\n\n但这两点并不能包含全部情况，我们看👇例子：\n\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c1632ee3c06e3~tplv-t2oaga2asx-image.image)\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c16354a9da897~tplv-t2oaga2asx-image.image)\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c16379452d7e0~tplv-t2oaga2asx-image.image)\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c1639f03b62ff~tplv-t2oaga2asx-image.image)\n\n\n\n从上面的4个例子中可以发现，当**box**和**content**都是同向的矩形（均为横向或者竖向）时，`meet`情况下，还需要继续判断短边的长度；而在`slice`的情况下还需要继续判断长边的长度。\n\n所以我们可以这样描述：\n\n- `meet`：总是比较两者的**长边**：\n\n  - 长边同边（同边：都是横向或者竖向矩形）：假设都为横向矩形，根据宽高比计算在**同一个宽度**下两者的高度，判断哪个的高度更高（反之同理）：\n    - 如果`contentHeight > boxHeight`（此时**box**更“扁”）：为了使**content**被完整包含在**box**里，需要让**content**的高等于**box**的高（对齐高）\n    - 如果`boxHeight > contentHeight`（此时**content**更“扁”）：使**content**的宽等于**box**的宽（对齐宽）\n\n  - 长边异边（异边：一个为横向另一个为竖向）：假设**content**为横向，长边为宽，**box**为竖向，长边为高（可以理解为content更扁一点），则使**content**的宽等于**box**的宽（对齐宽），反之同理。\n\n\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c17e213819216~tplv-t2oaga2asx-image.image)\n\n- `slice`：总是比较两者的**短边**：\n  - 短边同边（同边：同上描述）：假设都为横向矩形，根据宽高比计算在**同一个宽度**下两者的高度，判断哪个的高度更高：\n    - 如果`contentHeight > boxHeight`（此时box更“扁”） ：使**content**的宽等于**box**的宽（对齐宽）\n    - 如果`boxHeight > contentHeight`（此时content更“扁”）：使**content**的高等于**box**的高（对齐高）\n  - 短边异边（异边：同上描述）：假设**content**为横向，短边为高，**box**为竖向，短边为宽，（content更扁），使**content**的高等于**box**的高（对齐高），反之同理。\n  \n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/29/171c18c514237275~tplv-t2oaga2asx-image.image)\n\n\n现在，我们已经知道`meet`和`slice`的缩放规律，根据图，我们可以进一步归纳逻辑。在这里，根据矩形形状的特点，使用“扁”作为统一标准：同宽情况下，高度越小，越扁。\n\n在保持**content**宽高比缩放的情况下，比较**content**和**box**的“扁”度：\n\n- meet\n  - box > content  => 对齐高：**content**的宽高同时乘以一个值使**content**的高等于**box**高\n  - box < content => 对齐宽：**content**的宽高同时乘以一个值使**content**的宽等于**box**宽\n\n- slice\n  - box > content  => 对齐宽：同上\n  - box < content =>对齐高： 同上\n\n伪代码可以这样描述：\n\n```\nif(type == 'meet'){\n  if(box_扁 > content_扁){\n   content_高 * scale = box_高;\n   content_宽 * scale = new_content_宽;\n  }else{\n\tcontent_宽 * scale = box_宽;\n\tcontent_高 * scale = new_content_高;\n  }\n}else if(type == 'slice'){\n if(box_扁 > content_扁){\n\tcontent_宽 * scale = box_宽;\n\tcontent_高 * scale = new_content_高;\n  }else{\n\tcontent_高 * scale = box_高;\n   \tcontent_宽 * scale = new_content_宽;\n  }\n}\n```\n\n\n\n# 四、实现meetOrSlice方法\n\n根据伪代码的描述，为了真正实现这个算法，我们需要：\n\n- 得到一个矩形的“**扁**”度\n\n- 得到**scale**值\n\n其实上面两点非常容易获取：\n\n- 如果一个矩形越扁，意味着宽高比越大，所以可以通过宽高比 `width / height` 来获取“扁”度。\n\n- 而**scale**，在伪代码中其实已经能发现scale的计算方法（假设对齐宽）：\n\n```\ncontentW * scale = boxW;\nscale = boxW / contentW;\n\n\n所以缩放后的content宽高为：\nnewContentW = scale * contentW;\nnewContentH = scale * contentH;\n```\n\n\n\n由此，我们就可以写出`meet`和`slice`方法了：\n\n```javascript\nfunction meetOrSlice(type, boxW, boxH, contentW, contentH){\n    let boxRadio = boxW / boxH,\n        contentRadio = contentW / contentH,\n        scaleW = (boxW / contentW) || 1,\n        scaleH = (boxH / contentH) || 1,\n        scale = 1;\n    if(type == 'meet'){\n        scale = boxRadio >= contentRadio ? scaleH : scaleW;\n    }else if(type == 'slice'){\n        scale = boxRadio >= contentRadio ? scaleW : scaleH;\n    }\n    \n    return {\n        w: scale * contentW,\n        h: scale * contentH\n    }\n}\n```\n\n\n最后和SVG对比一下效果，其中关于边框的两个问题： \n\n- svg中边框宽度不一致：是因为SVG缩放中会连同边框一起缩放 \n- svg中部分 部分边框被裁切：是因为svg内部矩形的x,y定位，是以边框的中线为标准计算的，所以当坐标点为`(0,0)`时，会有一半的边框超出svg的窗口范围，导致被截断。\n\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c1656567c3728~tplv-t2oaga2asx-image.image)\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c165994da0a5e~tplv-t2oaga2asx-image.image)\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c165af0998dc9~tplv-t2oaga2asx-image.image)\n\n\n\n[点击查看源码](https://github.com/kkkkira/demo/blob/master/meetOrSlice/index.html)\n\n完结，撒花🎉。\n\n\n\n### 参考\n\n[理解SVG坐标系统和变换： 建立新视窗](<https://www.w3cplus.com/html5/nesting-svgs.html>)\n\n[理解SVG坐标系和变换：视窗,viewBox和preserveAspectRatio](<https://www.w3cplus.com/html5/svg-coordinate-systems.html>)\n\n[MDN preserveAspectRatio](<https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/preserveAspectRatio>)","slug":"meetOrSlice算法","published":1,"updated":"2023-03-03T07:35:48.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clesk19gp0007dddf00brfmpu","content":"<h1 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h1><p>本文重点是实现<code>preserveAspectRatio</code>中<code>&lt;meetOrSlice&gt;</code>参数的效果，也是<code>background-size</code>中值为<code>cover</code>，<code>contain</code>属性效果。在实现之前，简单介绍一下<strong>SVG</strong>中的<code>viewport</code>, <code>viewBox</code>和<code>preserveAspectRatio</code>的关系。</p>\n<h2 id=\"画布\"><a href=\"#画布\" class=\"headerlink\" title=\"画布\"></a>画布</h2><p> 当我们创建SVG标签时，实际上是创建了一个<strong>隐形的无限延伸</strong>的画布。</p>\n<h2 id=\"视窗（viewport）\"><a href=\"#视窗（viewport）\" class=\"headerlink\" title=\"视窗（viewport）\"></a>视窗（viewport）</h2><p> 画布是无限延伸的，但是人的视野是有限的，我们需要设置一个固定的区域，然后在这个固定的区域去绘制图形，使其可见。所以我们通过给SVG设置<code>width</code>和<code>height</code>属性（或者通过css设置宽高）设置一个可见区域，这个区域就是<strong>viewport</strong>，也就是视窗。这个区域是初始坐标系。</p>\n<p> 在不做任何坐标系转换 (transform) 的情况下，我们绘制一个SVG图形，实际是绘制在画布上，但是是以<strong>viewport</strong>的坐标系为参考坐标系绘制的。可以理解为画布是绘制实体，视窗是用来确定具体绘制的位置和尺寸的。</p>\n<h2 id=\"viewBox\"><a href=\"#viewBox\" class=\"headerlink\" title=\"viewBox\"></a>viewBox</h2><p> 什么是<strong>viewBox</strong>呢？</p>\n<p> 可以理解为我们手里有一个任意尺寸的方形框，即<strong>viewBox</strong>，这个框可以在视窗的区域内任意位置游走。我们通过设置<strong>viewBox</strong>的属性值，可以指定这个框的尺寸（width, height），以及具体游走在视窗的那个位置（x, y）。</p>\n<p> 在框内的画面就是我们最终看到的画面，我们将框内的区域“裁剪”出来，然后通过缩放填充整个视窗。而具体的缩放规则就要看<strong>preserveAspectRatio</strong>属性设置的值。</p>\n<h2 id=\"preserveAspectRatio\"><a href=\"#preserveAspectRatio\" class=\"headerlink\" title=\"preserveAspectRatio\"></a>preserveAspectRatio</h2><p> 我们通过<strong>viewBox</strong>裁剪了一个区域，然后将这个区域缩放填充整个视窗。为了便于理解，我们将通过viewBox裁剪出来的区域称为<strong>content</strong>，将视窗称为<strong>box</strong>。</p>\n<p> 为了使<strong>content</strong>在缩放过程不变形，我们需要保持<strong>content</strong>的宽高比，如果<strong>content</strong>和<strong>box</strong>的宽高比相等，则<strong>content</strong>通过缩放可以刚好填满整个<strong>box</strong>。但是如果宽高比不相等，那应该如何填充？</p>\n<p> <strong>preserveAspectRatio</strong>就是为了解决这个问题而产生的。<strong>preserveAspectRatio</strong>中有两个参数<code>&lt;align&gt;</code>和<code>&lt;meetOrSlice&gt;</code>，一个值决定<strong>content</strong>按照什么规则缩放，一个值决定缩放后的<strong>content</strong>与<strong>box</strong>的对齐方式。</p>\n<p> 其中<code>&lt;meetOrSlice&gt;</code>属性值的效果和<code>background-size</code>中<code>cover</code>和<code>contain</code> 类似。</p>\n<p>关于更详细的SVG坐标系的解释，参考这两篇文章：</p>\n<p><a href=\"https://www.w3cplus.com/html5/nesting-svgs.html\">理解SVG坐标系统和变换： 建立新视窗</a></p>\n<p><a href=\"https://www.w3cplus.com/html5/svg-coordinate-systems.html\">理解SVG坐标系和变换：视窗,viewBox和preserveAspectRatio</a></p>\n<p>接下来就详细介绍一下<code>&lt;meetOrSlice&gt;</code>是如何控制填充效果的。</p>\n<h1 id=\"二、meetOrSlice定义\"><a href=\"#二、meetOrSlice定义\" class=\"headerlink\" title=\"二、meetOrSlice定义\"></a>二、meetOrSlice定义</h1><p>为了行文方便，仍然用<strong>content</strong>和<strong>box</strong>分别代指用于填充的矩形图和被填充的盒子。因为本文重点在于探索和实现<strong>preserveAspectRatio</strong>的<code>&lt;meetOrSlice&gt;</code>效果，在这里就不对<code>&lt;align&gt;</code>参数展开介绍了。</p>\n<p><code>&lt;meetOrSlice&gt;</code>参数有两个值：<code>meet</code>和<code>slice</code>，其中<code>meet</code>类似于<code>background-size</code>中的<code>contain</code>，<code>slice</code>类似于<code>background-size</code>中的<code>cover</code>。</p>\n<p>在<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/preserveAspectRatio\">MDN preserveAspectRatio</a>对这两个属性值是这样描述的：</p>\n<blockquote>\n<ul>\n<li>meet (默认值)  图形将缩放到:<ul>\n<li>宽高比将会被保留</li>\n<li>整个SVG的viewbox在视图范围内是可见的</li>\n<li>尽可能的放大SVG的viewbox，同时仍然满足其他的条件。</li>\n</ul>\n</li>\n</ul>\n<p>在这种情况下，如果图形的宽高比和视图窗口不匹配，则某些视图将会超出viewbox范围（即SVG的viewbox视图将会比可视窗口小）。</p>\n<ul>\n<li>slice 图形将缩放到:<ul>\n<li>宽高比将会被保留</li>\n<li>整个视图窗口将覆盖viewbox</li>\n<li>SVG的viewbox属性将会被尽可能的缩小，但是仍然符合其他标准。</li>\n</ul>\n</li>\n</ul>\n<p>在这种情况下，如果SVG的viewbox宽高比与可视区域不匹配，则viewbox的某些区域将会延伸到视图窗口外部（即SVG的viewbox将会比可视窗口大）。</p>\n</blockquote>\n<p>简单概括就是两句话，在保持<strong>content</strong>宽高比不变的情况下：</p>\n<p><code>meet / contain </code>：缩放，使<strong>box</strong>包含(contain)完整的<strong>content</strong>，<strong>box</strong>内部可能产生空白。重点：不产生“越界”现象</p>\n<p><code>slice / cover</code>：缩放，使<strong>content</strong>覆盖(cover)<strong>box</strong>全部区域，<strong>content</strong>可能会超出<strong>box</strong>区域。重点：不产生空白区域</p>\n<h1 id=\"三、理解meetOrSlice的填充规则\"><a href=\"#三、理解meetOrSlice的填充规则\" class=\"headerlink\" title=\"三、理解meetOrSlice的填充规则\"></a>三、理解meetOrSlice的填充规则</h1><p> 在了解了这个两个属性值的含义之后，我们再来探究这两个值的具体计算规则。<strong>box</strong>和<strong>content</strong>都是矩形，我们将矩形分为三类：正方形、竖向矩形、横向矩形：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c1618d33f9c79~tplv-t2oaga2asx-image.image\"><br><strong>box</strong>和<strong>content</strong>分别有可能是其中的任意一类，通过排列组合可以得到9种对应关系（相等，同向，异向）：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c161e53a40906~tplv-t2oaga2asx-image.image\"></p>\n<p>为了更精确的对比所有尺寸得到的结果，我们分别设置三种类型的<strong>box</strong>尺寸，以及三种类型的<strong>content</strong>尺寸，如下：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c16219b143378~tplv-t2oaga2asx-image.image\"></p>\n<p>在<strong>SVG</strong>中，设置<code>meet</code>和<code>slice</code>，得到的结果如下（SVG缩放中会影响到矩形的边框宽度，所以同样的边框宽度因为缩放比例不同会导致最终的视觉宽度不同）：<br><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c162390e34466~tplv-t2oaga2asx-image.image\"></p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c1625c3a49f49~tplv-t2oaga2asx-image.image\"></p>\n<p>根据定义和实验结果，我们可以发现：</p>\n<ul>\n<li><p><code>meet</code>模式下，为了使 <strong>content</strong>最大程度的被完整包含在<strong>box</strong>内部，总是<strong>content</strong>的<strong>长边</strong>与<strong>box</strong>对应边对齐。</p>\n</li>\n<li><p><code>slice</code>模式下，为了使<strong>box</strong>被填满，总是<strong>content</strong>的<strong>短边</strong>与<strong>box</strong>对应边对齐。</p>\n</li>\n</ul>\n<p>但这两点并不能包含全部情况，我们看👇例子：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c1632ee3c06e3~tplv-t2oaga2asx-image.image\"></p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c16354a9da897~tplv-t2oaga2asx-image.image\"></p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c16379452d7e0~tplv-t2oaga2asx-image.image\"></p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c1639f03b62ff~tplv-t2oaga2asx-image.image\"></p>\n<p>从上面的4个例子中可以发现，当<strong>box</strong>和<strong>content</strong>都是同向的矩形（均为横向或者竖向）时，<code>meet</code>情况下，还需要继续判断短边的长度；而在<code>slice</code>的情况下还需要继续判断长边的长度。</p>\n<p>所以我们可以这样描述：</p>\n<ul>\n<li><p><code>meet</code>：总是比较两者的<strong>长边</strong>：</p>\n<ul>\n<li><p>长边同边（同边：都是横向或者竖向矩形）：假设都为横向矩形，根据宽高比计算在<strong>同一个宽度</strong>下两者的高度，判断哪个的高度更高（反之同理）：</p>\n<ul>\n<li>如果<code>contentHeight &gt; boxHeight</code>（此时<strong>box</strong>更“扁”）：为了使<strong>content</strong>被完整包含在<strong>box</strong>里，需要让<strong>content</strong>的高等于<strong>box</strong>的高（对齐高）</li>\n<li>如果<code>boxHeight &gt; contentHeight</code>（此时<strong>content</strong>更“扁”）：使<strong>content</strong>的宽等于<strong>box</strong>的宽（对齐宽）</li>\n</ul>\n</li>\n<li><p>长边异边（异边：一个为横向另一个为竖向）：假设<strong>content</strong>为横向，长边为宽，<strong>box</strong>为竖向，长边为高（可以理解为content更扁一点），则使<strong>content</strong>的宽等于<strong>box</strong>的宽（对齐宽），反之同理。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c17e213819216~tplv-t2oaga2asx-image.image\"></p>\n<ul>\n<li><code>slice</code>：总是比较两者的<strong>短边</strong>：<ul>\n<li>短边同边（同边：同上描述）：假设都为横向矩形，根据宽高比计算在<strong>同一个宽度</strong>下两者的高度，判断哪个的高度更高：<ul>\n<li>如果<code>contentHeight &gt; boxHeight</code>（此时box更“扁”） ：使<strong>content</strong>的宽等于<strong>box</strong>的宽（对齐宽）</li>\n<li>如果<code>boxHeight &gt; contentHeight</code>（此时content更“扁”）：使<strong>content</strong>的高等于<strong>box</strong>的高（对齐高）</li>\n</ul>\n</li>\n<li>短边异边（异边：同上描述）：假设<strong>content</strong>为横向，短边为高，<strong>box</strong>为竖向，短边为宽，（content更扁），使<strong>content</strong>的高等于<strong>box</strong>的高（对齐高），反之同理。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/29/171c18c514237275~tplv-t2oaga2asx-image.image\"></p>\n<p>现在，我们已经知道<code>meet</code>和<code>slice</code>的缩放规律，根据图，我们可以进一步归纳逻辑。在这里，根据矩形形状的特点，使用“扁”作为统一标准：同宽情况下，高度越小，越扁。</p>\n<p>在保持<strong>content</strong>宽高比缩放的情况下，比较<strong>content</strong>和<strong>box</strong>的“扁”度：</p>\n<ul>\n<li><p>meet</p>\n<ul>\n<li>box &gt; content  =&gt; 对齐高：<strong>content</strong>的宽高同时乘以一个值使<strong>content</strong>的高等于<strong>box</strong>高</li>\n<li>box &lt; content =&gt; 对齐宽：<strong>content</strong>的宽高同时乘以一个值使<strong>content</strong>的宽等于<strong>box</strong>宽</li>\n</ul>\n</li>\n<li><p>slice</p>\n<ul>\n<li>box &gt; content  =&gt; 对齐宽：同上</li>\n<li>box &lt; content =&gt;对齐高： 同上</li>\n</ul>\n</li>\n</ul>\n<p>伪代码可以这样描述：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\">if(type == <span class=\"hljs-string\">&#x27;meet&#x27;</span>)&#123;<br>  if(<span class=\"hljs-keyword\">box_扁 </span>&gt; content_扁)&#123;<br>   content_高 * <span class=\"hljs-keyword\">scale </span>= <span class=\"hljs-keyword\">box_高;</span><br><span class=\"hljs-keyword\"></span>   content_宽 * <span class=\"hljs-keyword\">scale </span>= new_content_宽;<br>  &#125;else&#123;<br>\tcontent_宽 * <span class=\"hljs-keyword\">scale </span>= <span class=\"hljs-keyword\">box_宽;</span><br><span class=\"hljs-keyword\"></span>\tcontent_高 * <span class=\"hljs-keyword\">scale </span>= new_content_高;<br>  &#125;<br>&#125;else if(type == <span class=\"hljs-string\">&#x27;slice&#x27;</span>)&#123;<br> if(<span class=\"hljs-keyword\">box_扁 </span>&gt; content_扁)&#123;<br>\tcontent_宽 * <span class=\"hljs-keyword\">scale </span>= <span class=\"hljs-keyword\">box_宽;</span><br><span class=\"hljs-keyword\"></span>\tcontent_高 * <span class=\"hljs-keyword\">scale </span>= new_content_高;<br>  &#125;else&#123;<br>\tcontent_高 * <span class=\"hljs-keyword\">scale </span>= <span class=\"hljs-keyword\">box_高;</span><br><span class=\"hljs-keyword\"></span>   \tcontent_宽 * <span class=\"hljs-keyword\">scale </span>= new_content_宽;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"四、实现meetOrSlice方法\"><a href=\"#四、实现meetOrSlice方法\" class=\"headerlink\" title=\"四、实现meetOrSlice方法\"></a>四、实现meetOrSlice方法</h1><p>根据伪代码的描述，为了真正实现这个算法，我们需要：</p>\n<ul>\n<li><p>得到一个矩形的“<strong>扁</strong>”度</p>\n</li>\n<li><p>得到<strong>scale</strong>值</p>\n</li>\n</ul>\n<p>其实上面两点非常容易获取：</p>\n<ul>\n<li><p>如果一个矩形越扁，意味着宽高比越大，所以可以通过宽高比 <code>width / height</code> 来获取“扁”度。</p>\n</li>\n<li><p>而<strong>scale</strong>，在伪代码中其实已经能发现scale的计算方法（假设对齐宽）：</p>\n</li>\n</ul>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">contentW * scale <span class=\"hljs-operator\">=</span> boxW<span class=\"hljs-comment\">;</span><br><span class=\"hljs-attribute\">scale</span> <span class=\"hljs-operator\">=</span> boxW / contentW<span class=\"hljs-comment\">;</span><br><br><br>所以缩放后的content宽高为：<br><span class=\"hljs-attribute\">newContentW</span> <span class=\"hljs-operator\">=</span> scale * contentW<span class=\"hljs-comment\">;</span><br><span class=\"hljs-attribute\">newContentH</span> <span class=\"hljs-operator\">=</span> scale * contentH<span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p>由此，我们就可以写出<code>meet</code>和<code>slice</code>方法了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">meetOrSlice</span>(<span class=\"hljs-params\">type, boxW, boxH, contentW, contentH</span>)&#123;<br>    <span class=\"hljs-keyword\">let</span> boxRadio = boxW / boxH,<br>        contentRadio = contentW / contentH,<br>        scaleW = (boxW / contentW) || <span class=\"hljs-number\">1</span>,<br>        scaleH = (boxH / contentH) || <span class=\"hljs-number\">1</span>,<br>        scale = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">if</span>(type == <span class=\"hljs-string\">&#x27;meet&#x27;</span>)&#123;<br>        scale = boxRadio &gt;= contentRadio ? scaleH : scaleW;<br>    &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(type == <span class=\"hljs-string\">&#x27;slice&#x27;</span>)&#123;<br>        scale = boxRadio &gt;= contentRadio ? scaleW : scaleH;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">return</span> &#123;<br>        <span class=\"hljs-attr\">w</span>: scale * contentW,<br>        <span class=\"hljs-attr\">h</span>: scale * contentH<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<p>最后和SVG对比一下效果，其中关于边框的两个问题： </p>\n<ul>\n<li>svg中边框宽度不一致：是因为SVG缩放中会连同边框一起缩放 </li>\n<li>svg中部分 部分边框被裁切：是因为svg内部矩形的x,y定位，是以边框的中线为标准计算的，所以当坐标点为<code>(0,0)</code>时，会有一半的边框超出svg的窗口范围，导致被截断。</li>\n</ul>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c1656567c3728~tplv-t2oaga2asx-image.image\"></p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c165994da0a5e~tplv-t2oaga2asx-image.image\"><br><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c165af0998dc9~tplv-t2oaga2asx-image.image\"></p>\n<p><a href=\"https://github.com/kkkkira/demo/blob/master/meetOrSlice/index.html\">点击查看源码</a></p>\n<p>完结，撒花🎉。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://www.w3cplus.com/html5/nesting-svgs.html\">理解SVG坐标系统和变换： 建立新视窗</a></p>\n<p><a href=\"https://www.w3cplus.com/html5/svg-coordinate-systems.html\">理解SVG坐标系和变换：视窗,viewBox和preserveAspectRatio</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/preserveAspectRatio\">MDN preserveAspectRatio</a></p>\n","site":{"data":{"languages/zh-CN":{"name":"简体中文","home":{"menu":"首页","title":"首页"},"archive":{"menu":"归档","title":"归档","subtitle":"归档","post_total":"共计 %d 篇文章"},"category":{"menu":"分类","title":"分类","subtitle":"分类","post_total":"共计 %d 篇文章","more":"More..."},"tag":{"menu":"标签","title":"标签","subtitle":"标签","post_total":"共计 %d 篇文章"},"about":{"menu":"关于","title":"关于","subtitle":"关于"},"links":{"menu":"友链","title":"友链","subtitle":"友情链接"},"page404":{"menu":"页面不存在","title":"页面不存在","subtitle":"页面不存在"},"post":{"toc":"目录","prev_post":"上一篇","next_post":"下一篇","updated":"本文最后更新于：%s","meta":{"wordcount":"%s 字","min2read":"%s 分钟","views":"{} 次"},"copyright":{"author":"作者","posted":"发布于","updated":"更新于","licensed":"许可协议","CC":"CC - 知识共享许可协议","BY":"BY - 署名","SA":"SA - 相同方式共享","NC":"NC - 非商业性使用","ND":"ND - 禁止演绎"}},"footer":{"pv":"总访问量 {} 次","uv":"总访客数 {} 人"},"search":{"title":"搜索","keyword":"关键词"},"noscript_warning":"博客在允许 JavaScript 运行的环境下浏览效果更佳"}}},"more":"<h1 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h1><p>本文重点是实现<code>preserveAspectRatio</code>中<code>&lt;meetOrSlice&gt;</code>参数的效果，也是<code>background-size</code>中值为<code>cover</code>，<code>contain</code>属性效果。在实现之前，简单介绍一下<strong>SVG</strong>中的<code>viewport</code>, <code>viewBox</code>和<code>preserveAspectRatio</code>的关系。</p>\n<h2 id=\"画布\"><a href=\"#画布\" class=\"headerlink\" title=\"画布\"></a>画布</h2><p> 当我们创建SVG标签时，实际上是创建了一个<strong>隐形的无限延伸</strong>的画布。</p>\n<h2 id=\"视窗（viewport）\"><a href=\"#视窗（viewport）\" class=\"headerlink\" title=\"视窗（viewport）\"></a>视窗（viewport）</h2><p> 画布是无限延伸的，但是人的视野是有限的，我们需要设置一个固定的区域，然后在这个固定的区域去绘制图形，使其可见。所以我们通过给SVG设置<code>width</code>和<code>height</code>属性（或者通过css设置宽高）设置一个可见区域，这个区域就是<strong>viewport</strong>，也就是视窗。这个区域是初始坐标系。</p>\n<p> 在不做任何坐标系转换 (transform) 的情况下，我们绘制一个SVG图形，实际是绘制在画布上，但是是以<strong>viewport</strong>的坐标系为参考坐标系绘制的。可以理解为画布是绘制实体，视窗是用来确定具体绘制的位置和尺寸的。</p>\n<h2 id=\"viewBox\"><a href=\"#viewBox\" class=\"headerlink\" title=\"viewBox\"></a>viewBox</h2><p> 什么是<strong>viewBox</strong>呢？</p>\n<p> 可以理解为我们手里有一个任意尺寸的方形框，即<strong>viewBox</strong>，这个框可以在视窗的区域内任意位置游走。我们通过设置<strong>viewBox</strong>的属性值，可以指定这个框的尺寸（width, height），以及具体游走在视窗的那个位置（x, y）。</p>\n<p> 在框内的画面就是我们最终看到的画面，我们将框内的区域“裁剪”出来，然后通过缩放填充整个视窗。而具体的缩放规则就要看<strong>preserveAspectRatio</strong>属性设置的值。</p>\n<h2 id=\"preserveAspectRatio\"><a href=\"#preserveAspectRatio\" class=\"headerlink\" title=\"preserveAspectRatio\"></a>preserveAspectRatio</h2><p> 我们通过<strong>viewBox</strong>裁剪了一个区域，然后将这个区域缩放填充整个视窗。为了便于理解，我们将通过viewBox裁剪出来的区域称为<strong>content</strong>，将视窗称为<strong>box</strong>。</p>\n<p> 为了使<strong>content</strong>在缩放过程不变形，我们需要保持<strong>content</strong>的宽高比，如果<strong>content</strong>和<strong>box</strong>的宽高比相等，则<strong>content</strong>通过缩放可以刚好填满整个<strong>box</strong>。但是如果宽高比不相等，那应该如何填充？</p>\n<p> <strong>preserveAspectRatio</strong>就是为了解决这个问题而产生的。<strong>preserveAspectRatio</strong>中有两个参数<code>&lt;align&gt;</code>和<code>&lt;meetOrSlice&gt;</code>，一个值决定<strong>content</strong>按照什么规则缩放，一个值决定缩放后的<strong>content</strong>与<strong>box</strong>的对齐方式。</p>\n<p> 其中<code>&lt;meetOrSlice&gt;</code>属性值的效果和<code>background-size</code>中<code>cover</code>和<code>contain</code> 类似。</p>\n<p>关于更详细的SVG坐标系的解释，参考这两篇文章：</p>\n<p><a href=\"https://www.w3cplus.com/html5/nesting-svgs.html\">理解SVG坐标系统和变换： 建立新视窗</a></p>\n<p><a href=\"https://www.w3cplus.com/html5/svg-coordinate-systems.html\">理解SVG坐标系和变换：视窗,viewBox和preserveAspectRatio</a></p>\n<p>接下来就详细介绍一下<code>&lt;meetOrSlice&gt;</code>是如何控制填充效果的。</p>\n<h1 id=\"二、meetOrSlice定义\"><a href=\"#二、meetOrSlice定义\" class=\"headerlink\" title=\"二、meetOrSlice定义\"></a>二、meetOrSlice定义</h1><p>为了行文方便，仍然用<strong>content</strong>和<strong>box</strong>分别代指用于填充的矩形图和被填充的盒子。因为本文重点在于探索和实现<strong>preserveAspectRatio</strong>的<code>&lt;meetOrSlice&gt;</code>效果，在这里就不对<code>&lt;align&gt;</code>参数展开介绍了。</p>\n<p><code>&lt;meetOrSlice&gt;</code>参数有两个值：<code>meet</code>和<code>slice</code>，其中<code>meet</code>类似于<code>background-size</code>中的<code>contain</code>，<code>slice</code>类似于<code>background-size</code>中的<code>cover</code>。</p>\n<p>在<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/preserveAspectRatio\">MDN preserveAspectRatio</a>对这两个属性值是这样描述的：</p>\n<blockquote>\n<ul>\n<li>meet (默认值)  图形将缩放到:<ul>\n<li>宽高比将会被保留</li>\n<li>整个SVG的viewbox在视图范围内是可见的</li>\n<li>尽可能的放大SVG的viewbox，同时仍然满足其他的条件。</li>\n</ul>\n</li>\n</ul>\n<p>在这种情况下，如果图形的宽高比和视图窗口不匹配，则某些视图将会超出viewbox范围（即SVG的viewbox视图将会比可视窗口小）。</p>\n<ul>\n<li>slice 图形将缩放到:<ul>\n<li>宽高比将会被保留</li>\n<li>整个视图窗口将覆盖viewbox</li>\n<li>SVG的viewbox属性将会被尽可能的缩小，但是仍然符合其他标准。</li>\n</ul>\n</li>\n</ul>\n<p>在这种情况下，如果SVG的viewbox宽高比与可视区域不匹配，则viewbox的某些区域将会延伸到视图窗口外部（即SVG的viewbox将会比可视窗口大）。</p>\n</blockquote>\n<p>简单概括就是两句话，在保持<strong>content</strong>宽高比不变的情况下：</p>\n<p><code>meet / contain </code>：缩放，使<strong>box</strong>包含(contain)完整的<strong>content</strong>，<strong>box</strong>内部可能产生空白。重点：不产生“越界”现象</p>\n<p><code>slice / cover</code>：缩放，使<strong>content</strong>覆盖(cover)<strong>box</strong>全部区域，<strong>content</strong>可能会超出<strong>box</strong>区域。重点：不产生空白区域</p>\n<h1 id=\"三、理解meetOrSlice的填充规则\"><a href=\"#三、理解meetOrSlice的填充规则\" class=\"headerlink\" title=\"三、理解meetOrSlice的填充规则\"></a>三、理解meetOrSlice的填充规则</h1><p> 在了解了这个两个属性值的含义之后，我们再来探究这两个值的具体计算规则。<strong>box</strong>和<strong>content</strong>都是矩形，我们将矩形分为三类：正方形、竖向矩形、横向矩形：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c1618d33f9c79~tplv-t2oaga2asx-image.image\"><br><strong>box</strong>和<strong>content</strong>分别有可能是其中的任意一类，通过排列组合可以得到9种对应关系（相等，同向，异向）：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c161e53a40906~tplv-t2oaga2asx-image.image\"></p>\n<p>为了更精确的对比所有尺寸得到的结果，我们分别设置三种类型的<strong>box</strong>尺寸，以及三种类型的<strong>content</strong>尺寸，如下：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c16219b143378~tplv-t2oaga2asx-image.image\"></p>\n<p>在<strong>SVG</strong>中，设置<code>meet</code>和<code>slice</code>，得到的结果如下（SVG缩放中会影响到矩形的边框宽度，所以同样的边框宽度因为缩放比例不同会导致最终的视觉宽度不同）：<br><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c162390e34466~tplv-t2oaga2asx-image.image\"></p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c1625c3a49f49~tplv-t2oaga2asx-image.image\"></p>\n<p>根据定义和实验结果，我们可以发现：</p>\n<ul>\n<li><p><code>meet</code>模式下，为了使 <strong>content</strong>最大程度的被完整包含在<strong>box</strong>内部，总是<strong>content</strong>的<strong>长边</strong>与<strong>box</strong>对应边对齐。</p>\n</li>\n<li><p><code>slice</code>模式下，为了使<strong>box</strong>被填满，总是<strong>content</strong>的<strong>短边</strong>与<strong>box</strong>对应边对齐。</p>\n</li>\n</ul>\n<p>但这两点并不能包含全部情况，我们看👇例子：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c1632ee3c06e3~tplv-t2oaga2asx-image.image\"></p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c16354a9da897~tplv-t2oaga2asx-image.image\"></p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c16379452d7e0~tplv-t2oaga2asx-image.image\"></p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c1639f03b62ff~tplv-t2oaga2asx-image.image\"></p>\n<p>从上面的4个例子中可以发现，当<strong>box</strong>和<strong>content</strong>都是同向的矩形（均为横向或者竖向）时，<code>meet</code>情况下，还需要继续判断短边的长度；而在<code>slice</code>的情况下还需要继续判断长边的长度。</p>\n<p>所以我们可以这样描述：</p>\n<ul>\n<li><p><code>meet</code>：总是比较两者的<strong>长边</strong>：</p>\n<ul>\n<li><p>长边同边（同边：都是横向或者竖向矩形）：假设都为横向矩形，根据宽高比计算在<strong>同一个宽度</strong>下两者的高度，判断哪个的高度更高（反之同理）：</p>\n<ul>\n<li>如果<code>contentHeight &gt; boxHeight</code>（此时<strong>box</strong>更“扁”）：为了使<strong>content</strong>被完整包含在<strong>box</strong>里，需要让<strong>content</strong>的高等于<strong>box</strong>的高（对齐高）</li>\n<li>如果<code>boxHeight &gt; contentHeight</code>（此时<strong>content</strong>更“扁”）：使<strong>content</strong>的宽等于<strong>box</strong>的宽（对齐宽）</li>\n</ul>\n</li>\n<li><p>长边异边（异边：一个为横向另一个为竖向）：假设<strong>content</strong>为横向，长边为宽，<strong>box</strong>为竖向，长边为高（可以理解为content更扁一点），则使<strong>content</strong>的宽等于<strong>box</strong>的宽（对齐宽），反之同理。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c17e213819216~tplv-t2oaga2asx-image.image\"></p>\n<ul>\n<li><code>slice</code>：总是比较两者的<strong>短边</strong>：<ul>\n<li>短边同边（同边：同上描述）：假设都为横向矩形，根据宽高比计算在<strong>同一个宽度</strong>下两者的高度，判断哪个的高度更高：<ul>\n<li>如果<code>contentHeight &gt; boxHeight</code>（此时box更“扁”） ：使<strong>content</strong>的宽等于<strong>box</strong>的宽（对齐宽）</li>\n<li>如果<code>boxHeight &gt; contentHeight</code>（此时content更“扁”）：使<strong>content</strong>的高等于<strong>box</strong>的高（对齐高）</li>\n</ul>\n</li>\n<li>短边异边（异边：同上描述）：假设<strong>content</strong>为横向，短边为高，<strong>box</strong>为竖向，短边为宽，（content更扁），使<strong>content</strong>的高等于<strong>box</strong>的高（对齐高），反之同理。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/29/171c18c514237275~tplv-t2oaga2asx-image.image\"></p>\n<p>现在，我们已经知道<code>meet</code>和<code>slice</code>的缩放规律，根据图，我们可以进一步归纳逻辑。在这里，根据矩形形状的特点，使用“扁”作为统一标准：同宽情况下，高度越小，越扁。</p>\n<p>在保持<strong>content</strong>宽高比缩放的情况下，比较<strong>content</strong>和<strong>box</strong>的“扁”度：</p>\n<ul>\n<li><p>meet</p>\n<ul>\n<li>box &gt; content  =&gt; 对齐高：<strong>content</strong>的宽高同时乘以一个值使<strong>content</strong>的高等于<strong>box</strong>高</li>\n<li>box &lt; content =&gt; 对齐宽：<strong>content</strong>的宽高同时乘以一个值使<strong>content</strong>的宽等于<strong>box</strong>宽</li>\n</ul>\n</li>\n<li><p>slice</p>\n<ul>\n<li>box &gt; content  =&gt; 对齐宽：同上</li>\n<li>box &lt; content =&gt;对齐高： 同上</li>\n</ul>\n</li>\n</ul>\n<p>伪代码可以这样描述：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\">if(type == <span class=\"hljs-string\">&#x27;meet&#x27;</span>)&#123;<br>  if(<span class=\"hljs-keyword\">box_扁 </span>&gt; content_扁)&#123;<br>   content_高 * <span class=\"hljs-keyword\">scale </span>= <span class=\"hljs-keyword\">box_高;</span><br><span class=\"hljs-keyword\"></span>   content_宽 * <span class=\"hljs-keyword\">scale </span>= new_content_宽;<br>  &#125;else&#123;<br>\tcontent_宽 * <span class=\"hljs-keyword\">scale </span>= <span class=\"hljs-keyword\">box_宽;</span><br><span class=\"hljs-keyword\"></span>\tcontent_高 * <span class=\"hljs-keyword\">scale </span>= new_content_高;<br>  &#125;<br>&#125;else if(type == <span class=\"hljs-string\">&#x27;slice&#x27;</span>)&#123;<br> if(<span class=\"hljs-keyword\">box_扁 </span>&gt; content_扁)&#123;<br>\tcontent_宽 * <span class=\"hljs-keyword\">scale </span>= <span class=\"hljs-keyword\">box_宽;</span><br><span class=\"hljs-keyword\"></span>\tcontent_高 * <span class=\"hljs-keyword\">scale </span>= new_content_高;<br>  &#125;else&#123;<br>\tcontent_高 * <span class=\"hljs-keyword\">scale </span>= <span class=\"hljs-keyword\">box_高;</span><br><span class=\"hljs-keyword\"></span>   \tcontent_宽 * <span class=\"hljs-keyword\">scale </span>= new_content_宽;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"四、实现meetOrSlice方法\"><a href=\"#四、实现meetOrSlice方法\" class=\"headerlink\" title=\"四、实现meetOrSlice方法\"></a>四、实现meetOrSlice方法</h1><p>根据伪代码的描述，为了真正实现这个算法，我们需要：</p>\n<ul>\n<li><p>得到一个矩形的“<strong>扁</strong>”度</p>\n</li>\n<li><p>得到<strong>scale</strong>值</p>\n</li>\n</ul>\n<p>其实上面两点非常容易获取：</p>\n<ul>\n<li><p>如果一个矩形越扁，意味着宽高比越大，所以可以通过宽高比 <code>width / height</code> 来获取“扁”度。</p>\n</li>\n<li><p>而<strong>scale</strong>，在伪代码中其实已经能发现scale的计算方法（假设对齐宽）：</p>\n</li>\n</ul>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">contentW * scale <span class=\"hljs-operator\">=</span> boxW<span class=\"hljs-comment\">;</span><br><span class=\"hljs-attribute\">scale</span> <span class=\"hljs-operator\">=</span> boxW / contentW<span class=\"hljs-comment\">;</span><br><br><br>所以缩放后的content宽高为：<br><span class=\"hljs-attribute\">newContentW</span> <span class=\"hljs-operator\">=</span> scale * contentW<span class=\"hljs-comment\">;</span><br><span class=\"hljs-attribute\">newContentH</span> <span class=\"hljs-operator\">=</span> scale * contentH<span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p>由此，我们就可以写出<code>meet</code>和<code>slice</code>方法了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">meetOrSlice</span>(<span class=\"hljs-params\">type, boxW, boxH, contentW, contentH</span>)&#123;<br>    <span class=\"hljs-keyword\">let</span> boxRadio = boxW / boxH,<br>        contentRadio = contentW / contentH,<br>        scaleW = (boxW / contentW) || <span class=\"hljs-number\">1</span>,<br>        scaleH = (boxH / contentH) || <span class=\"hljs-number\">1</span>,<br>        scale = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">if</span>(type == <span class=\"hljs-string\">&#x27;meet&#x27;</span>)&#123;<br>        scale = boxRadio &gt;= contentRadio ? scaleH : scaleW;<br>    &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(type == <span class=\"hljs-string\">&#x27;slice&#x27;</span>)&#123;<br>        scale = boxRadio &gt;= contentRadio ? scaleW : scaleH;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">return</span> &#123;<br>        <span class=\"hljs-attr\">w</span>: scale * contentW,<br>        <span class=\"hljs-attr\">h</span>: scale * contentH<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<p>最后和SVG对比一下效果，其中关于边框的两个问题： </p>\n<ul>\n<li>svg中边框宽度不一致：是因为SVG缩放中会连同边框一起缩放 </li>\n<li>svg中部分 部分边框被裁切：是因为svg内部矩形的x,y定位，是以边框的中线为标准计算的，所以当坐标点为<code>(0,0)</code>时，会有一半的边框超出svg的窗口范围，导致被截断。</li>\n</ul>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c1656567c3728~tplv-t2oaga2asx-image.image\"></p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c165994da0a5e~tplv-t2oaga2asx-image.image\"><br><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c165af0998dc9~tplv-t2oaga2asx-image.image\"></p>\n<p><a href=\"https://github.com/kkkkira/demo/blob/master/meetOrSlice/index.html\">点击查看源码</a></p>\n<p>完结，撒花🎉。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://www.w3cplus.com/html5/nesting-svgs.html\">理解SVG坐标系统和变换： 建立新视窗</a></p>\n<p><a href=\"https://www.w3cplus.com/html5/svg-coordinate-systems.html\">理解SVG坐标系和变换：视窗,viewBox和preserveAspectRatio</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/preserveAspectRatio\">MDN preserveAspectRatio</a></p>\n"},{"title":"浅谈计算机字体","date":"2023-03-03T05:05:41.000Z","excerpt":"本文主要介绍了一下计算机字体的发展以及一些字体规范。","_content":"# 计算机字体简介\n\n## 字体分类\n\n## 点阵字体\n\n点阵字体是指每一个字符都按照16×16或24×24的尺寸设置，在设定好的尺寸内，通过每个像素点的虚实来表示字符的轮廓。点阵字体也叫**位图字体**，其中每个字形都以一组二维像素信息表示。\n\n因为是预先设计好然后直接输出，当字符进行动态的放大缩小时，是无法清晰的显示字形轮廓，所以点阵字体只在预设好的字号下能清晰显示，有时候不同的字号甚至可能显示成完全不同的字体，例如（图片出处：[对计算机字体渲染的一些研究](https://xuchen.wang/archives/fonts.html)）：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b543e25616774f4395ffe52440d961eb~tplv-k3u1fbpfcp-zoom-1.image)\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95709cb05db540918c68bc2393d1c834~tplv-k3u1fbpfcp-zoom-1.image)\n\n## 矢量字体\n\n矢量字体又叫做轮廓字体(Outline Fonts)，是利用贝塞尔曲线来描述字形轮廓，当使用该字体时，计算机根据曲线进行实时计算渲染，从而保证了当字体进行任意大小缩放时，字符都能清晰显示。\n\n\n\n## 渲染技术\n\n无论是点阵字体还是矢量字体，在计算机中，其本质都是栅格化（Rasterization）图像。对于计算机而言，其最小操作单元就是一个个像素栅格。如何使用一定数量的像素栅格去准确描绘理想的字体形状，就是需要解决的问题。\n\n\n\n## 黑白渲染（Black and white rendering）\n\n黑白渲染又叫做二值渲染（bi-level rendering）。黑白渲染是最早人们使用的渲染技术，这种渲染方式只使用黑白两种颜色来表达文字的形状。目前打印机就仍在使用这种方法，由于打印机的高输出分辨率，打印的结果能很好地再现原图。但是由于屏幕的分辨率较低，在这种渲染方式下，放大字体可能就会看到一些锯齿。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/132cb451161343ff9e499d6127457c04~tplv-k3u1fbpfcp-zoom-1.image)\n\n## 灰度渲染（Grayscale rendering）\n\n灰度渲染实际上是计算机图形学中的一种**反锯齿（Anti-Aliasing）**技术，通过在锯齿边缘增加一些灰阶像素，从而平滑字体轮廓。它的灰度值取决于理想的字型在此像素所覆盖的面积比例。该技术的原理与照片重新采样（resampled）到一个较低分辨率时的原理是相同的，人眼在识别图像时，由于图像的边界不明显，大脑会将其与周围的像素理解为一个整体。 因此我们的眼睛和大脑在理解灰色像素所包含的信息时，会将它转换为字型的轮廓，这就让我们可以获得与原始设计极为接近的渲染效果。\n\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b676f63f1e254af4bddb0f271e4da1c2~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n\n## 亚像素渲染（Subpixel rendering）\n\n亚像素渲染实际上是灰度渲染的进阶版。这种技术的出现主要得益于硬件的提升。传统CRT显示器最小控制单元是像素，是由相邻的红、绿、蓝荧光粉单元各一个为一组组成。LCD液晶显示屏也是由红、绿、蓝三个子（亚）像素构成的，它们共同决定了这一像素的颜色和亮度，但LCD能够做到单独控制每一个子像素。因为这些子像素非常小，以至于人眼无法察觉到他们是一个个独立的颜色点。与单纯的灰度渲染相比，水平方向的分辨率翻了三倍。\n\n将亚像素渲染与灰度渲染对比可以发现，视觉上来说亚像素的边缘会更平滑：\n<div style=\"text-align: center\"><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddfb377e5b2940b8a59af7e3cc7b9a94~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"20200804180415\" style=\"zoom:50%;\" /></div>\n\n\n我们将这个像素细化到亚像素并转为灰度模式可以会有更直观的感受，原有的一个灰阶像素变成了三个灰阶亚像素，整个边缘进行了更加平滑的过渡：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a4fb6f747ee4b78b983e68bfa026d46~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n# 字符编码\n\n文字，是一个可以被人类识别的图形化符号，本质是图形，在计算机我们称之为图元。但是文字是人类文明的产物，计算机并不认识。但是对于计算机而言，它只会认识由0、1组成的二进制值，所以为了让计算机识别一段文字，需要让文字与二进制值之间进行相互转化，这个过程就是编码与解码的过程。\n\n\n\n在计算机中存在着多种编码格式，包括ASCII编码、GB类的中文编码以及Unicode编码等，关于中文字符编码，可以查看[这篇文章](https://zhuanlan.zhihu.com/p/46216008)，本文就不做介绍，只是简单介绍一下ASCII编码和Unicode编码。\n\n## ASCII编码\n\nASCII码是是上个世纪60年代美国信息交换标准代码是由美国国家标准学会(American National Standard Institute , ANSI )制定的，是一种标准的**单字节**字符[编码](https://baike.baidu.com/item/编码)方案，用于基于[文本](https://baike.baidu.com/item/文本)的数据，对英语字符与二进制位之间的关系，做了统一规定。\n\nASCII规定，用8位二进制（1byte，8bit）来存储字符和特殊符号，总共可以表示256个字符。（因为英文字符总共才26个，加上特殊字符，8bit绰绰有余）。\n\n早期只针对英文编码，是使用7 位二进制数（剩下的1位二进制为0）来表示所有的大写和小写字母，数字0 到9、标点符号，以及在美式英语中使用的特殊控制字符。此时7位的叫做[标准ASCII码](http://ascii.911cha.com/)也叫**基础ASCII码**。\n\n后来当它被国际标准化组织（International Organization for Standardization, ISO）定为国际标准后，仅仅128个符号编码就不够用了，因为在其他的拉丁文字字母中还可能存在注音符号，这时就无法用基础 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。此时把8位二进制编码的字符码称为**[扩展ASCII](https://baike.baidu.com/item/扩展ASCII)码**。\n\n\n\n## Unicode\n\n我们知道ASCII码最多支持256位字符，用来表示其他语言是完全不够的，亚洲国家的文字中，汉字就多达10万左右。因此出现了多种编码格式，例如GB类的中文编码。当通过多种编码方案解决了多语言的字符显示问题之后，又出现了新的问题：乱码。\n\n我们都知道计算机内部只存储二进制数据，当我们进行通信时，发送者需要将文字编码成一串二进制比特流进行传输通信，而接收者需要使用同一套编码规则进行解码，才能获取到正确的信息。但是如果通信双方使用不同的编码规则，例如发送者使用单字节编码（规定每8位为一个字符码），而接收者使用双字节解码（规定每16位为一个字符码），或者接收者同样使用单字节编码，但是其对应的不是同一个字符，就会出现乱码。\n\n于是Unicode就出现了。Unicode把所有语言都统一到一套编码里，每个字符在Unicode中只有唯一的字符码。\n\n## Unicode标准\n\nUnicode标准定义 **一个字符代表一个code，不存在二义性**，例如`U+0041`总是代表`'A'`，而且这套标准也会随着需求不断的拓展。\n\n实质上Unicode只是一个字符集，里面是定义了所有字符和二进制code的对应关系，但是并没有真正实现字符集的编码。而UTF-8，UTF-16，UTF-32就是Unicode的不同实现。\n\n## UTF-8\n\nUTF-8 是在互联网上使用最广的一种 Unicode 的实现方式之一。UTF-8 最大的一个特点，就是它是一种变长的编码方式，根据不同的Unicode字符，使用不同数量的字节编码。因为如果采用单字节编码方式，是不够的，而如果采用多字节编码，那么对于小序的字符来说，会在前面填充非常多的0，非常浪费空间。所以用一种可变的方式，既可以有效的利用空间，又可以包含更多数量的字符。\n\n\n\n> UTF-8 的编码规则很简单，只有二条：\n>\n> 1）对于单字节的符号，字节的第一位设为`0`，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。\n>\n> 2）对于`n`字节的符号（`n > 1`），第一个字节的前`n`位都设为`1`，第`n + 1`位设为`0`，后面字节的前两位一律设为`10`。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。\n>\n> 下表总结了编码规则，字母`x`表示可用编码的位。\n>\n> ```\n> Unicode符号范围     |        UTF-8编码方式\n> (十六进制)          |         （二进制）\n> ----------------------+---------------------------------------------\n> 0000 0000-0000 007F | 0xxxxxxx\n> 0000 0080-0000 07FF | 110xxxxx 10xxxxxx\n> 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx\n> 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n> ```\n\n\n\n## UTF-16\n\nUnicode编码中，最常用的字符其实是`0-65535`，因此针对这点产生了UTF-16方案。\n\nUTF-16编码以16位无符号整数为单位，将0–65535范围内的字符编码成2个字节，超过这个的用4个字节编码。UTF16编码是Unicode最直接的实现方式，通常我们在windows上新建文本文件后保存为Unicode编码，其实就是保存为UTF16编码。\n\n\n\n## UTF-32\n\nUTF-32是Unicode的一种实现方式. UTF32编码使用固定的4个字节来存储。 因此,非常浪费空间,不利于网络传输,所以使用不普遍。\n\n\n\n# 字体文件\n\n## 常见的字体文件格式\n\n我们知道，字体分为点阵字体和矢量字体。\n\n对于纯点阵字体，其常见的字体格式包括： bdf，pcf，fnt，hbf 。\n\n对于矢量字体，其常见的格式包括**Type1**，**TrueType（ttf）**和**OpenType（otf / ttf）**。\n\n\n\n简单介绍一下矢量字体中各个格式之间的的区别：\n\n- **Type1**：全称**PostScript Type1**，是1985年由Adobe公司提出的一套矢量字体标准，使用贝塞尔曲线描述字形，称为**PostScript曲线**。是非开放字体，使用需要收费。\n\n- **TrueType**：TrueType是1991年由苹果（Apple）公司与 微软（Microsoft）公司联合提出另一套矢量字标准。虽然与Type1都是使用贝塞尔曲线描述字体轮廓，但是**Type1**使用三次贝塞尔曲线来描述字形，而TrueType使用的是二次贝塞尔曲线（**TrueType曲线**）。**TrueType 曲线**可接受典型的 hinting，可告知栅格化引擎在栅格化之前应该如何把轮廓扭曲，这样可精确控制字体的抗锯齿结果。\n\n- **Opentype**：是1995年由微软（Microsoft）和 Adobe公司开发的另外一种字体格式 ，基于TrueType扩展，内部兼容了**TrueType 曲线**和 **PostScript 曲线**。并且真正支持 **Unicode**的字体，最多可以支持 65535 个码位。其后缀名可以是ttf或者otf。仅包含**TrueType 曲线**，其后缀名一般是**ttf**，包含有 **PostScript 曲线**的，后缀名则是**otf**。\n\n\n\n而目前常见的用于web的字体格式，除了主流的otf 和 ttf之外，还包括了**WOFF** 和 **SVG**。\n\n> - **WOFF**：WOFF (Web Open Font Format) 本质上是 metadata + 基于 SFNT 的字体（如 TTF、OTF 或其他开放字体格式）。该格式完全是为了 Web 而创建，由 Mozilla 基金会、微软和 Opera 软件公司合作推出。 WOFF 字体均经过 WOFF 的编码工具压缩，文件大小一般比 TTF 小 40%，加载速度更快，可以更好的嵌入网页中。metadata 允许在字体文件中包含许可数据，以解决版权问题。这是万维网联盟提（qing）倡（ding）的，所以毫无疑问的是字体格式的未来。**目前主流的浏览器的新版本几乎都支持 WOFF。**\n>\n> - **SVG**：SVG (Scalable Vector Graphics font) 字体格式使用 SVG 的字体元素定义。这些字体包含作为标准 SVG 元素和属性的字形轮廓，就像它们是 SVG 映像中的单个矢量对象一样。SVG 字体最大的缺点是缺少字体提示（font-hinting）。字体提示是渲染小字体时为了质量和清晰度额外嵌入的信息。同时，SVG 对文本（body text）支持并不是特别好。因为 SVG 的文本选择（text selection）目前在 Safari、Safari Mobile 和 Chrome 的一些版本上完全崩坏，所以你不能选择单个字符、单词或任何自定义选项，你只能选择整行或段落文本。\n\n\n\n\n\n## TrueType 字体\n\n目前最常使用的主流字体格式还是**ttf**。所以简单了解一下**TrueType** 字体文件结构。\n\n**TrueType** 字体是一个矢量字体格式。对于矢量字体来说，要准确绘制一个字体，其文件中需要存储其图元轮廓的定义，字符代码与图元的映射等信息。所以在**TrueType**字体文件中，存储了多张表格，不同的表格包含了与字体相关的不同信息，下表包含了部分表格说明：\n\n| 表名 | 说明                    | 说明                                                         |\n| ---- | ----------------------- | ------------------------------------------------------------ |\n| head | 字体头                  | 字体的全局信息                                               |\n| cmap | 字符代码到图元的映射    | 把字符代码映射为图元索引                                     |\n| glyf | 图元数据                | 图元轮廓定义以及网格调整指令                                 |\n| maxp | 最大需求表              | 字体中所需内存分配情况的汇总数据                             |\n| mmtx | 水平规格                | 图元水平规格                                                 |\n| loca | 位置表索引              | 把元索引转换为图元的位置                                     |\n| name | 命名表                  | 版权说明、字体名、字体族名、风格名等等                       |\n| hmtx | 水平布局                | 字体水平布局星系：上高、下高、行间距、最大前进宽度、最小左支撑、最小右支撑 |\n| kerm | 字距调整表              | 字距调整对的数组                                             |\n| post | PostScript信息          | 所有图元的PostScript  FontInfo目录项和PostScript名           |\n| PCLT | PCL  5数据              | HP  PCL  5Printer  Language  的字体信息：字体数、宽度、x高度、风格、记号集等等 |\n| hhea | mac下渲染数据           | 水平布局排列字符的字体所需的信息                             |\n| OS/2 | OS/2和Windows特有的规格 | TrueType字体所需的规格集                                     |\n\n其中对于文本的排版布局来说，有几个参数比较重要：\n\n- head表中的`unitsPerEm`字段代表字形中UPM值\n\n- hhea表中的`ascent` 、`descent` 和`line gap` 字段常用于Mac OS下的字体渲染。\n- OS/2表中\n  - 用于window字体渲染\n    - `usWinAscent`\n    - `usWinDescent`\n  - 用于印刷\n    - `sTypoAscender`\n    - `sTypoDescender`\n    - `sTypoLineGap`\n    - `sCapHeight`\n    - `sxHeight`\n\n\n\n这些参数主要用于排版布局的计算。对于前端而言，在CSS行框计算中，这是最根本的依据。但是这些参数究竟代表了什么含义呢？在这里做一个简单的介绍。\n\n## em square (UPM)\n\nem框，也叫做upm（units per em）。在字体设计中，一个字符图形需要设计到在一个框内，这个框我们称之为em框。em框的概念最早来自印刷。\n\n> 在传统的金属字模中，每个字符被放置在一个统一大小的金属块中，每个字符的高度是统一的，这样每个字模可以整齐地放进行和块中（如下）。\n>\n> 字模的高度被称为`em`，起源于大写的字符“M”的宽度；这个字母的比例被做成了方形（因此有了“EM Square”的称呼）。\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d25914fc3d464f618a3c0f74c731f876~tplv-k3u1fbpfcp-zoom-1.image)\n\nem size是根据字模计算出的点值。是字符占用空间的数字化定义总量，通常指代高度，表示当前字体的字符在设计时的单位量。在OpenType字体中，UPM或em大小通常是1000单位。在TrueType字体中，UPM约定是2的幂，通常是1024或2048。而我们设置字号大小，实际上是在设置em框，从而实现缩放字符的效果。\n\n下图的字体是在1000单位的em框中设计，其中这个 `H` 字符在设计时总高度为700单位，占整个框高度的 7/10，那么当给这个字符设置10px时，其实是规定了em的大小为10px，那么此时 `H` 的实际高度就是7px：\n$$\n7 / 10 * 10  = 7\n$$\n\n\n<div style=\"text-align: center;margin-top: 50px;\">\n  <img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92d57fb265eb49d4b34fa0b5a4b160a4~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"20200804180415\" style=\"zoom:50%;\" /></div>\n\n\n## font Metrics\n\n简单来说，**字体度量（Font Metrics）**就是描述一个字体的一系列参数，用于计算机解析渲染字体。在设计一套字体时，可以对这些参数进行自定义设置从而实现自定义字体设计。这些参数包含了一个字体中各个字形的轮廓参数，字符的大小，样式设置，以及该字体中字符与字符间的排布等，可以通过[glossary](https://www.fontshop.com/glossary) 来了解相关的设计参数信息与含义。\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c8976e9e2e1404ea228b9790156f9b9~tplv-k3u1fbpfcp-zoom-1.image)\n\n而这一些系列的参数中，重点介绍一下与字符排布相关的参数（这些参数都是以英文字符为参考对象）：\n\n| 参数               | 定义                                                         |\n| ------------------ | ------------------------------------------------------------ |\n| baseline           | 是文字绘制时所参照的基准线，所有的文字以此为基准位置进行设计。 |\n| x-height           | 小写字母的高度，以x为例                                      |\n| capital height     | 基线到大写字母顶部到高度                                     |\n| ascent             | 小写字母中延伸到 x-height以上的部分                          |\n| descent            | 小写字母中延伸到 x-height以下 的部分                         |\n| leading / line gap | 从基线到基线的文本行之间的垂直间隔                           |\n| midline            | 位于小写字母的主体之上，基线和中线之间的距离是x-height       |\n| spacing            | 字间距                                                       |\n\n通过一张图来了解这些参数（图源网络）：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1133390d7ac403ab6fec921cd1752a7~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n\n\n\n\n\n\n\n\n\n# 参考\n\n[参数化设计与字体战争：从 OpenType 1.8 说起](https://www.thetype.com/2016/09/10968/)\n\n[一笔一划间蕴藏的学问 浅谈计算机字体](https://pcedu.pconline.com.cn/teach/xt/1205/2783057_all.html)\n\n[对计算机字体渲染的一些研究](https://xuchen.wang/archives/fonts.html)\n\n[A Closer Look At Font Rendering](https://www.smashingmagazine.com/2012/04/a-closer-look-at-font-rendering/)\n\n[Font smoothing, anti-aliasing, and sub-pixel rendering](https://www.joelonsoftware.com/2007/06/12/font-smoothing-anti-aliasing-and-sub-pixel-rendering/)\n[Antialiasing 101](https://www.html5rocks.com/zh/tutorials/internals/antialiasing-101/)\n\n[十分钟搞清字符集和字符编码](http://cenalulu.github.io/linux/character-encoding/)\n \n[The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets](https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/)\n\n[百度百科：ASCII](https://baike.baidu.com/item/ASCII)\n\n[百度百科：Unicode](https://baike.baidu.com/item/Unicode)\n\n[字符编码笔记：ASCII，Unicode 和 UTF-8](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)\n[【字符编码系列】常用的几种字符编码(GBK，UTF-8，UTF-16)](https://dailc.github.io/2017/05/17/severalCommonlyCharEncoding.html)\n[TrueType](https://developer.apple.com/fonts/TrueType-Reference-Manual/)\n[Web 字体简介: TTF, OTF, WOFF, EOT & SVG](https://zhuanlan.zhihu.com/p/28179203)\n[字体生成小记](http://www.shushilvshe.com/data/font-build.html)\n[ttf文件结构解析](https://www.cnblogs.com/sjhrun2001/archive/2010/01/19/1651274.html)\n\n[Typr.js](https://photopea.github.io/Typr.js/)\n\n","source":"_posts/浅谈计算机字体.md","raw":"---\ntitle: 浅谈计算机字体\ndate: 2023-03-03 13:05:41\ncategory: [字体渲染]\ntags: <span class=\"label label-primary\">字体渲染</span> <span class=\"label label-primary\">ttf</span> <span class=\"label label-primary\">字符编码</span>\nexcerpt: 本文主要介绍了一下计算机字体的发展以及一些字体规范。\n---\n# 计算机字体简介\n\n## 字体分类\n\n## 点阵字体\n\n点阵字体是指每一个字符都按照16×16或24×24的尺寸设置，在设定好的尺寸内，通过每个像素点的虚实来表示字符的轮廓。点阵字体也叫**位图字体**，其中每个字形都以一组二维像素信息表示。\n\n因为是预先设计好然后直接输出，当字符进行动态的放大缩小时，是无法清晰的显示字形轮廓，所以点阵字体只在预设好的字号下能清晰显示，有时候不同的字号甚至可能显示成完全不同的字体，例如（图片出处：[对计算机字体渲染的一些研究](https://xuchen.wang/archives/fonts.html)）：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b543e25616774f4395ffe52440d961eb~tplv-k3u1fbpfcp-zoom-1.image)\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95709cb05db540918c68bc2393d1c834~tplv-k3u1fbpfcp-zoom-1.image)\n\n## 矢量字体\n\n矢量字体又叫做轮廓字体(Outline Fonts)，是利用贝塞尔曲线来描述字形轮廓，当使用该字体时，计算机根据曲线进行实时计算渲染，从而保证了当字体进行任意大小缩放时，字符都能清晰显示。\n\n\n\n## 渲染技术\n\n无论是点阵字体还是矢量字体，在计算机中，其本质都是栅格化（Rasterization）图像。对于计算机而言，其最小操作单元就是一个个像素栅格。如何使用一定数量的像素栅格去准确描绘理想的字体形状，就是需要解决的问题。\n\n\n\n## 黑白渲染（Black and white rendering）\n\n黑白渲染又叫做二值渲染（bi-level rendering）。黑白渲染是最早人们使用的渲染技术，这种渲染方式只使用黑白两种颜色来表达文字的形状。目前打印机就仍在使用这种方法，由于打印机的高输出分辨率，打印的结果能很好地再现原图。但是由于屏幕的分辨率较低，在这种渲染方式下，放大字体可能就会看到一些锯齿。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/132cb451161343ff9e499d6127457c04~tplv-k3u1fbpfcp-zoom-1.image)\n\n## 灰度渲染（Grayscale rendering）\n\n灰度渲染实际上是计算机图形学中的一种**反锯齿（Anti-Aliasing）**技术，通过在锯齿边缘增加一些灰阶像素，从而平滑字体轮廓。它的灰度值取决于理想的字型在此像素所覆盖的面积比例。该技术的原理与照片重新采样（resampled）到一个较低分辨率时的原理是相同的，人眼在识别图像时，由于图像的边界不明显，大脑会将其与周围的像素理解为一个整体。 因此我们的眼睛和大脑在理解灰色像素所包含的信息时，会将它转换为字型的轮廓，这就让我们可以获得与原始设计极为接近的渲染效果。\n\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b676f63f1e254af4bddb0f271e4da1c2~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n\n## 亚像素渲染（Subpixel rendering）\n\n亚像素渲染实际上是灰度渲染的进阶版。这种技术的出现主要得益于硬件的提升。传统CRT显示器最小控制单元是像素，是由相邻的红、绿、蓝荧光粉单元各一个为一组组成。LCD液晶显示屏也是由红、绿、蓝三个子（亚）像素构成的，它们共同决定了这一像素的颜色和亮度，但LCD能够做到单独控制每一个子像素。因为这些子像素非常小，以至于人眼无法察觉到他们是一个个独立的颜色点。与单纯的灰度渲染相比，水平方向的分辨率翻了三倍。\n\n将亚像素渲染与灰度渲染对比可以发现，视觉上来说亚像素的边缘会更平滑：\n<div style=\"text-align: center\"><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddfb377e5b2940b8a59af7e3cc7b9a94~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"20200804180415\" style=\"zoom:50%;\" /></div>\n\n\n我们将这个像素细化到亚像素并转为灰度模式可以会有更直观的感受，原有的一个灰阶像素变成了三个灰阶亚像素，整个边缘进行了更加平滑的过渡：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a4fb6f747ee4b78b983e68bfa026d46~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n# 字符编码\n\n文字，是一个可以被人类识别的图形化符号，本质是图形，在计算机我们称之为图元。但是文字是人类文明的产物，计算机并不认识。但是对于计算机而言，它只会认识由0、1组成的二进制值，所以为了让计算机识别一段文字，需要让文字与二进制值之间进行相互转化，这个过程就是编码与解码的过程。\n\n\n\n在计算机中存在着多种编码格式，包括ASCII编码、GB类的中文编码以及Unicode编码等，关于中文字符编码，可以查看[这篇文章](https://zhuanlan.zhihu.com/p/46216008)，本文就不做介绍，只是简单介绍一下ASCII编码和Unicode编码。\n\n## ASCII编码\n\nASCII码是是上个世纪60年代美国信息交换标准代码是由美国国家标准学会(American National Standard Institute , ANSI )制定的，是一种标准的**单字节**字符[编码](https://baike.baidu.com/item/编码)方案，用于基于[文本](https://baike.baidu.com/item/文本)的数据，对英语字符与二进制位之间的关系，做了统一规定。\n\nASCII规定，用8位二进制（1byte，8bit）来存储字符和特殊符号，总共可以表示256个字符。（因为英文字符总共才26个，加上特殊字符，8bit绰绰有余）。\n\n早期只针对英文编码，是使用7 位二进制数（剩下的1位二进制为0）来表示所有的大写和小写字母，数字0 到9、标点符号，以及在美式英语中使用的特殊控制字符。此时7位的叫做[标准ASCII码](http://ascii.911cha.com/)也叫**基础ASCII码**。\n\n后来当它被国际标准化组织（International Organization for Standardization, ISO）定为国际标准后，仅仅128个符号编码就不够用了，因为在其他的拉丁文字字母中还可能存在注音符号，这时就无法用基础 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。此时把8位二进制编码的字符码称为**[扩展ASCII](https://baike.baidu.com/item/扩展ASCII)码**。\n\n\n\n## Unicode\n\n我们知道ASCII码最多支持256位字符，用来表示其他语言是完全不够的，亚洲国家的文字中，汉字就多达10万左右。因此出现了多种编码格式，例如GB类的中文编码。当通过多种编码方案解决了多语言的字符显示问题之后，又出现了新的问题：乱码。\n\n我们都知道计算机内部只存储二进制数据，当我们进行通信时，发送者需要将文字编码成一串二进制比特流进行传输通信，而接收者需要使用同一套编码规则进行解码，才能获取到正确的信息。但是如果通信双方使用不同的编码规则，例如发送者使用单字节编码（规定每8位为一个字符码），而接收者使用双字节解码（规定每16位为一个字符码），或者接收者同样使用单字节编码，但是其对应的不是同一个字符，就会出现乱码。\n\n于是Unicode就出现了。Unicode把所有语言都统一到一套编码里，每个字符在Unicode中只有唯一的字符码。\n\n## Unicode标准\n\nUnicode标准定义 **一个字符代表一个code，不存在二义性**，例如`U+0041`总是代表`'A'`，而且这套标准也会随着需求不断的拓展。\n\n实质上Unicode只是一个字符集，里面是定义了所有字符和二进制code的对应关系，但是并没有真正实现字符集的编码。而UTF-8，UTF-16，UTF-32就是Unicode的不同实现。\n\n## UTF-8\n\nUTF-8 是在互联网上使用最广的一种 Unicode 的实现方式之一。UTF-8 最大的一个特点，就是它是一种变长的编码方式，根据不同的Unicode字符，使用不同数量的字节编码。因为如果采用单字节编码方式，是不够的，而如果采用多字节编码，那么对于小序的字符来说，会在前面填充非常多的0，非常浪费空间。所以用一种可变的方式，既可以有效的利用空间，又可以包含更多数量的字符。\n\n\n\n> UTF-8 的编码规则很简单，只有二条：\n>\n> 1）对于单字节的符号，字节的第一位设为`0`，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。\n>\n> 2）对于`n`字节的符号（`n > 1`），第一个字节的前`n`位都设为`1`，第`n + 1`位设为`0`，后面字节的前两位一律设为`10`。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。\n>\n> 下表总结了编码规则，字母`x`表示可用编码的位。\n>\n> ```\n> Unicode符号范围     |        UTF-8编码方式\n> (十六进制)          |         （二进制）\n> ----------------------+---------------------------------------------\n> 0000 0000-0000 007F | 0xxxxxxx\n> 0000 0080-0000 07FF | 110xxxxx 10xxxxxx\n> 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx\n> 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n> ```\n\n\n\n## UTF-16\n\nUnicode编码中，最常用的字符其实是`0-65535`，因此针对这点产生了UTF-16方案。\n\nUTF-16编码以16位无符号整数为单位，将0–65535范围内的字符编码成2个字节，超过这个的用4个字节编码。UTF16编码是Unicode最直接的实现方式，通常我们在windows上新建文本文件后保存为Unicode编码，其实就是保存为UTF16编码。\n\n\n\n## UTF-32\n\nUTF-32是Unicode的一种实现方式. UTF32编码使用固定的4个字节来存储。 因此,非常浪费空间,不利于网络传输,所以使用不普遍。\n\n\n\n# 字体文件\n\n## 常见的字体文件格式\n\n我们知道，字体分为点阵字体和矢量字体。\n\n对于纯点阵字体，其常见的字体格式包括： bdf，pcf，fnt，hbf 。\n\n对于矢量字体，其常见的格式包括**Type1**，**TrueType（ttf）**和**OpenType（otf / ttf）**。\n\n\n\n简单介绍一下矢量字体中各个格式之间的的区别：\n\n- **Type1**：全称**PostScript Type1**，是1985年由Adobe公司提出的一套矢量字体标准，使用贝塞尔曲线描述字形，称为**PostScript曲线**。是非开放字体，使用需要收费。\n\n- **TrueType**：TrueType是1991年由苹果（Apple）公司与 微软（Microsoft）公司联合提出另一套矢量字标准。虽然与Type1都是使用贝塞尔曲线描述字体轮廓，但是**Type1**使用三次贝塞尔曲线来描述字形，而TrueType使用的是二次贝塞尔曲线（**TrueType曲线**）。**TrueType 曲线**可接受典型的 hinting，可告知栅格化引擎在栅格化之前应该如何把轮廓扭曲，这样可精确控制字体的抗锯齿结果。\n\n- **Opentype**：是1995年由微软（Microsoft）和 Adobe公司开发的另外一种字体格式 ，基于TrueType扩展，内部兼容了**TrueType 曲线**和 **PostScript 曲线**。并且真正支持 **Unicode**的字体，最多可以支持 65535 个码位。其后缀名可以是ttf或者otf。仅包含**TrueType 曲线**，其后缀名一般是**ttf**，包含有 **PostScript 曲线**的，后缀名则是**otf**。\n\n\n\n而目前常见的用于web的字体格式，除了主流的otf 和 ttf之外，还包括了**WOFF** 和 **SVG**。\n\n> - **WOFF**：WOFF (Web Open Font Format) 本质上是 metadata + 基于 SFNT 的字体（如 TTF、OTF 或其他开放字体格式）。该格式完全是为了 Web 而创建，由 Mozilla 基金会、微软和 Opera 软件公司合作推出。 WOFF 字体均经过 WOFF 的编码工具压缩，文件大小一般比 TTF 小 40%，加载速度更快，可以更好的嵌入网页中。metadata 允许在字体文件中包含许可数据，以解决版权问题。这是万维网联盟提（qing）倡（ding）的，所以毫无疑问的是字体格式的未来。**目前主流的浏览器的新版本几乎都支持 WOFF。**\n>\n> - **SVG**：SVG (Scalable Vector Graphics font) 字体格式使用 SVG 的字体元素定义。这些字体包含作为标准 SVG 元素和属性的字形轮廓，就像它们是 SVG 映像中的单个矢量对象一样。SVG 字体最大的缺点是缺少字体提示（font-hinting）。字体提示是渲染小字体时为了质量和清晰度额外嵌入的信息。同时，SVG 对文本（body text）支持并不是特别好。因为 SVG 的文本选择（text selection）目前在 Safari、Safari Mobile 和 Chrome 的一些版本上完全崩坏，所以你不能选择单个字符、单词或任何自定义选项，你只能选择整行或段落文本。\n\n\n\n\n\n## TrueType 字体\n\n目前最常使用的主流字体格式还是**ttf**。所以简单了解一下**TrueType** 字体文件结构。\n\n**TrueType** 字体是一个矢量字体格式。对于矢量字体来说，要准确绘制一个字体，其文件中需要存储其图元轮廓的定义，字符代码与图元的映射等信息。所以在**TrueType**字体文件中，存储了多张表格，不同的表格包含了与字体相关的不同信息，下表包含了部分表格说明：\n\n| 表名 | 说明                    | 说明                                                         |\n| ---- | ----------------------- | ------------------------------------------------------------ |\n| head | 字体头                  | 字体的全局信息                                               |\n| cmap | 字符代码到图元的映射    | 把字符代码映射为图元索引                                     |\n| glyf | 图元数据                | 图元轮廓定义以及网格调整指令                                 |\n| maxp | 最大需求表              | 字体中所需内存分配情况的汇总数据                             |\n| mmtx | 水平规格                | 图元水平规格                                                 |\n| loca | 位置表索引              | 把元索引转换为图元的位置                                     |\n| name | 命名表                  | 版权说明、字体名、字体族名、风格名等等                       |\n| hmtx | 水平布局                | 字体水平布局星系：上高、下高、行间距、最大前进宽度、最小左支撑、最小右支撑 |\n| kerm | 字距调整表              | 字距调整对的数组                                             |\n| post | PostScript信息          | 所有图元的PostScript  FontInfo目录项和PostScript名           |\n| PCLT | PCL  5数据              | HP  PCL  5Printer  Language  的字体信息：字体数、宽度、x高度、风格、记号集等等 |\n| hhea | mac下渲染数据           | 水平布局排列字符的字体所需的信息                             |\n| OS/2 | OS/2和Windows特有的规格 | TrueType字体所需的规格集                                     |\n\n其中对于文本的排版布局来说，有几个参数比较重要：\n\n- head表中的`unitsPerEm`字段代表字形中UPM值\n\n- hhea表中的`ascent` 、`descent` 和`line gap` 字段常用于Mac OS下的字体渲染。\n- OS/2表中\n  - 用于window字体渲染\n    - `usWinAscent`\n    - `usWinDescent`\n  - 用于印刷\n    - `sTypoAscender`\n    - `sTypoDescender`\n    - `sTypoLineGap`\n    - `sCapHeight`\n    - `sxHeight`\n\n\n\n这些参数主要用于排版布局的计算。对于前端而言，在CSS行框计算中，这是最根本的依据。但是这些参数究竟代表了什么含义呢？在这里做一个简单的介绍。\n\n## em square (UPM)\n\nem框，也叫做upm（units per em）。在字体设计中，一个字符图形需要设计到在一个框内，这个框我们称之为em框。em框的概念最早来自印刷。\n\n> 在传统的金属字模中，每个字符被放置在一个统一大小的金属块中，每个字符的高度是统一的，这样每个字模可以整齐地放进行和块中（如下）。\n>\n> 字模的高度被称为`em`，起源于大写的字符“M”的宽度；这个字母的比例被做成了方形（因此有了“EM Square”的称呼）。\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d25914fc3d464f618a3c0f74c731f876~tplv-k3u1fbpfcp-zoom-1.image)\n\nem size是根据字模计算出的点值。是字符占用空间的数字化定义总量，通常指代高度，表示当前字体的字符在设计时的单位量。在OpenType字体中，UPM或em大小通常是1000单位。在TrueType字体中，UPM约定是2的幂，通常是1024或2048。而我们设置字号大小，实际上是在设置em框，从而实现缩放字符的效果。\n\n下图的字体是在1000单位的em框中设计，其中这个 `H` 字符在设计时总高度为700单位，占整个框高度的 7/10，那么当给这个字符设置10px时，其实是规定了em的大小为10px，那么此时 `H` 的实际高度就是7px：\n$$\n7 / 10 * 10  = 7\n$$\n\n\n<div style=\"text-align: center;margin-top: 50px;\">\n  <img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92d57fb265eb49d4b34fa0b5a4b160a4~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"20200804180415\" style=\"zoom:50%;\" /></div>\n\n\n## font Metrics\n\n简单来说，**字体度量（Font Metrics）**就是描述一个字体的一系列参数，用于计算机解析渲染字体。在设计一套字体时，可以对这些参数进行自定义设置从而实现自定义字体设计。这些参数包含了一个字体中各个字形的轮廓参数，字符的大小，样式设置，以及该字体中字符与字符间的排布等，可以通过[glossary](https://www.fontshop.com/glossary) 来了解相关的设计参数信息与含义。\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c8976e9e2e1404ea228b9790156f9b9~tplv-k3u1fbpfcp-zoom-1.image)\n\n而这一些系列的参数中，重点介绍一下与字符排布相关的参数（这些参数都是以英文字符为参考对象）：\n\n| 参数               | 定义                                                         |\n| ------------------ | ------------------------------------------------------------ |\n| baseline           | 是文字绘制时所参照的基准线，所有的文字以此为基准位置进行设计。 |\n| x-height           | 小写字母的高度，以x为例                                      |\n| capital height     | 基线到大写字母顶部到高度                                     |\n| ascent             | 小写字母中延伸到 x-height以上的部分                          |\n| descent            | 小写字母中延伸到 x-height以下 的部分                         |\n| leading / line gap | 从基线到基线的文本行之间的垂直间隔                           |\n| midline            | 位于小写字母的主体之上，基线和中线之间的距离是x-height       |\n| spacing            | 字间距                                                       |\n\n通过一张图来了解这些参数（图源网络）：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1133390d7ac403ab6fec921cd1752a7~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n\n\n\n\n\n\n\n\n\n# 参考\n\n[参数化设计与字体战争：从 OpenType 1.8 说起](https://www.thetype.com/2016/09/10968/)\n\n[一笔一划间蕴藏的学问 浅谈计算机字体](https://pcedu.pconline.com.cn/teach/xt/1205/2783057_all.html)\n\n[对计算机字体渲染的一些研究](https://xuchen.wang/archives/fonts.html)\n\n[A Closer Look At Font Rendering](https://www.smashingmagazine.com/2012/04/a-closer-look-at-font-rendering/)\n\n[Font smoothing, anti-aliasing, and sub-pixel rendering](https://www.joelonsoftware.com/2007/06/12/font-smoothing-anti-aliasing-and-sub-pixel-rendering/)\n[Antialiasing 101](https://www.html5rocks.com/zh/tutorials/internals/antialiasing-101/)\n\n[十分钟搞清字符集和字符编码](http://cenalulu.github.io/linux/character-encoding/)\n \n[The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets](https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/)\n\n[百度百科：ASCII](https://baike.baidu.com/item/ASCII)\n\n[百度百科：Unicode](https://baike.baidu.com/item/Unicode)\n\n[字符编码笔记：ASCII，Unicode 和 UTF-8](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)\n[【字符编码系列】常用的几种字符编码(GBK，UTF-8，UTF-16)](https://dailc.github.io/2017/05/17/severalCommonlyCharEncoding.html)\n[TrueType](https://developer.apple.com/fonts/TrueType-Reference-Manual/)\n[Web 字体简介: TTF, OTF, WOFF, EOT & SVG](https://zhuanlan.zhihu.com/p/28179203)\n[字体生成小记](http://www.shushilvshe.com/data/font-build.html)\n[ttf文件结构解析](https://www.cnblogs.com/sjhrun2001/archive/2010/01/19/1651274.html)\n\n[Typr.js](https://photopea.github.io/Typr.js/)\n\n","slug":"浅谈计算机字体","published":1,"updated":"2023-03-03T09:48:03.147Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clesk19gq0008dddf3r0l7kcm","content":"<h1 id=\"计算机字体简介\"><a href=\"#计算机字体简介\" class=\"headerlink\" title=\"计算机字体简介\"></a>计算机字体简介</h1><h2 id=\"字体分类\"><a href=\"#字体分类\" class=\"headerlink\" title=\"字体分类\"></a>字体分类</h2><h2 id=\"点阵字体\"><a href=\"#点阵字体\" class=\"headerlink\" title=\"点阵字体\"></a>点阵字体</h2><p>点阵字体是指每一个字符都按照16×16或24×24的尺寸设置，在设定好的尺寸内，通过每个像素点的虚实来表示字符的轮廓。点阵字体也叫<strong>位图字体</strong>，其中每个字形都以一组二维像素信息表示。</p>\n<p>因为是预先设计好然后直接输出，当字符进行动态的放大缩小时，是无法清晰的显示字形轮廓，所以点阵字体只在预设好的字号下能清晰显示，有时候不同的字号甚至可能显示成完全不同的字体，例如（图片出处：<a href=\"https://xuchen.wang/archives/fonts.html\">对计算机字体渲染的一些研究</a>）：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b543e25616774f4395ffe52440d961eb~tplv-k3u1fbpfcp-zoom-1.image\"><br><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95709cb05db540918c68bc2393d1c834~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<h2 id=\"矢量字体\"><a href=\"#矢量字体\" class=\"headerlink\" title=\"矢量字体\"></a>矢量字体</h2><p>矢量字体又叫做轮廓字体(Outline Fonts)，是利用贝塞尔曲线来描述字形轮廓，当使用该字体时，计算机根据曲线进行实时计算渲染，从而保证了当字体进行任意大小缩放时，字符都能清晰显示。</p>\n<h2 id=\"渲染技术\"><a href=\"#渲染技术\" class=\"headerlink\" title=\"渲染技术\"></a>渲染技术</h2><p>无论是点阵字体还是矢量字体，在计算机中，其本质都是栅格化（Rasterization）图像。对于计算机而言，其最小操作单元就是一个个像素栅格。如何使用一定数量的像素栅格去准确描绘理想的字体形状，就是需要解决的问题。</p>\n<h2 id=\"黑白渲染（Black-and-white-rendering）\"><a href=\"#黑白渲染（Black-and-white-rendering）\" class=\"headerlink\" title=\"黑白渲染（Black and white rendering）\"></a>黑白渲染（Black and white rendering）</h2><p>黑白渲染又叫做二值渲染（bi-level rendering）。黑白渲染是最早人们使用的渲染技术，这种渲染方式只使用黑白两种颜色来表达文字的形状。目前打印机就仍在使用这种方法，由于打印机的高输出分辨率，打印的结果能很好地再现原图。但是由于屏幕的分辨率较低，在这种渲染方式下，放大字体可能就会看到一些锯齿。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/132cb451161343ff9e499d6127457c04~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<h2 id=\"灰度渲染（Grayscale-rendering）\"><a href=\"#灰度渲染（Grayscale-rendering）\" class=\"headerlink\" title=\"灰度渲染（Grayscale rendering）\"></a>灰度渲染（Grayscale rendering）</h2><p>灰度渲染实际上是计算机图形学中的一种<strong>反锯齿（Anti-Aliasing）</strong>技术，通过在锯齿边缘增加一些灰阶像素，从而平滑字体轮廓。它的灰度值取决于理想的字型在此像素所覆盖的面积比例。该技术的原理与照片重新采样（resampled）到一个较低分辨率时的原理是相同的，人眼在识别图像时，由于图像的边界不明显，大脑会将其与周围的像素理解为一个整体。 因此我们的眼睛和大脑在理解灰色像素所包含的信息时，会将它转换为字型的轮廓，这就让我们可以获得与原始设计极为接近的渲染效果。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b676f63f1e254af4bddb0f271e4da1c2~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<h2 id=\"亚像素渲染（Subpixel-rendering）\"><a href=\"#亚像素渲染（Subpixel-rendering）\" class=\"headerlink\" title=\"亚像素渲染（Subpixel rendering）\"></a>亚像素渲染（Subpixel rendering）</h2><p>亚像素渲染实际上是灰度渲染的进阶版。这种技术的出现主要得益于硬件的提升。传统CRT显示器最小控制单元是像素，是由相邻的红、绿、蓝荧光粉单元各一个为一组组成。LCD液晶显示屏也是由红、绿、蓝三个子（亚）像素构成的，它们共同决定了这一像素的颜色和亮度，但LCD能够做到单独控制每一个子像素。因为这些子像素非常小，以至于人眼无法察觉到他们是一个个独立的颜色点。与单纯的灰度渲染相比，水平方向的分辨率翻了三倍。</p>\n<p>将亚像素渲染与灰度渲染对比可以发现，视觉上来说亚像素的边缘会更平滑：</p>\n<div style=\"text-align: center\"><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddfb377e5b2940b8a59af7e3cc7b9a94~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"20200804180415\" style=\"zoom:50%;\" /></div>\n\n\n<p>我们将这个像素细化到亚像素并转为灰度模式可以会有更直观的感受，原有的一个灰阶像素变成了三个灰阶亚像素，整个边缘进行了更加平滑的过渡：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a4fb6f747ee4b78b983e68bfa026d46~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<h1 id=\"字符编码\"><a href=\"#字符编码\" class=\"headerlink\" title=\"字符编码\"></a>字符编码</h1><p>文字，是一个可以被人类识别的图形化符号，本质是图形，在计算机我们称之为图元。但是文字是人类文明的产物，计算机并不认识。但是对于计算机而言，它只会认识由0、1组成的二进制值，所以为了让计算机识别一段文字，需要让文字与二进制值之间进行相互转化，这个过程就是编码与解码的过程。</p>\n<p>在计算机中存在着多种编码格式，包括ASCII编码、GB类的中文编码以及Unicode编码等，关于中文字符编码，可以查看<a href=\"https://zhuanlan.zhihu.com/p/46216008\">这篇文章</a>，本文就不做介绍，只是简单介绍一下ASCII编码和Unicode编码。</p>\n<h2 id=\"ASCII编码\"><a href=\"#ASCII编码\" class=\"headerlink\" title=\"ASCII编码\"></a>ASCII编码</h2><p>ASCII码是是上个世纪60年代美国信息交换标准代码是由美国国家标准学会(American National Standard Institute , ANSI )制定的，是一种标准的<strong>单字节</strong>字符<a href=\"https://baike.baidu.com/item/%E7%BC%96%E7%A0%81\">编码</a>方案，用于基于<a href=\"https://baike.baidu.com/item/%E6%96%87%E6%9C%AC\">文本</a>的数据，对英语字符与二进制位之间的关系，做了统一规定。</p>\n<p>ASCII规定，用8位二进制（1byte，8bit）来存储字符和特殊符号，总共可以表示256个字符。（因为英文字符总共才26个，加上特殊字符，8bit绰绰有余）。</p>\n<p>早期只针对英文编码，是使用7 位二进制数（剩下的1位二进制为0）来表示所有的大写和小写字母，数字0 到9、标点符号，以及在美式英语中使用的特殊控制字符。此时7位的叫做<a href=\"http://ascii.911cha.com/\">标准ASCII码</a>也叫<strong>基础ASCII码</strong>。</p>\n<p>后来当它被国际标准化组织（International Organization for Standardization, ISO）定为国际标准后，仅仅128个符号编码就不够用了，因为在其他的拉丁文字字母中还可能存在注音符号，这时就无法用基础 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。此时把8位二进制编码的字符码称为**<a href=\"https://baike.baidu.com/item/%E6%89%A9%E5%B1%95ASCII\">扩展ASCII</a>码**。</p>\n<h2 id=\"Unicode\"><a href=\"#Unicode\" class=\"headerlink\" title=\"Unicode\"></a>Unicode</h2><p>我们知道ASCII码最多支持256位字符，用来表示其他语言是完全不够的，亚洲国家的文字中，汉字就多达10万左右。因此出现了多种编码格式，例如GB类的中文编码。当通过多种编码方案解决了多语言的字符显示问题之后，又出现了新的问题：乱码。</p>\n<p>我们都知道计算机内部只存储二进制数据，当我们进行通信时，发送者需要将文字编码成一串二进制比特流进行传输通信，而接收者需要使用同一套编码规则进行解码，才能获取到正确的信息。但是如果通信双方使用不同的编码规则，例如发送者使用单字节编码（规定每8位为一个字符码），而接收者使用双字节解码（规定每16位为一个字符码），或者接收者同样使用单字节编码，但是其对应的不是同一个字符，就会出现乱码。</p>\n<p>于是Unicode就出现了。Unicode把所有语言都统一到一套编码里，每个字符在Unicode中只有唯一的字符码。</p>\n<h2 id=\"Unicode标准\"><a href=\"#Unicode标准\" class=\"headerlink\" title=\"Unicode标准\"></a>Unicode标准</h2><p>Unicode标准定义 <strong>一个字符代表一个code，不存在二义性</strong>，例如<code>U+0041</code>总是代表<code>&#39;A&#39;</code>，而且这套标准也会随着需求不断的拓展。</p>\n<p>实质上Unicode只是一个字符集，里面是定义了所有字符和二进制code的对应关系，但是并没有真正实现字符集的编码。而UTF-8，UTF-16，UTF-32就是Unicode的不同实现。</p>\n<h2 id=\"UTF-8\"><a href=\"#UTF-8\" class=\"headerlink\" title=\"UTF-8\"></a>UTF-8</h2><p>UTF-8 是在互联网上使用最广的一种 Unicode 的实现方式之一。UTF-8 最大的一个特点，就是它是一种变长的编码方式，根据不同的Unicode字符，使用不同数量的字节编码。因为如果采用单字节编码方式，是不够的，而如果采用多字节编码，那么对于小序的字符来说，会在前面填充非常多的0，非常浪费空间。所以用一种可变的方式，既可以有效的利用空间，又可以包含更多数量的字符。</p>\n<blockquote>\n<p>UTF-8 的编码规则很简单，只有二条：</p>\n<p>1）对于单字节的符号，字节的第一位设为<code>0</code>，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</p>\n<p>2）对于<code>n</code>字节的符号（<code>n &gt; 1</code>），第一个字节的前<code>n</code>位都设为<code>1</code>，第<code>n + 1</code>位设为<code>0</code>，后面字节的前两位一律设为<code>10</code>。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</p>\n<p>下表总结了编码规则，字母<code>x</code>表示可用编码的位。</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asciidoc\">Unicode符号范围     |        UTF-8编码方式<br><span class=\"hljs-section\">(十六进制)          |         （二进制）</span><br><span class=\"hljs-section\">----------------------+---------------------------------------------</span><br>0000 0000-0000 007F | 0xxxxxxx<br>0000 0080-0000 07FF | 110xxxxx 10xxxxxx<br>0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx<br>0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"UTF-16\"><a href=\"#UTF-16\" class=\"headerlink\" title=\"UTF-16\"></a>UTF-16</h2><p>Unicode编码中，最常用的字符其实是<code>0-65535</code>，因此针对这点产生了UTF-16方案。</p>\n<p>UTF-16编码以16位无符号整数为单位，将0–65535范围内的字符编码成2个字节，超过这个的用4个字节编码。UTF16编码是Unicode最直接的实现方式，通常我们在windows上新建文本文件后保存为Unicode编码，其实就是保存为UTF16编码。</p>\n<h2 id=\"UTF-32\"><a href=\"#UTF-32\" class=\"headerlink\" title=\"UTF-32\"></a>UTF-32</h2><p>UTF-32是Unicode的一种实现方式. UTF32编码使用固定的4个字节来存储。 因此,非常浪费空间,不利于网络传输,所以使用不普遍。</p>\n<h1 id=\"字体文件\"><a href=\"#字体文件\" class=\"headerlink\" title=\"字体文件\"></a>字体文件</h1><h2 id=\"常见的字体文件格式\"><a href=\"#常见的字体文件格式\" class=\"headerlink\" title=\"常见的字体文件格式\"></a>常见的字体文件格式</h2><p>我们知道，字体分为点阵字体和矢量字体。</p>\n<p>对于纯点阵字体，其常见的字体格式包括： bdf，pcf，fnt，hbf 。</p>\n<p>对于矢量字体，其常见的格式包括<strong>Type1</strong>，<strong>TrueType（ttf）</strong>和<strong>OpenType（otf / ttf）</strong>。</p>\n<p>简单介绍一下矢量字体中各个格式之间的的区别：</p>\n<ul>\n<li><p><strong>Type1</strong>：全称<strong>PostScript Type1</strong>，是1985年由Adobe公司提出的一套矢量字体标准，使用贝塞尔曲线描述字形，称为<strong>PostScript曲线</strong>。是非开放字体，使用需要收费。</p>\n</li>\n<li><p><strong>TrueType</strong>：TrueType是1991年由苹果（Apple）公司与 微软（Microsoft）公司联合提出另一套矢量字标准。虽然与Type1都是使用贝塞尔曲线描述字体轮廓，但是<strong>Type1</strong>使用三次贝塞尔曲线来描述字形，而TrueType使用的是二次贝塞尔曲线（<strong>TrueType曲线</strong>）。<strong>TrueType 曲线</strong>可接受典型的 hinting，可告知栅格化引擎在栅格化之前应该如何把轮廓扭曲，这样可精确控制字体的抗锯齿结果。</p>\n</li>\n<li><p><strong>Opentype</strong>：是1995年由微软（Microsoft）和 Adobe公司开发的另外一种字体格式 ，基于TrueType扩展，内部兼容了<strong>TrueType 曲线</strong>和 <strong>PostScript 曲线</strong>。并且真正支持 <strong>Unicode</strong>的字体，最多可以支持 65535 个码位。其后缀名可以是ttf或者otf。仅包含<strong>TrueType 曲线</strong>，其后缀名一般是<strong>ttf</strong>，包含有 <strong>PostScript 曲线</strong>的，后缀名则是<strong>otf</strong>。</p>\n</li>\n</ul>\n<p>而目前常见的用于web的字体格式，除了主流的otf 和 ttf之外，还包括了<strong>WOFF</strong> 和 <strong>SVG</strong>。</p>\n<blockquote>\n<ul>\n<li><p><strong>WOFF</strong>：WOFF (Web Open Font Format) 本质上是 metadata + 基于 SFNT 的字体（如 TTF、OTF 或其他开放字体格式）。该格式完全是为了 Web 而创建，由 Mozilla 基金会、微软和 Opera 软件公司合作推出。 WOFF 字体均经过 WOFF 的编码工具压缩，文件大小一般比 TTF 小 40%，加载速度更快，可以更好的嵌入网页中。metadata 允许在字体文件中包含许可数据，以解决版权问题。这是万维网联盟提（qing）倡（ding）的，所以毫无疑问的是字体格式的未来。<strong>目前主流的浏览器的新版本几乎都支持 WOFF。</strong></p>\n</li>\n<li><p><strong>SVG</strong>：SVG (Scalable Vector Graphics font) 字体格式使用 SVG 的字体元素定义。这些字体包含作为标准 SVG 元素和属性的字形轮廓，就像它们是 SVG 映像中的单个矢量对象一样。SVG 字体最大的缺点是缺少字体提示（font-hinting）。字体提示是渲染小字体时为了质量和清晰度额外嵌入的信息。同时，SVG 对文本（body text）支持并不是特别好。因为 SVG 的文本选择（text selection）目前在 Safari、Safari Mobile 和 Chrome 的一些版本上完全崩坏，所以你不能选择单个字符、单词或任何自定义选项，你只能选择整行或段落文本。</p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"TrueType-字体\"><a href=\"#TrueType-字体\" class=\"headerlink\" title=\"TrueType 字体\"></a>TrueType 字体</h2><p>目前最常使用的主流字体格式还是<strong>ttf</strong>。所以简单了解一下<strong>TrueType</strong> 字体文件结构。</p>\n<p><strong>TrueType</strong> 字体是一个矢量字体格式。对于矢量字体来说，要准确绘制一个字体，其文件中需要存储其图元轮廓的定义，字符代码与图元的映射等信息。所以在<strong>TrueType</strong>字体文件中，存储了多张表格，不同的表格包含了与字体相关的不同信息，下表包含了部分表格说明：</p>\n<table>\n<thead>\n<tr>\n<th>表名</th>\n<th>说明</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>head</td>\n<td>字体头</td>\n<td>字体的全局信息</td>\n</tr>\n<tr>\n<td>cmap</td>\n<td>字符代码到图元的映射</td>\n<td>把字符代码映射为图元索引</td>\n</tr>\n<tr>\n<td>glyf</td>\n<td>图元数据</td>\n<td>图元轮廓定义以及网格调整指令</td>\n</tr>\n<tr>\n<td>maxp</td>\n<td>最大需求表</td>\n<td>字体中所需内存分配情况的汇总数据</td>\n</tr>\n<tr>\n<td>mmtx</td>\n<td>水平规格</td>\n<td>图元水平规格</td>\n</tr>\n<tr>\n<td>loca</td>\n<td>位置表索引</td>\n<td>把元索引转换为图元的位置</td>\n</tr>\n<tr>\n<td>name</td>\n<td>命名表</td>\n<td>版权说明、字体名、字体族名、风格名等等</td>\n</tr>\n<tr>\n<td>hmtx</td>\n<td>水平布局</td>\n<td>字体水平布局星系：上高、下高、行间距、最大前进宽度、最小左支撑、最小右支撑</td>\n</tr>\n<tr>\n<td>kerm</td>\n<td>字距调整表</td>\n<td>字距调整对的数组</td>\n</tr>\n<tr>\n<td>post</td>\n<td>PostScript信息</td>\n<td>所有图元的PostScript  FontInfo目录项和PostScript名</td>\n</tr>\n<tr>\n<td>PCLT</td>\n<td>PCL  5数据</td>\n<td>HP  PCL  5Printer  Language  的字体信息：字体数、宽度、x高度、风格、记号集等等</td>\n</tr>\n<tr>\n<td>hhea</td>\n<td>mac下渲染数据</td>\n<td>水平布局排列字符的字体所需的信息</td>\n</tr>\n<tr>\n<td>OS/2</td>\n<td>OS/2和Windows特有的规格</td>\n<td>TrueType字体所需的规格集</td>\n</tr>\n</tbody></table>\n<p>其中对于文本的排版布局来说，有几个参数比较重要：</p>\n<ul>\n<li><p>head表中的<code>unitsPerEm</code>字段代表字形中UPM值</p>\n</li>\n<li><p>hhea表中的<code>ascent</code> 、<code>descent</code> 和<code>line gap</code> 字段常用于Mac OS下的字体渲染。</p>\n</li>\n<li><p>OS/2表中</p>\n<ul>\n<li>用于window字体渲染<ul>\n<li><code>usWinAscent</code></li>\n<li><code>usWinDescent</code></li>\n</ul>\n</li>\n<li>用于印刷<ul>\n<li><code>sTypoAscender</code></li>\n<li><code>sTypoDescender</code></li>\n<li><code>sTypoLineGap</code></li>\n<li><code>sCapHeight</code></li>\n<li><code>sxHeight</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>这些参数主要用于排版布局的计算。对于前端而言，在CSS行框计算中，这是最根本的依据。但是这些参数究竟代表了什么含义呢？在这里做一个简单的介绍。</p>\n<h2 id=\"em-square-UPM\"><a href=\"#em-square-UPM\" class=\"headerlink\" title=\"em square (UPM)\"></a>em square (UPM)</h2><p>em框，也叫做upm（units per em）。在字体设计中，一个字符图形需要设计到在一个框内，这个框我们称之为em框。em框的概念最早来自印刷。</p>\n<blockquote>\n<p>在传统的金属字模中，每个字符被放置在一个统一大小的金属块中，每个字符的高度是统一的，这样每个字模可以整齐地放进行和块中（如下）。</p>\n<p>字模的高度被称为<code>em</code>，起源于大写的字符“M”的宽度；这个字母的比例被做成了方形（因此有了“EM Square”的称呼）。</p>\n</blockquote>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d25914fc3d464f618a3c0f74c731f876~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>em size是根据字模计算出的点值。是字符占用空间的数字化定义总量，通常指代高度，表示当前字体的字符在设计时的单位量。在OpenType字体中，UPM或em大小通常是1000单位。在TrueType字体中，UPM约定是2的幂，通常是1024或2048。而我们设置字号大小，实际上是在设置em框，从而实现缩放字符的效果。</p>\n<p>下图的字体是在1000单位的em框中设计，其中这个 <code>H</code> 字符在设计时总高度为700单位，占整个框高度的 7/10，那么当给这个字符设置10px时，其实是规定了em的大小为10px，那么此时 <code>H</code> 的实际高度就是7px：<br>$$<br>7 / 10 * 10  = 7<br>$$</p>\n<div style=\"text-align: center;margin-top: 50px;\">\n  <img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92d57fb265eb49d4b34fa0b5a4b160a4~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"20200804180415\" style=\"zoom:50%;\" /></div>\n\n\n<h2 id=\"font-Metrics\"><a href=\"#font-Metrics\" class=\"headerlink\" title=\"font Metrics\"></a>font Metrics</h2><p>简单来说，<strong>字体度量（Font Metrics）</strong>就是描述一个字体的一系列参数，用于计算机解析渲染字体。在设计一套字体时，可以对这些参数进行自定义设置从而实现自定义字体设计。这些参数包含了一个字体中各个字形的轮廓参数，字符的大小，样式设置，以及该字体中字符与字符间的排布等，可以通过<a href=\"https://www.fontshop.com/glossary\">glossary</a> 来了解相关的设计参数信息与含义。<br><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c8976e9e2e1404ea228b9790156f9b9~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>而这一些系列的参数中，重点介绍一下与字符排布相关的参数（这些参数都是以英文字符为参考对象）：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>定义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>baseline</td>\n<td>是文字绘制时所参照的基准线，所有的文字以此为基准位置进行设计。</td>\n</tr>\n<tr>\n<td>x-height</td>\n<td>小写字母的高度，以x为例</td>\n</tr>\n<tr>\n<td>capital height</td>\n<td>基线到大写字母顶部到高度</td>\n</tr>\n<tr>\n<td>ascent</td>\n<td>小写字母中延伸到 x-height以上的部分</td>\n</tr>\n<tr>\n<td>descent</td>\n<td>小写字母中延伸到 x-height以下 的部分</td>\n</tr>\n<tr>\n<td>leading / line gap</td>\n<td>从基线到基线的文本行之间的垂直间隔</td>\n</tr>\n<tr>\n<td>midline</td>\n<td>位于小写字母的主体之上，基线和中线之间的距离是x-height</td>\n</tr>\n<tr>\n<td>spacing</td>\n<td>字间距</td>\n</tr>\n</tbody></table>\n<p>通过一张图来了解这些参数（图源网络）：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1133390d7ac403ab6fec921cd1752a7~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.thetype.com/2016/09/10968/\">参数化设计与字体战争：从 OpenType 1.8 说起</a></p>\n<p><a href=\"https://pcedu.pconline.com.cn/teach/xt/1205/2783057_all.html\">一笔一划间蕴藏的学问 浅谈计算机字体</a></p>\n<p><a href=\"https://xuchen.wang/archives/fonts.html\">对计算机字体渲染的一些研究</a></p>\n<p><a href=\"https://www.smashingmagazine.com/2012/04/a-closer-look-at-font-rendering/\">A Closer Look At Font Rendering</a></p>\n<p><a href=\"https://www.joelonsoftware.com/2007/06/12/font-smoothing-anti-aliasing-and-sub-pixel-rendering/\">Font smoothing, anti-aliasing, and sub-pixel rendering</a><br><a href=\"https://www.html5rocks.com/zh/tutorials/internals/antialiasing-101/\">Antialiasing 101</a></p>\n<p><a href=\"http://cenalulu.github.io/linux/character-encoding/\">十分钟搞清字符集和字符编码</a></p>\n<p><a href=\"https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/\">The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets</a></p>\n<p><a href=\"https://baike.baidu.com/item/ASCII\">百度百科：ASCII</a></p>\n<p><a href=\"https://baike.baidu.com/item/Unicode\">百度百科：Unicode</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html\">字符编码笔记：ASCII，Unicode 和 UTF-8</a><br><a href=\"https://dailc.github.io/2017/05/17/severalCommonlyCharEncoding.html\">【字符编码系列】常用的几种字符编码(GBK，UTF-8，UTF-16)</a><br><a href=\"https://developer.apple.com/fonts/TrueType-Reference-Manual/\">TrueType</a><br><a href=\"https://zhuanlan.zhihu.com/p/28179203\">Web 字体简介: TTF, OTF, WOFF, EOT &amp; SVG</a><br><a href=\"http://www.shushilvshe.com/data/font-build.html\">字体生成小记</a><br><a href=\"https://www.cnblogs.com/sjhrun2001/archive/2010/01/19/1651274.html\">ttf文件结构解析</a></p>\n<p><a href=\"https://photopea.github.io/Typr.js/\">Typr.js</a></p>\n","site":{"data":{"languages/zh-CN":{"name":"简体中文","home":{"menu":"首页","title":"首页"},"archive":{"menu":"归档","title":"归档","subtitle":"归档","post_total":"共计 %d 篇文章"},"category":{"menu":"分类","title":"分类","subtitle":"分类","post_total":"共计 %d 篇文章","more":"More..."},"tag":{"menu":"标签","title":"标签","subtitle":"标签","post_total":"共计 %d 篇文章"},"about":{"menu":"关于","title":"关于","subtitle":"关于"},"links":{"menu":"友链","title":"友链","subtitle":"友情链接"},"page404":{"menu":"页面不存在","title":"页面不存在","subtitle":"页面不存在"},"post":{"toc":"目录","prev_post":"上一篇","next_post":"下一篇","updated":"本文最后更新于：%s","meta":{"wordcount":"%s 字","min2read":"%s 分钟","views":"{} 次"},"copyright":{"author":"作者","posted":"发布于","updated":"更新于","licensed":"许可协议","CC":"CC - 知识共享许可协议","BY":"BY - 署名","SA":"SA - 相同方式共享","NC":"NC - 非商业性使用","ND":"ND - 禁止演绎"}},"footer":{"pv":"总访问量 {} 次","uv":"总访客数 {} 人"},"search":{"title":"搜索","keyword":"关键词"},"noscript_warning":"博客在允许 JavaScript 运行的环境下浏览效果更佳"}}},"more":"<h1 id=\"计算机字体简介\"><a href=\"#计算机字体简介\" class=\"headerlink\" title=\"计算机字体简介\"></a>计算机字体简介</h1><h2 id=\"字体分类\"><a href=\"#字体分类\" class=\"headerlink\" title=\"字体分类\"></a>字体分类</h2><h2 id=\"点阵字体\"><a href=\"#点阵字体\" class=\"headerlink\" title=\"点阵字体\"></a>点阵字体</h2><p>点阵字体是指每一个字符都按照16×16或24×24的尺寸设置，在设定好的尺寸内，通过每个像素点的虚实来表示字符的轮廓。点阵字体也叫<strong>位图字体</strong>，其中每个字形都以一组二维像素信息表示。</p>\n<p>因为是预先设计好然后直接输出，当字符进行动态的放大缩小时，是无法清晰的显示字形轮廓，所以点阵字体只在预设好的字号下能清晰显示，有时候不同的字号甚至可能显示成完全不同的字体，例如（图片出处：<a href=\"https://xuchen.wang/archives/fonts.html\">对计算机字体渲染的一些研究</a>）：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b543e25616774f4395ffe52440d961eb~tplv-k3u1fbpfcp-zoom-1.image\"><br><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95709cb05db540918c68bc2393d1c834~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<h2 id=\"矢量字体\"><a href=\"#矢量字体\" class=\"headerlink\" title=\"矢量字体\"></a>矢量字体</h2><p>矢量字体又叫做轮廓字体(Outline Fonts)，是利用贝塞尔曲线来描述字形轮廓，当使用该字体时，计算机根据曲线进行实时计算渲染，从而保证了当字体进行任意大小缩放时，字符都能清晰显示。</p>\n<h2 id=\"渲染技术\"><a href=\"#渲染技术\" class=\"headerlink\" title=\"渲染技术\"></a>渲染技术</h2><p>无论是点阵字体还是矢量字体，在计算机中，其本质都是栅格化（Rasterization）图像。对于计算机而言，其最小操作单元就是一个个像素栅格。如何使用一定数量的像素栅格去准确描绘理想的字体形状，就是需要解决的问题。</p>\n<h2 id=\"黑白渲染（Black-and-white-rendering）\"><a href=\"#黑白渲染（Black-and-white-rendering）\" class=\"headerlink\" title=\"黑白渲染（Black and white rendering）\"></a>黑白渲染（Black and white rendering）</h2><p>黑白渲染又叫做二值渲染（bi-level rendering）。黑白渲染是最早人们使用的渲染技术，这种渲染方式只使用黑白两种颜色来表达文字的形状。目前打印机就仍在使用这种方法，由于打印机的高输出分辨率，打印的结果能很好地再现原图。但是由于屏幕的分辨率较低，在这种渲染方式下，放大字体可能就会看到一些锯齿。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/132cb451161343ff9e499d6127457c04~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<h2 id=\"灰度渲染（Grayscale-rendering）\"><a href=\"#灰度渲染（Grayscale-rendering）\" class=\"headerlink\" title=\"灰度渲染（Grayscale rendering）\"></a>灰度渲染（Grayscale rendering）</h2><p>灰度渲染实际上是计算机图形学中的一种<strong>反锯齿（Anti-Aliasing）</strong>技术，通过在锯齿边缘增加一些灰阶像素，从而平滑字体轮廓。它的灰度值取决于理想的字型在此像素所覆盖的面积比例。该技术的原理与照片重新采样（resampled）到一个较低分辨率时的原理是相同的，人眼在识别图像时，由于图像的边界不明显，大脑会将其与周围的像素理解为一个整体。 因此我们的眼睛和大脑在理解灰色像素所包含的信息时，会将它转换为字型的轮廓，这就让我们可以获得与原始设计极为接近的渲染效果。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b676f63f1e254af4bddb0f271e4da1c2~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<h2 id=\"亚像素渲染（Subpixel-rendering）\"><a href=\"#亚像素渲染（Subpixel-rendering）\" class=\"headerlink\" title=\"亚像素渲染（Subpixel rendering）\"></a>亚像素渲染（Subpixel rendering）</h2><p>亚像素渲染实际上是灰度渲染的进阶版。这种技术的出现主要得益于硬件的提升。传统CRT显示器最小控制单元是像素，是由相邻的红、绿、蓝荧光粉单元各一个为一组组成。LCD液晶显示屏也是由红、绿、蓝三个子（亚）像素构成的，它们共同决定了这一像素的颜色和亮度，但LCD能够做到单独控制每一个子像素。因为这些子像素非常小，以至于人眼无法察觉到他们是一个个独立的颜色点。与单纯的灰度渲染相比，水平方向的分辨率翻了三倍。</p>\n<p>将亚像素渲染与灰度渲染对比可以发现，视觉上来说亚像素的边缘会更平滑：</p>\n<div style=\"text-align: center\"><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddfb377e5b2940b8a59af7e3cc7b9a94~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"20200804180415\" style=\"zoom:50%;\" /></div>\n\n\n<p>我们将这个像素细化到亚像素并转为灰度模式可以会有更直观的感受，原有的一个灰阶像素变成了三个灰阶亚像素，整个边缘进行了更加平滑的过渡：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a4fb6f747ee4b78b983e68bfa026d46~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<h1 id=\"字符编码\"><a href=\"#字符编码\" class=\"headerlink\" title=\"字符编码\"></a>字符编码</h1><p>文字，是一个可以被人类识别的图形化符号，本质是图形，在计算机我们称之为图元。但是文字是人类文明的产物，计算机并不认识。但是对于计算机而言，它只会认识由0、1组成的二进制值，所以为了让计算机识别一段文字，需要让文字与二进制值之间进行相互转化，这个过程就是编码与解码的过程。</p>\n<p>在计算机中存在着多种编码格式，包括ASCII编码、GB类的中文编码以及Unicode编码等，关于中文字符编码，可以查看<a href=\"https://zhuanlan.zhihu.com/p/46216008\">这篇文章</a>，本文就不做介绍，只是简单介绍一下ASCII编码和Unicode编码。</p>\n<h2 id=\"ASCII编码\"><a href=\"#ASCII编码\" class=\"headerlink\" title=\"ASCII编码\"></a>ASCII编码</h2><p>ASCII码是是上个世纪60年代美国信息交换标准代码是由美国国家标准学会(American National Standard Institute , ANSI )制定的，是一种标准的<strong>单字节</strong>字符<a href=\"https://baike.baidu.com/item/%E7%BC%96%E7%A0%81\">编码</a>方案，用于基于<a href=\"https://baike.baidu.com/item/%E6%96%87%E6%9C%AC\">文本</a>的数据，对英语字符与二进制位之间的关系，做了统一规定。</p>\n<p>ASCII规定，用8位二进制（1byte，8bit）来存储字符和特殊符号，总共可以表示256个字符。（因为英文字符总共才26个，加上特殊字符，8bit绰绰有余）。</p>\n<p>早期只针对英文编码，是使用7 位二进制数（剩下的1位二进制为0）来表示所有的大写和小写字母，数字0 到9、标点符号，以及在美式英语中使用的特殊控制字符。此时7位的叫做<a href=\"http://ascii.911cha.com/\">标准ASCII码</a>也叫<strong>基础ASCII码</strong>。</p>\n<p>后来当它被国际标准化组织（International Organization for Standardization, ISO）定为国际标准后，仅仅128个符号编码就不够用了，因为在其他的拉丁文字字母中还可能存在注音符号，这时就无法用基础 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。此时把8位二进制编码的字符码称为**<a href=\"https://baike.baidu.com/item/%E6%89%A9%E5%B1%95ASCII\">扩展ASCII</a>码**。</p>\n<h2 id=\"Unicode\"><a href=\"#Unicode\" class=\"headerlink\" title=\"Unicode\"></a>Unicode</h2><p>我们知道ASCII码最多支持256位字符，用来表示其他语言是完全不够的，亚洲国家的文字中，汉字就多达10万左右。因此出现了多种编码格式，例如GB类的中文编码。当通过多种编码方案解决了多语言的字符显示问题之后，又出现了新的问题：乱码。</p>\n<p>我们都知道计算机内部只存储二进制数据，当我们进行通信时，发送者需要将文字编码成一串二进制比特流进行传输通信，而接收者需要使用同一套编码规则进行解码，才能获取到正确的信息。但是如果通信双方使用不同的编码规则，例如发送者使用单字节编码（规定每8位为一个字符码），而接收者使用双字节解码（规定每16位为一个字符码），或者接收者同样使用单字节编码，但是其对应的不是同一个字符，就会出现乱码。</p>\n<p>于是Unicode就出现了。Unicode把所有语言都统一到一套编码里，每个字符在Unicode中只有唯一的字符码。</p>\n<h2 id=\"Unicode标准\"><a href=\"#Unicode标准\" class=\"headerlink\" title=\"Unicode标准\"></a>Unicode标准</h2><p>Unicode标准定义 <strong>一个字符代表一个code，不存在二义性</strong>，例如<code>U+0041</code>总是代表<code>&#39;A&#39;</code>，而且这套标准也会随着需求不断的拓展。</p>\n<p>实质上Unicode只是一个字符集，里面是定义了所有字符和二进制code的对应关系，但是并没有真正实现字符集的编码。而UTF-8，UTF-16，UTF-32就是Unicode的不同实现。</p>\n<h2 id=\"UTF-8\"><a href=\"#UTF-8\" class=\"headerlink\" title=\"UTF-8\"></a>UTF-8</h2><p>UTF-8 是在互联网上使用最广的一种 Unicode 的实现方式之一。UTF-8 最大的一个特点，就是它是一种变长的编码方式，根据不同的Unicode字符，使用不同数量的字节编码。因为如果采用单字节编码方式，是不够的，而如果采用多字节编码，那么对于小序的字符来说，会在前面填充非常多的0，非常浪费空间。所以用一种可变的方式，既可以有效的利用空间，又可以包含更多数量的字符。</p>\n<blockquote>\n<p>UTF-8 的编码规则很简单，只有二条：</p>\n<p>1）对于单字节的符号，字节的第一位设为<code>0</code>，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</p>\n<p>2）对于<code>n</code>字节的符号（<code>n &gt; 1</code>），第一个字节的前<code>n</code>位都设为<code>1</code>，第<code>n + 1</code>位设为<code>0</code>，后面字节的前两位一律设为<code>10</code>。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</p>\n<p>下表总结了编码规则，字母<code>x</code>表示可用编码的位。</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asciidoc\">Unicode符号范围     |        UTF-8编码方式<br><span class=\"hljs-section\">(十六进制)          |         （二进制）</span><br><span class=\"hljs-section\">----------------------+---------------------------------------------</span><br>0000 0000-0000 007F | 0xxxxxxx<br>0000 0080-0000 07FF | 110xxxxx 10xxxxxx<br>0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx<br>0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"UTF-16\"><a href=\"#UTF-16\" class=\"headerlink\" title=\"UTF-16\"></a>UTF-16</h2><p>Unicode编码中，最常用的字符其实是<code>0-65535</code>，因此针对这点产生了UTF-16方案。</p>\n<p>UTF-16编码以16位无符号整数为单位，将0–65535范围内的字符编码成2个字节，超过这个的用4个字节编码。UTF16编码是Unicode最直接的实现方式，通常我们在windows上新建文本文件后保存为Unicode编码，其实就是保存为UTF16编码。</p>\n<h2 id=\"UTF-32\"><a href=\"#UTF-32\" class=\"headerlink\" title=\"UTF-32\"></a>UTF-32</h2><p>UTF-32是Unicode的一种实现方式. UTF32编码使用固定的4个字节来存储。 因此,非常浪费空间,不利于网络传输,所以使用不普遍。</p>\n<h1 id=\"字体文件\"><a href=\"#字体文件\" class=\"headerlink\" title=\"字体文件\"></a>字体文件</h1><h2 id=\"常见的字体文件格式\"><a href=\"#常见的字体文件格式\" class=\"headerlink\" title=\"常见的字体文件格式\"></a>常见的字体文件格式</h2><p>我们知道，字体分为点阵字体和矢量字体。</p>\n<p>对于纯点阵字体，其常见的字体格式包括： bdf，pcf，fnt，hbf 。</p>\n<p>对于矢量字体，其常见的格式包括<strong>Type1</strong>，<strong>TrueType（ttf）</strong>和<strong>OpenType（otf / ttf）</strong>。</p>\n<p>简单介绍一下矢量字体中各个格式之间的的区别：</p>\n<ul>\n<li><p><strong>Type1</strong>：全称<strong>PostScript Type1</strong>，是1985年由Adobe公司提出的一套矢量字体标准，使用贝塞尔曲线描述字形，称为<strong>PostScript曲线</strong>。是非开放字体，使用需要收费。</p>\n</li>\n<li><p><strong>TrueType</strong>：TrueType是1991年由苹果（Apple）公司与 微软（Microsoft）公司联合提出另一套矢量字标准。虽然与Type1都是使用贝塞尔曲线描述字体轮廓，但是<strong>Type1</strong>使用三次贝塞尔曲线来描述字形，而TrueType使用的是二次贝塞尔曲线（<strong>TrueType曲线</strong>）。<strong>TrueType 曲线</strong>可接受典型的 hinting，可告知栅格化引擎在栅格化之前应该如何把轮廓扭曲，这样可精确控制字体的抗锯齿结果。</p>\n</li>\n<li><p><strong>Opentype</strong>：是1995年由微软（Microsoft）和 Adobe公司开发的另外一种字体格式 ，基于TrueType扩展，内部兼容了<strong>TrueType 曲线</strong>和 <strong>PostScript 曲线</strong>。并且真正支持 <strong>Unicode</strong>的字体，最多可以支持 65535 个码位。其后缀名可以是ttf或者otf。仅包含<strong>TrueType 曲线</strong>，其后缀名一般是<strong>ttf</strong>，包含有 <strong>PostScript 曲线</strong>的，后缀名则是<strong>otf</strong>。</p>\n</li>\n</ul>\n<p>而目前常见的用于web的字体格式，除了主流的otf 和 ttf之外，还包括了<strong>WOFF</strong> 和 <strong>SVG</strong>。</p>\n<blockquote>\n<ul>\n<li><p><strong>WOFF</strong>：WOFF (Web Open Font Format) 本质上是 metadata + 基于 SFNT 的字体（如 TTF、OTF 或其他开放字体格式）。该格式完全是为了 Web 而创建，由 Mozilla 基金会、微软和 Opera 软件公司合作推出。 WOFF 字体均经过 WOFF 的编码工具压缩，文件大小一般比 TTF 小 40%，加载速度更快，可以更好的嵌入网页中。metadata 允许在字体文件中包含许可数据，以解决版权问题。这是万维网联盟提（qing）倡（ding）的，所以毫无疑问的是字体格式的未来。<strong>目前主流的浏览器的新版本几乎都支持 WOFF。</strong></p>\n</li>\n<li><p><strong>SVG</strong>：SVG (Scalable Vector Graphics font) 字体格式使用 SVG 的字体元素定义。这些字体包含作为标准 SVG 元素和属性的字形轮廓，就像它们是 SVG 映像中的单个矢量对象一样。SVG 字体最大的缺点是缺少字体提示（font-hinting）。字体提示是渲染小字体时为了质量和清晰度额外嵌入的信息。同时，SVG 对文本（body text）支持并不是特别好。因为 SVG 的文本选择（text selection）目前在 Safari、Safari Mobile 和 Chrome 的一些版本上完全崩坏，所以你不能选择单个字符、单词或任何自定义选项，你只能选择整行或段落文本。</p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"TrueType-字体\"><a href=\"#TrueType-字体\" class=\"headerlink\" title=\"TrueType 字体\"></a>TrueType 字体</h2><p>目前最常使用的主流字体格式还是<strong>ttf</strong>。所以简单了解一下<strong>TrueType</strong> 字体文件结构。</p>\n<p><strong>TrueType</strong> 字体是一个矢量字体格式。对于矢量字体来说，要准确绘制一个字体，其文件中需要存储其图元轮廓的定义，字符代码与图元的映射等信息。所以在<strong>TrueType</strong>字体文件中，存储了多张表格，不同的表格包含了与字体相关的不同信息，下表包含了部分表格说明：</p>\n<table>\n<thead>\n<tr>\n<th>表名</th>\n<th>说明</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>head</td>\n<td>字体头</td>\n<td>字体的全局信息</td>\n</tr>\n<tr>\n<td>cmap</td>\n<td>字符代码到图元的映射</td>\n<td>把字符代码映射为图元索引</td>\n</tr>\n<tr>\n<td>glyf</td>\n<td>图元数据</td>\n<td>图元轮廓定义以及网格调整指令</td>\n</tr>\n<tr>\n<td>maxp</td>\n<td>最大需求表</td>\n<td>字体中所需内存分配情况的汇总数据</td>\n</tr>\n<tr>\n<td>mmtx</td>\n<td>水平规格</td>\n<td>图元水平规格</td>\n</tr>\n<tr>\n<td>loca</td>\n<td>位置表索引</td>\n<td>把元索引转换为图元的位置</td>\n</tr>\n<tr>\n<td>name</td>\n<td>命名表</td>\n<td>版权说明、字体名、字体族名、风格名等等</td>\n</tr>\n<tr>\n<td>hmtx</td>\n<td>水平布局</td>\n<td>字体水平布局星系：上高、下高、行间距、最大前进宽度、最小左支撑、最小右支撑</td>\n</tr>\n<tr>\n<td>kerm</td>\n<td>字距调整表</td>\n<td>字距调整对的数组</td>\n</tr>\n<tr>\n<td>post</td>\n<td>PostScript信息</td>\n<td>所有图元的PostScript  FontInfo目录项和PostScript名</td>\n</tr>\n<tr>\n<td>PCLT</td>\n<td>PCL  5数据</td>\n<td>HP  PCL  5Printer  Language  的字体信息：字体数、宽度、x高度、风格、记号集等等</td>\n</tr>\n<tr>\n<td>hhea</td>\n<td>mac下渲染数据</td>\n<td>水平布局排列字符的字体所需的信息</td>\n</tr>\n<tr>\n<td>OS/2</td>\n<td>OS/2和Windows特有的规格</td>\n<td>TrueType字体所需的规格集</td>\n</tr>\n</tbody></table>\n<p>其中对于文本的排版布局来说，有几个参数比较重要：</p>\n<ul>\n<li><p>head表中的<code>unitsPerEm</code>字段代表字形中UPM值</p>\n</li>\n<li><p>hhea表中的<code>ascent</code> 、<code>descent</code> 和<code>line gap</code> 字段常用于Mac OS下的字体渲染。</p>\n</li>\n<li><p>OS/2表中</p>\n<ul>\n<li>用于window字体渲染<ul>\n<li><code>usWinAscent</code></li>\n<li><code>usWinDescent</code></li>\n</ul>\n</li>\n<li>用于印刷<ul>\n<li><code>sTypoAscender</code></li>\n<li><code>sTypoDescender</code></li>\n<li><code>sTypoLineGap</code></li>\n<li><code>sCapHeight</code></li>\n<li><code>sxHeight</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>这些参数主要用于排版布局的计算。对于前端而言，在CSS行框计算中，这是最根本的依据。但是这些参数究竟代表了什么含义呢？在这里做一个简单的介绍。</p>\n<h2 id=\"em-square-UPM\"><a href=\"#em-square-UPM\" class=\"headerlink\" title=\"em square (UPM)\"></a>em square (UPM)</h2><p>em框，也叫做upm（units per em）。在字体设计中，一个字符图形需要设计到在一个框内，这个框我们称之为em框。em框的概念最早来自印刷。</p>\n<blockquote>\n<p>在传统的金属字模中，每个字符被放置在一个统一大小的金属块中，每个字符的高度是统一的，这样每个字模可以整齐地放进行和块中（如下）。</p>\n<p>字模的高度被称为<code>em</code>，起源于大写的字符“M”的宽度；这个字母的比例被做成了方形（因此有了“EM Square”的称呼）。</p>\n</blockquote>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d25914fc3d464f618a3c0f74c731f876~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>em size是根据字模计算出的点值。是字符占用空间的数字化定义总量，通常指代高度，表示当前字体的字符在设计时的单位量。在OpenType字体中，UPM或em大小通常是1000单位。在TrueType字体中，UPM约定是2的幂，通常是1024或2048。而我们设置字号大小，实际上是在设置em框，从而实现缩放字符的效果。</p>\n<p>下图的字体是在1000单位的em框中设计，其中这个 <code>H</code> 字符在设计时总高度为700单位，占整个框高度的 7/10，那么当给这个字符设置10px时，其实是规定了em的大小为10px，那么此时 <code>H</code> 的实际高度就是7px：<br>$$<br>7 / 10 * 10  = 7<br>$$</p>\n<div style=\"text-align: center;margin-top: 50px;\">\n  <img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92d57fb265eb49d4b34fa0b5a4b160a4~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"20200804180415\" style=\"zoom:50%;\" /></div>\n\n\n<h2 id=\"font-Metrics\"><a href=\"#font-Metrics\" class=\"headerlink\" title=\"font Metrics\"></a>font Metrics</h2><p>简单来说，<strong>字体度量（Font Metrics）</strong>就是描述一个字体的一系列参数，用于计算机解析渲染字体。在设计一套字体时，可以对这些参数进行自定义设置从而实现自定义字体设计。这些参数包含了一个字体中各个字形的轮廓参数，字符的大小，样式设置，以及该字体中字符与字符间的排布等，可以通过<a href=\"https://www.fontshop.com/glossary\">glossary</a> 来了解相关的设计参数信息与含义。<br><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c8976e9e2e1404ea228b9790156f9b9~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>而这一些系列的参数中，重点介绍一下与字符排布相关的参数（这些参数都是以英文字符为参考对象）：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>定义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>baseline</td>\n<td>是文字绘制时所参照的基准线，所有的文字以此为基准位置进行设计。</td>\n</tr>\n<tr>\n<td>x-height</td>\n<td>小写字母的高度，以x为例</td>\n</tr>\n<tr>\n<td>capital height</td>\n<td>基线到大写字母顶部到高度</td>\n</tr>\n<tr>\n<td>ascent</td>\n<td>小写字母中延伸到 x-height以上的部分</td>\n</tr>\n<tr>\n<td>descent</td>\n<td>小写字母中延伸到 x-height以下 的部分</td>\n</tr>\n<tr>\n<td>leading / line gap</td>\n<td>从基线到基线的文本行之间的垂直间隔</td>\n</tr>\n<tr>\n<td>midline</td>\n<td>位于小写字母的主体之上，基线和中线之间的距离是x-height</td>\n</tr>\n<tr>\n<td>spacing</td>\n<td>字间距</td>\n</tr>\n</tbody></table>\n<p>通过一张图来了解这些参数（图源网络）：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1133390d7ac403ab6fec921cd1752a7~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.thetype.com/2016/09/10968/\">参数化设计与字体战争：从 OpenType 1.8 说起</a></p>\n<p><a href=\"https://pcedu.pconline.com.cn/teach/xt/1205/2783057_all.html\">一笔一划间蕴藏的学问 浅谈计算机字体</a></p>\n<p><a href=\"https://xuchen.wang/archives/fonts.html\">对计算机字体渲染的一些研究</a></p>\n<p><a href=\"https://www.smashingmagazine.com/2012/04/a-closer-look-at-font-rendering/\">A Closer Look At Font Rendering</a></p>\n<p><a href=\"https://www.joelonsoftware.com/2007/06/12/font-smoothing-anti-aliasing-and-sub-pixel-rendering/\">Font smoothing, anti-aliasing, and sub-pixel rendering</a><br><a href=\"https://www.html5rocks.com/zh/tutorials/internals/antialiasing-101/\">Antialiasing 101</a></p>\n<p><a href=\"http://cenalulu.github.io/linux/character-encoding/\">十分钟搞清字符集和字符编码</a></p>\n<p><a href=\"https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/\">The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets</a></p>\n<p><a href=\"https://baike.baidu.com/item/ASCII\">百度百科：ASCII</a></p>\n<p><a href=\"https://baike.baidu.com/item/Unicode\">百度百科：Unicode</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html\">字符编码笔记：ASCII，Unicode 和 UTF-8</a><br><a href=\"https://dailc.github.io/2017/05/17/severalCommonlyCharEncoding.html\">【字符编码系列】常用的几种字符编码(GBK，UTF-8，UTF-16)</a><br><a href=\"https://developer.apple.com/fonts/TrueType-Reference-Manual/\">TrueType</a><br><a href=\"https://zhuanlan.zhihu.com/p/28179203\">Web 字体简介: TTF, OTF, WOFF, EOT &amp; SVG</a><br><a href=\"http://www.shushilvshe.com/data/font-build.html\">字体生成小记</a><br><a href=\"https://www.cnblogs.com/sjhrun2001/archive/2010/01/19/1651274.html\">ttf文件结构解析</a></p>\n<p><a href=\"https://photopea.github.io/Typr.js/\">Typr.js</a></p>\n"},{"title":"浏览器同源策略","date":"2023-02-28T14:12:38.000Z","excerpt":"同源策略是一个重要的安全策略，它用于限制一个源（origin）的文档或者它加载的脚本如何能与另一个源的资源进行交互。非同源下的文档和脚本（JS），不能跨域获取资源。","_content":"# 同源策略\n## 什么是同源策略\n同源策略是一个重要的**安全策略**，它用于**限制**一个源（origin）的文档或者它加载的脚本如何能与另一个源的资源进行**交互**。非同源下的文档和脚本（JS），不能跨域获取资源。\n\n其中**同源**是指：\n\n- 协议相同\n- 域名相同\n- 端口相同\n\n## 为什么会存在同源策略\n\n同源策略是**浏览器**为了**保护用户信息安全**所执行的策略。1995年由 Netscape 公司引入的，目前所有的**浏览器**都执行这个策略。\n\n因为它的主要目的是为了保证用户信息安全，所以只要涉及到用户信息的获取途径都会被**限制**，这些信息获取途径包括：\n\n- 通过操作**其他网站**或者 **iframe**的 `dom` 来获取用户的表单数据\n- 通过获取`cookie`，`localstorge`，`sessionstorage`，`indexDB`等缓存信息，来获取用户信息\n- 通过发送 `ajax / fetch` 请求，来获取后端的用户信息（提交表单不受跨域限制）\n\n如果不对这些途径加以限制，就可能被恶意网站盗取用户信息。那么恶意是如何通过这几种途径获取信息的呢？举几个案例（来源于[彻底理解浏览器的跨域](https://juejin.im/post/6844903816060469262)）：\n\n\n> 一、cookie获取发送请求\n> \n> A 网站是一家银行，用户登录以后，A 网站在用户的机器上设置了一个 Cookie，包含了一些隐私信息（比如存款总额）。用户离开 A 网站以后，又去访问 B 网站，如果没有同源限制，B 网站可以读取 A 网站的 Cookie，那么隐私信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。\n> 例如\n>\n> 1. 用户登录了自己的银行页面 [http://mybank.com](http://mybank.com/)，[mybank.com](https://www.notion.so/b4dda8a6ca0b4a308ed8dd5d5f77861a) 向用户的cookie中添加用户标识。\n> 2. 用户浏览了恶意页面 [evil.com](http://evil.com/)。执行了页面中的恶意AJAX请求代码。\n> 3. 向http://mybank.com发起AJAX HTTP请求，请求会默认把http://mybank.com对应cookie也同时发送过去。\n> 4. 银行页面从发送的cookie中提取用户标识，验证用户无误，response中返回请求数据。此时数据就泄露了。\n> 5. 而且由于Ajax在后台执行，用户无法感知这一过程。\n>\n> 二、dom操作\n>\n> 1. 做一个假网站，里面用iframe嵌套一个银行网站 [mybank.com](http://mybank.com/)。\n> 2. 把iframe宽高啥的调整到页面全部，这样用户进来除了域名，别的部分和银行的网站没有任何差别。\n> 3. 这时如果用户输入账号密码，我们的主网站可以跨域访问到http://mybank.com的dom节点，就可以拿到用户的输入了，那么就完成了一次攻击\n\n\n\n所以针对这三点，浏览器做了同源限制：\n\n- 无法获取跨域缓存：`cookie` `localstorge` `indexDB` 等\n\n- 无法访问非同源网页的` DOM （iframe）`。\n- 无法向非同源地址发送 `AJAX` 请求 或 `Fetch` 请求（可以发送，但浏览器拒绝接受响应）。\n\n\n\n总结一下：\n\n同源策略实际就是浏览器为了保证用户信息安全的策略，限制只有同源的文档或者脚本才能进行交互。其中同源是指**协议**、**域名**、**端口**三点相同。通过限制用户（一般是指开发者）通过操作`dom`、获取缓存信息以及发送`ajax / fetch` 请求等方式来获取用户信息来保证用户信息安全。\n\n# 解决跨域通信\n\n我们在开发中，避免不了要跨域获取信息，其中最常见的就是发送跨域请求（`ajax / fetch`）来获取资源。那么解决跨域通信问题就成了我们的日常。根据浏览器的同源限制，我们将解决跨域通信分为2个方向：\n\n- 针对**跨域的网络请求**，需要前后端配合操作来解决，主要方法包括：\n    - CORS\n    - JSONP\n    - 服务器代理\n- 针对DOM级别的操作，我们只需要通过前端解决，主要方法包括：\n    - `postMassage`（HTML5 的 api， 允许两个窗口之间进行跨域发送消息）\n    - `document.domain`（只能用于一、二级域名都相同的情况）\n\n| 通信侧 | 方法 |\n| --- | --- |\n| 前端 | `postMassage`（HTML5 的 api， 允许两个窗口之间进行跨域发送消息）、<br />`document.domain`（只能用于一、二级域名都相同的情况） |\n| 前后端 | `CORS`、`jsonp`、服务器代理 |\n\n## CORS\n\nCORS（**跨域资源共享  Cross-origin resource sharing）**是W3C标准，它允许浏览器向跨域服务器发出请求，解决了**同源限制中AJAX 请求无法跨域**的问题。这种跨域通信解决方案不需要用户做额外的操作，是浏览器和服务器共同实现的。\n\n在浏览器端，不需要用户额外配置，当用户在浏览器发送AJAX请求（例如在js代码中发起了ajax请求），浏览器会自动处理HTTP请求，同时会对服务器端返回的响应进行拦截处理，判断该响应是否同源，进而决定是返回正常的响应还是抛出错误。\n\n而服务器则需要手动配置CORS接口，实现对跨域请求的处理。常用的**服务器CORS配置字段**如下：\n\n| 协议头参数 | 说明 | 是否必须 | 备注 |\n| ---- | ---- | -- | :-- |\n| `Access-Control-Allow-Origin` | 表示允许跨域请求的域 值为：<br />- 通配符`*`：接受任何域的跨域访问<br />`<origin>`：指定一个来源（只能指定一个）<br />`null` ：指定来源为 `null` <br />此时实际上就是不接受跨域，但是不推荐设置为该值。<br />因为浏览器在进行`CORS`判定时只会判断`Access-Control-Allow-Origin`字段是否存在而不会判断该字段的值，所以设置为`null`会导致安全问题 | T |  |\n| `Access-Control-Allow-Methods` | 服务器允许跨域请求的 `http` 方法列表 | T | 响应预检请求时，必须包含 |\n| `Access-Control-Allow-Headers` | 列出了服务器支持的所有头信息字段，<br />这些字段可以用于预检请求的`Access-Control-Request-Headers` | F | 当预请求（`OPTIONS`）中包含`Access-Control-Request-Headers`时，服务器必须设置该字段配置 |\n| `Access-Control-Allow-Credentials` | 表示是否允许发送Cookie，只有一个可选值：true（必为小写）。<br />如果不发送cookie，则直接省略，不写为false | F | CORS请求默认不发送`Cookie`和HTTP认证信息<br />要携带这些信息，需要发送方和服务器配置<br />服务器配置：<br />- `Access-Control-Allow-Credentials`为`true`<br />- `Access-Control-Allow-Origin`不能为`*`，必须指定域名<br />发送方（JS）:<br/>开发者必须在AJAX请求中打开`withCredentials`属性 |\n| `Access-Control-Max-Age` | 以秒为单位的缓存时间在有效时间内，<br />浏览器无须为同一请求再次发起预检请求 | F |  |\n\n在Nginx中的配置：\n\n```yaml\nlocation / {  \n    add_header Access-Control-Allow-Origin *;\n    add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';\n    add_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization';\n\t\tadd_header Access-Control-Allow-Credentials 'true';\n\t\tadd_header Access-Control-Max-Age 86400;\n}\n```\n\n### CORS的判定流程\n\nCORS基本判定流程如图所示，主要分为三个阶段：\n\n1. **浏览器发起请求**：处理请求头，增加`Origin`字段\n2. **服务器处理请求，并返回响应**：服务器接收请求，根据当前服务器的CORS配置决定是否在响应头中写入`Access-Control-Allow-Origin`，并返回正常HTTP响应（注意，因为这里无论是否接收跨域请求，服务器都会返回一个正常HTTP响应，所以无法通过状态码来判断跨域请求是否成功）：\n    1. 服务器已配置CORS，写入该字段\n    2. 服务器未配置CORS，不写入该字段\n3. **浏览器处理响应**：检查响应头是否存在`Access-Control-Allow-Origin`：\n    1. 存在，服务器不允许跨域，浏览器抛出错误，错误类型为：`No 'Access-Control-Allow-Origin' header is present on the requested resource.`\n    2. 不存在，浏览器进一步比对该值是否包含当前域的值：\n        1. 包含，服务器同意该源的跨域请求，浏览器正常返回响应\n        2. 不包含，服务器允许跨域请求，但拒绝当前源的请求，浏览器抛出错误，错误类型为：`The 'Access-Control-Allow-Origin' header has a value '[http://xxx.com](http://xxx.com/)' that is not equal to the supplied origin.`\n\n\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/206ffba5f7094472b7f81527a21c60a6~tplv-k3u1fbpfcp-watermark.image?\" alt=\"3.png\" width=\"100%\" />\n\n在这三个阶段中，根据请求类型（**简单请求 / 非简单请求**）的不同，具体的流程处理和操作也会不一致。\n\n### 简单请求和非简单请求\n\n什么是简单请求和非简单请求呢？实际上这个可以理解为根据当前请求的信息载量来进行区分的。对于信息载量较少的就是简单请求，信息载量多的就是非简单请求。对于这两种请求类型，有明确的定义。\n\n#### 简单请求\n\n1. 使用 `GET、POST、HEAD` 其中一种请求方法。\n2. HTTP的头信息不超出以下几种字段：\n- `Accept`\n- `Accept-Language`\n- `Content-Language`\n- `Last-Event-ID`\n- `Content-Type`：只限于三个值 `application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`\n    - 这三个值也是直接用表单提交可以设置的值\n1. `XMLHttpRequestUpload`：\n    1. 请求中的任意`XMLHttpRequestUpload` 对象均没有注册任何事件监听器；\n    2. `XMLHttpRequestUpload` 对象可以使用 `XMLHttpRequest.upload` 属性访问。 \n2. 请求中没有使用 `ReadableStream` 对象。\n\n对于简单请求类型，整个CORS流程没什么变化（如上图一致），浏览器在第一阶段处理请求时，会直接在当前请求的请求头中增加`Origin`字段然后发送给服务器。\n\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58388e59c5c346039dcb6ac020b7ff80~tplv-k3u1fbpfcp-watermark.image?\" alt=\"1.png\" width=\"100%\" />\n\n#### 非简单请求\n\n除了简单请求，其他的都是非简单请求。\n\n非简单请求的流程有所不同。对于非简单请求，浏览器会在正式通信之前，增加一次HTTP查询请求，称为“预检“请求（preflight）。只有通过了预检请求，浏览器才会发出正式通信。这里预检请求的方法是`OPTIONS` 。一次非简单请求的流程如下：\n\n- 浏览器发起`OPTIONS`请求：当浏览器发现当前的请求是非简单请求，会先发起`OPTIONS` 请求。在`OPTIONS`的请求头中增加3个字段：\n    - `Origin`\n    - `Access-Control-Request-Method`：列出浏览器的**正式请求**中会用到的HTTP方法。\n    - `Access-Control-Request-Headers`：指定浏览器的**正式请求**中会额外需要发送哪些头信息字段。\n- 服务器接收`OPTIONS`请求，返回响应：服务器收到请求后，会检查服务器的CORS配置和请求头中CORS字段，决定如何返回响应：\n    - 服务器**未配置CORS接口 or** 服务器配置的CORS接口和请求头中的**CORS字段不匹配**：服务器**否定**此次预检请求，返回正常的HTTP响应，响应头中不包含CORS相关字段`（未配置 || 不匹配 ⇒ 否定：不包含）`。\n    - 服务器**已配置 and** 配置的CORS接口和请求头的**CORS字段匹配**：服务器**肯定**此次预检请求，返回正常的HTTP响应，响应头中包含CORS相关字段`（配置 && 匹配 ⇒ 肯定：包含）`；\n- 浏览器处理响应：当浏览器接收到服务器的响应之后，检查响应头是否包含CORS相关字段：\n    - 不包含，浏览器抛出错误\n    - 包含，服务器肯定此次预检请求，浏览器发出正式的`CORS`请求获取数据，这个正式的CORS请求的流程和简单请求一致。\n\n\n<img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6503b02ce11748148b8653877f306e79~tplv-k3u1fbpfcp-watermark.image?\" alt=\"2.png\" width=\"100%\" />\n\n\n下面列出了CORS请求中会用到的协议头字段以及说明：\n\n| 协议头参数 | 类型 | 说明 | 是否必须 | 备注 |\n| --- | --- | --- | --- | --- |\n| `Origin` | 请求头 | 该字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。 | T |  |\n| `Access-Control-Request-Method` | 请求头 | 该字段用于预检请求，指名浏览器正式的CORS请求会用到的HTTP方法 | T | 发送预检请求时，必须包含 |\n| `Access-Control-Request-Headers` | 请求头 | 该字段用于预检请求，指名浏览器正式的CORS请求会额外发送的头信息字段 | T | 发送预检请求时，必须包含 |\n| `Access-Control-Allow-Origin` | 响应头 | （同服务器配置字段含义） | T |  |\n| `Access-Control-Expose-Headers` | 响应头 | 该字段指明服务器允许哪些响应头可以暴露给浏览器中运行的脚本（JS），以响应跨源请求。<br />在没有额外指明的情况下，CORS请求时，XMLHttpRequest对象的`getResponseHeader()`方法只能拿到6个基本字段：<br />`Cache-Control`、`Content-Language`、`Content-Type`、`Expires`、`Last-Modified`、`Pragma`。<br/>如果想拿到其他字段，就必须在`Access-Control-Expose-Headers`里面指定。 |F||\n| `Access-Control-Allow-Methods` | 响应头 | （同服务器配置字段含义） | T |  |\n| `Access-Control-Allow-Headers` | 响应头 | （同服务器配置字段含义） | F |  |\n| `Access-Control-Allow-Credentials` | 响应头 | （同服务器配置字段含义） | F |  |\n| `Access-Control-Max-Age` | 响应头 | （同服务器配置字段含义） | F |  |\n\n## JSONP\n\nJSONP 的原理就是利用 `<script>` 标签的 `src` 属性没有跨域的限制，通过指向一个需要访问的地址，由服务端返回一个预先定义好的 `Javascript` 函数的调用，并且将服务器数据以该函数参数的形式传递过来，此方法需要前后端配合完成。\n\n- `script`标签 `src`可跨域\n- 将回调方法作为`get`参数传给后端\n- 后端返回一个`js`，调用这个回调，并把数据传给回调\n\n```jsx\n//定义获取数据的回调方法\nfunction getData(data) {\n  console.log(data);\n}\n\n// 创建一个script标签，并且告诉后端回调函数名叫 getData\nvar body = document.getElementsByTagName('body')[0];\nvar script = document.gerElement('script');\nscript.type = 'text/javasctipt';\nscript.src = 'demo.js?callback=getData';\nbody.appendChild(script);\n\n//script 加载完毕之后从页面中删除,否则每次点击生成许多script标签\nscript.onload = function () {\n  document.body.removeChild(script);\n}\n```\n\n\n\n## 服务器代理\n\n浏览器对网络请求做了处理，所以通过从浏览器端发送的请求都会有跨域限制，但是服务器请求服务器就不存在这个问题。所以可以搭建一个代理服务器，将前端资源和代理服务器部署到一个域下，然后前端请求代理服务器，再通过代理服务器转发请求，从而实现请求跨域。\n\n\n\n## document.domain\n\n该方式只能用于二级域名相同的情况下，比如 `a.test.com` 和 `b.test.com` 适用于该方式。\n\n只需要给两个页面都添加 `document.domain = 'test.com'`，通过在 `a.test.com` 创建一个 `iframe`，去控制 `iframe` 的 `window`，从而进行交互。\n\n\n\n## postMessage\n\n`window.postMessage` 是一个 `HTML5` 的 `api`，允许两个窗口之间进行跨域发送消息。\n\n这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息\n\n```jsx\n// 发送消息端\nvar receiver = document.getElementById('receiver').contentWindow;\nvar btn = document.getElementById('send');\nbtn.addEventListener('click', function (e) {\n    e.preventDefault();\n    var val = document.getElementById('text').value;\n    receiver.postMessage(\"Hello \"+val+\"！\", \"http://res.42du.cn\");\n}); \n\n// 接收消息端\nwindow.addEventListener(\"message\", receiveMessage, false);\nfunction receiveMessage(event){\n  if (event.origin !== \"http://www.42du.cn\")\n    return;\n}\n```\n\n# 需要跨域请求的情况\n\n- 由 [XMLHttpRequest](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest) 或者 [Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) 发起的跨源 HTTP 请求。\n- Web 字体 (CSS 中通过`@font-face`使用跨源字体资源)，[因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用](https://www.w3.org/TR/css-fonts-3/#font-fetching-requirements)。\n- [WebGL 贴图](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL)\n- 使用 `drawImage` 将 `Images/video` 画面绘制到 `canvas`\n\n\n# 参考\n- [彻底理解浏览器的跨域](https://juejin.im/post/6844903816060469262)\n- [跨域资源共享 CORS 详解](https://www.ruanyifeng.com/blog/2016/04/cors.html)\n- [你真的会使用XMLHttpRequest吗？](https://segmentfault.com/a/1190000004322487)\n- [跨源资源共享（CORS）](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS)\n- [九种跨域方式实现原理（完整版）](https://juejin.cn/post/6844903767226351623)\n\n\n\n\n\n","source":"_posts/浏览器同源策略.md","raw":"---\ntitle: 浏览器同源策略\ndate: 2023-02-28 22:12:38\ncategory: [浏览器]\ntags: <span class=\"label label-primary\">浏览器安全</span> <span class=\"label label-primary\">CORS</span>\nexcerpt: 同源策略是一个重要的安全策略，它用于限制一个源（origin）的文档或者它加载的脚本如何能与另一个源的资源进行交互。非同源下的文档和脚本（JS），不能跨域获取资源。\n---\n# 同源策略\n## 什么是同源策略\n同源策略是一个重要的**安全策略**，它用于**限制**一个源（origin）的文档或者它加载的脚本如何能与另一个源的资源进行**交互**。非同源下的文档和脚本（JS），不能跨域获取资源。\n\n其中**同源**是指：\n\n- 协议相同\n- 域名相同\n- 端口相同\n\n## 为什么会存在同源策略\n\n同源策略是**浏览器**为了**保护用户信息安全**所执行的策略。1995年由 Netscape 公司引入的，目前所有的**浏览器**都执行这个策略。\n\n因为它的主要目的是为了保证用户信息安全，所以只要涉及到用户信息的获取途径都会被**限制**，这些信息获取途径包括：\n\n- 通过操作**其他网站**或者 **iframe**的 `dom` 来获取用户的表单数据\n- 通过获取`cookie`，`localstorge`，`sessionstorage`，`indexDB`等缓存信息，来获取用户信息\n- 通过发送 `ajax / fetch` 请求，来获取后端的用户信息（提交表单不受跨域限制）\n\n如果不对这些途径加以限制，就可能被恶意网站盗取用户信息。那么恶意是如何通过这几种途径获取信息的呢？举几个案例（来源于[彻底理解浏览器的跨域](https://juejin.im/post/6844903816060469262)）：\n\n\n> 一、cookie获取发送请求\n> \n> A 网站是一家银行，用户登录以后，A 网站在用户的机器上设置了一个 Cookie，包含了一些隐私信息（比如存款总额）。用户离开 A 网站以后，又去访问 B 网站，如果没有同源限制，B 网站可以读取 A 网站的 Cookie，那么隐私信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。\n> 例如\n>\n> 1. 用户登录了自己的银行页面 [http://mybank.com](http://mybank.com/)，[mybank.com](https://www.notion.so/b4dda8a6ca0b4a308ed8dd5d5f77861a) 向用户的cookie中添加用户标识。\n> 2. 用户浏览了恶意页面 [evil.com](http://evil.com/)。执行了页面中的恶意AJAX请求代码。\n> 3. 向http://mybank.com发起AJAX HTTP请求，请求会默认把http://mybank.com对应cookie也同时发送过去。\n> 4. 银行页面从发送的cookie中提取用户标识，验证用户无误，response中返回请求数据。此时数据就泄露了。\n> 5. 而且由于Ajax在后台执行，用户无法感知这一过程。\n>\n> 二、dom操作\n>\n> 1. 做一个假网站，里面用iframe嵌套一个银行网站 [mybank.com](http://mybank.com/)。\n> 2. 把iframe宽高啥的调整到页面全部，这样用户进来除了域名，别的部分和银行的网站没有任何差别。\n> 3. 这时如果用户输入账号密码，我们的主网站可以跨域访问到http://mybank.com的dom节点，就可以拿到用户的输入了，那么就完成了一次攻击\n\n\n\n所以针对这三点，浏览器做了同源限制：\n\n- 无法获取跨域缓存：`cookie` `localstorge` `indexDB` 等\n\n- 无法访问非同源网页的` DOM （iframe）`。\n- 无法向非同源地址发送 `AJAX` 请求 或 `Fetch` 请求（可以发送，但浏览器拒绝接受响应）。\n\n\n\n总结一下：\n\n同源策略实际就是浏览器为了保证用户信息安全的策略，限制只有同源的文档或者脚本才能进行交互。其中同源是指**协议**、**域名**、**端口**三点相同。通过限制用户（一般是指开发者）通过操作`dom`、获取缓存信息以及发送`ajax / fetch` 请求等方式来获取用户信息来保证用户信息安全。\n\n# 解决跨域通信\n\n我们在开发中，避免不了要跨域获取信息，其中最常见的就是发送跨域请求（`ajax / fetch`）来获取资源。那么解决跨域通信问题就成了我们的日常。根据浏览器的同源限制，我们将解决跨域通信分为2个方向：\n\n- 针对**跨域的网络请求**，需要前后端配合操作来解决，主要方法包括：\n    - CORS\n    - JSONP\n    - 服务器代理\n- 针对DOM级别的操作，我们只需要通过前端解决，主要方法包括：\n    - `postMassage`（HTML5 的 api， 允许两个窗口之间进行跨域发送消息）\n    - `document.domain`（只能用于一、二级域名都相同的情况）\n\n| 通信侧 | 方法 |\n| --- | --- |\n| 前端 | `postMassage`（HTML5 的 api， 允许两个窗口之间进行跨域发送消息）、<br />`document.domain`（只能用于一、二级域名都相同的情况） |\n| 前后端 | `CORS`、`jsonp`、服务器代理 |\n\n## CORS\n\nCORS（**跨域资源共享  Cross-origin resource sharing）**是W3C标准，它允许浏览器向跨域服务器发出请求，解决了**同源限制中AJAX 请求无法跨域**的问题。这种跨域通信解决方案不需要用户做额外的操作，是浏览器和服务器共同实现的。\n\n在浏览器端，不需要用户额外配置，当用户在浏览器发送AJAX请求（例如在js代码中发起了ajax请求），浏览器会自动处理HTTP请求，同时会对服务器端返回的响应进行拦截处理，判断该响应是否同源，进而决定是返回正常的响应还是抛出错误。\n\n而服务器则需要手动配置CORS接口，实现对跨域请求的处理。常用的**服务器CORS配置字段**如下：\n\n| 协议头参数 | 说明 | 是否必须 | 备注 |\n| ---- | ---- | -- | :-- |\n| `Access-Control-Allow-Origin` | 表示允许跨域请求的域 值为：<br />- 通配符`*`：接受任何域的跨域访问<br />`<origin>`：指定一个来源（只能指定一个）<br />`null` ：指定来源为 `null` <br />此时实际上就是不接受跨域，但是不推荐设置为该值。<br />因为浏览器在进行`CORS`判定时只会判断`Access-Control-Allow-Origin`字段是否存在而不会判断该字段的值，所以设置为`null`会导致安全问题 | T |  |\n| `Access-Control-Allow-Methods` | 服务器允许跨域请求的 `http` 方法列表 | T | 响应预检请求时，必须包含 |\n| `Access-Control-Allow-Headers` | 列出了服务器支持的所有头信息字段，<br />这些字段可以用于预检请求的`Access-Control-Request-Headers` | F | 当预请求（`OPTIONS`）中包含`Access-Control-Request-Headers`时，服务器必须设置该字段配置 |\n| `Access-Control-Allow-Credentials` | 表示是否允许发送Cookie，只有一个可选值：true（必为小写）。<br />如果不发送cookie，则直接省略，不写为false | F | CORS请求默认不发送`Cookie`和HTTP认证信息<br />要携带这些信息，需要发送方和服务器配置<br />服务器配置：<br />- `Access-Control-Allow-Credentials`为`true`<br />- `Access-Control-Allow-Origin`不能为`*`，必须指定域名<br />发送方（JS）:<br/>开发者必须在AJAX请求中打开`withCredentials`属性 |\n| `Access-Control-Max-Age` | 以秒为单位的缓存时间在有效时间内，<br />浏览器无须为同一请求再次发起预检请求 | F |  |\n\n在Nginx中的配置：\n\n```yaml\nlocation / {  \n    add_header Access-Control-Allow-Origin *;\n    add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';\n    add_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization';\n\t\tadd_header Access-Control-Allow-Credentials 'true';\n\t\tadd_header Access-Control-Max-Age 86400;\n}\n```\n\n### CORS的判定流程\n\nCORS基本判定流程如图所示，主要分为三个阶段：\n\n1. **浏览器发起请求**：处理请求头，增加`Origin`字段\n2. **服务器处理请求，并返回响应**：服务器接收请求，根据当前服务器的CORS配置决定是否在响应头中写入`Access-Control-Allow-Origin`，并返回正常HTTP响应（注意，因为这里无论是否接收跨域请求，服务器都会返回一个正常HTTP响应，所以无法通过状态码来判断跨域请求是否成功）：\n    1. 服务器已配置CORS，写入该字段\n    2. 服务器未配置CORS，不写入该字段\n3. **浏览器处理响应**：检查响应头是否存在`Access-Control-Allow-Origin`：\n    1. 存在，服务器不允许跨域，浏览器抛出错误，错误类型为：`No 'Access-Control-Allow-Origin' header is present on the requested resource.`\n    2. 不存在，浏览器进一步比对该值是否包含当前域的值：\n        1. 包含，服务器同意该源的跨域请求，浏览器正常返回响应\n        2. 不包含，服务器允许跨域请求，但拒绝当前源的请求，浏览器抛出错误，错误类型为：`The 'Access-Control-Allow-Origin' header has a value '[http://xxx.com](http://xxx.com/)' that is not equal to the supplied origin.`\n\n\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/206ffba5f7094472b7f81527a21c60a6~tplv-k3u1fbpfcp-watermark.image?\" alt=\"3.png\" width=\"100%\" />\n\n在这三个阶段中，根据请求类型（**简单请求 / 非简单请求**）的不同，具体的流程处理和操作也会不一致。\n\n### 简单请求和非简单请求\n\n什么是简单请求和非简单请求呢？实际上这个可以理解为根据当前请求的信息载量来进行区分的。对于信息载量较少的就是简单请求，信息载量多的就是非简单请求。对于这两种请求类型，有明确的定义。\n\n#### 简单请求\n\n1. 使用 `GET、POST、HEAD` 其中一种请求方法。\n2. HTTP的头信息不超出以下几种字段：\n- `Accept`\n- `Accept-Language`\n- `Content-Language`\n- `Last-Event-ID`\n- `Content-Type`：只限于三个值 `application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`\n    - 这三个值也是直接用表单提交可以设置的值\n1. `XMLHttpRequestUpload`：\n    1. 请求中的任意`XMLHttpRequestUpload` 对象均没有注册任何事件监听器；\n    2. `XMLHttpRequestUpload` 对象可以使用 `XMLHttpRequest.upload` 属性访问。 \n2. 请求中没有使用 `ReadableStream` 对象。\n\n对于简单请求类型，整个CORS流程没什么变化（如上图一致），浏览器在第一阶段处理请求时，会直接在当前请求的请求头中增加`Origin`字段然后发送给服务器。\n\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58388e59c5c346039dcb6ac020b7ff80~tplv-k3u1fbpfcp-watermark.image?\" alt=\"1.png\" width=\"100%\" />\n\n#### 非简单请求\n\n除了简单请求，其他的都是非简单请求。\n\n非简单请求的流程有所不同。对于非简单请求，浏览器会在正式通信之前，增加一次HTTP查询请求，称为“预检“请求（preflight）。只有通过了预检请求，浏览器才会发出正式通信。这里预检请求的方法是`OPTIONS` 。一次非简单请求的流程如下：\n\n- 浏览器发起`OPTIONS`请求：当浏览器发现当前的请求是非简单请求，会先发起`OPTIONS` 请求。在`OPTIONS`的请求头中增加3个字段：\n    - `Origin`\n    - `Access-Control-Request-Method`：列出浏览器的**正式请求**中会用到的HTTP方法。\n    - `Access-Control-Request-Headers`：指定浏览器的**正式请求**中会额外需要发送哪些头信息字段。\n- 服务器接收`OPTIONS`请求，返回响应：服务器收到请求后，会检查服务器的CORS配置和请求头中CORS字段，决定如何返回响应：\n    - 服务器**未配置CORS接口 or** 服务器配置的CORS接口和请求头中的**CORS字段不匹配**：服务器**否定**此次预检请求，返回正常的HTTP响应，响应头中不包含CORS相关字段`（未配置 || 不匹配 ⇒ 否定：不包含）`。\n    - 服务器**已配置 and** 配置的CORS接口和请求头的**CORS字段匹配**：服务器**肯定**此次预检请求，返回正常的HTTP响应，响应头中包含CORS相关字段`（配置 && 匹配 ⇒ 肯定：包含）`；\n- 浏览器处理响应：当浏览器接收到服务器的响应之后，检查响应头是否包含CORS相关字段：\n    - 不包含，浏览器抛出错误\n    - 包含，服务器肯定此次预检请求，浏览器发出正式的`CORS`请求获取数据，这个正式的CORS请求的流程和简单请求一致。\n\n\n<img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6503b02ce11748148b8653877f306e79~tplv-k3u1fbpfcp-watermark.image?\" alt=\"2.png\" width=\"100%\" />\n\n\n下面列出了CORS请求中会用到的协议头字段以及说明：\n\n| 协议头参数 | 类型 | 说明 | 是否必须 | 备注 |\n| --- | --- | --- | --- | --- |\n| `Origin` | 请求头 | 该字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。 | T |  |\n| `Access-Control-Request-Method` | 请求头 | 该字段用于预检请求，指名浏览器正式的CORS请求会用到的HTTP方法 | T | 发送预检请求时，必须包含 |\n| `Access-Control-Request-Headers` | 请求头 | 该字段用于预检请求，指名浏览器正式的CORS请求会额外发送的头信息字段 | T | 发送预检请求时，必须包含 |\n| `Access-Control-Allow-Origin` | 响应头 | （同服务器配置字段含义） | T |  |\n| `Access-Control-Expose-Headers` | 响应头 | 该字段指明服务器允许哪些响应头可以暴露给浏览器中运行的脚本（JS），以响应跨源请求。<br />在没有额外指明的情况下，CORS请求时，XMLHttpRequest对象的`getResponseHeader()`方法只能拿到6个基本字段：<br />`Cache-Control`、`Content-Language`、`Content-Type`、`Expires`、`Last-Modified`、`Pragma`。<br/>如果想拿到其他字段，就必须在`Access-Control-Expose-Headers`里面指定。 |F||\n| `Access-Control-Allow-Methods` | 响应头 | （同服务器配置字段含义） | T |  |\n| `Access-Control-Allow-Headers` | 响应头 | （同服务器配置字段含义） | F |  |\n| `Access-Control-Allow-Credentials` | 响应头 | （同服务器配置字段含义） | F |  |\n| `Access-Control-Max-Age` | 响应头 | （同服务器配置字段含义） | F |  |\n\n## JSONP\n\nJSONP 的原理就是利用 `<script>` 标签的 `src` 属性没有跨域的限制，通过指向一个需要访问的地址，由服务端返回一个预先定义好的 `Javascript` 函数的调用，并且将服务器数据以该函数参数的形式传递过来，此方法需要前后端配合完成。\n\n- `script`标签 `src`可跨域\n- 将回调方法作为`get`参数传给后端\n- 后端返回一个`js`，调用这个回调，并把数据传给回调\n\n```jsx\n//定义获取数据的回调方法\nfunction getData(data) {\n  console.log(data);\n}\n\n// 创建一个script标签，并且告诉后端回调函数名叫 getData\nvar body = document.getElementsByTagName('body')[0];\nvar script = document.gerElement('script');\nscript.type = 'text/javasctipt';\nscript.src = 'demo.js?callback=getData';\nbody.appendChild(script);\n\n//script 加载完毕之后从页面中删除,否则每次点击生成许多script标签\nscript.onload = function () {\n  document.body.removeChild(script);\n}\n```\n\n\n\n## 服务器代理\n\n浏览器对网络请求做了处理，所以通过从浏览器端发送的请求都会有跨域限制，但是服务器请求服务器就不存在这个问题。所以可以搭建一个代理服务器，将前端资源和代理服务器部署到一个域下，然后前端请求代理服务器，再通过代理服务器转发请求，从而实现请求跨域。\n\n\n\n## document.domain\n\n该方式只能用于二级域名相同的情况下，比如 `a.test.com` 和 `b.test.com` 适用于该方式。\n\n只需要给两个页面都添加 `document.domain = 'test.com'`，通过在 `a.test.com` 创建一个 `iframe`，去控制 `iframe` 的 `window`，从而进行交互。\n\n\n\n## postMessage\n\n`window.postMessage` 是一个 `HTML5` 的 `api`，允许两个窗口之间进行跨域发送消息。\n\n这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息\n\n```jsx\n// 发送消息端\nvar receiver = document.getElementById('receiver').contentWindow;\nvar btn = document.getElementById('send');\nbtn.addEventListener('click', function (e) {\n    e.preventDefault();\n    var val = document.getElementById('text').value;\n    receiver.postMessage(\"Hello \"+val+\"！\", \"http://res.42du.cn\");\n}); \n\n// 接收消息端\nwindow.addEventListener(\"message\", receiveMessage, false);\nfunction receiveMessage(event){\n  if (event.origin !== \"http://www.42du.cn\")\n    return;\n}\n```\n\n# 需要跨域请求的情况\n\n- 由 [XMLHttpRequest](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest) 或者 [Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) 发起的跨源 HTTP 请求。\n- Web 字体 (CSS 中通过`@font-face`使用跨源字体资源)，[因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用](https://www.w3.org/TR/css-fonts-3/#font-fetching-requirements)。\n- [WebGL 贴图](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL)\n- 使用 `drawImage` 将 `Images/video` 画面绘制到 `canvas`\n\n\n# 参考\n- [彻底理解浏览器的跨域](https://juejin.im/post/6844903816060469262)\n- [跨域资源共享 CORS 详解](https://www.ruanyifeng.com/blog/2016/04/cors.html)\n- [你真的会使用XMLHttpRequest吗？](https://segmentfault.com/a/1190000004322487)\n- [跨源资源共享（CORS）](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS)\n- [九种跨域方式实现原理（完整版）](https://juejin.cn/post/6844903767226351623)\n\n\n\n\n\n","slug":"浏览器同源策略","published":1,"updated":"2023-03-03T13:09:12.857Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clesk19gu000cdddf9jelhpk1","content":"<h1 id=\"同源策略\"><a href=\"#同源策略\" class=\"headerlink\" title=\"同源策略\"></a>同源策略</h1><h2 id=\"什么是同源策略\"><a href=\"#什么是同源策略\" class=\"headerlink\" title=\"什么是同源策略\"></a>什么是同源策略</h2><p>同源策略是一个重要的<strong>安全策略</strong>，它用于<strong>限制</strong>一个源（origin）的文档或者它加载的脚本如何能与另一个源的资源进行<strong>交互</strong>。非同源下的文档和脚本（JS），不能跨域获取资源。</p>\n<p>其中<strong>同源</strong>是指：</p>\n<ul>\n<li>协议相同</li>\n<li>域名相同</li>\n<li>端口相同</li>\n</ul>\n<h2 id=\"为什么会存在同源策略\"><a href=\"#为什么会存在同源策略\" class=\"headerlink\" title=\"为什么会存在同源策略\"></a>为什么会存在同源策略</h2><p>同源策略是<strong>浏览器</strong>为了<strong>保护用户信息安全</strong>所执行的策略。1995年由 Netscape 公司引入的，目前所有的<strong>浏览器</strong>都执行这个策略。</p>\n<p>因为它的主要目的是为了保证用户信息安全，所以只要涉及到用户信息的获取途径都会被<strong>限制</strong>，这些信息获取途径包括：</p>\n<ul>\n<li>通过操作<strong>其他网站</strong>或者 <strong>iframe</strong>的 <code>dom</code> 来获取用户的表单数据</li>\n<li>通过获取<code>cookie</code>，<code>localstorge</code>，<code>sessionstorage</code>，<code>indexDB</code>等缓存信息，来获取用户信息</li>\n<li>通过发送 <code>ajax / fetch</code> 请求，来获取后端的用户信息（提交表单不受跨域限制）</li>\n</ul>\n<p>如果不对这些途径加以限制，就可能被恶意网站盗取用户信息。那么恶意是如何通过这几种途径获取信息的呢？举几个案例（来源于<a href=\"https://juejin.im/post/6844903816060469262\">彻底理解浏览器的跨域</a>）：</p>\n<blockquote>\n<p>一、cookie获取发送请求</p>\n<p>A 网站是一家银行，用户登录以后，A 网站在用户的机器上设置了一个 Cookie，包含了一些隐私信息（比如存款总额）。用户离开 A 网站以后，又去访问 B 网站，如果没有同源限制，B 网站可以读取 A 网站的 Cookie，那么隐私信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。<br>例如</p>\n<ol>\n<li>用户登录了自己的银行页面 <a href=\"http://mybank.com/\">http://mybank.com</a>，<a href=\"https://www.notion.so/b4dda8a6ca0b4a308ed8dd5d5f77861a\">mybank.com</a> 向用户的cookie中添加用户标识。</li>\n<li>用户浏览了恶意页面 <a href=\"http://evil.com/\">evil.com</a>。执行了页面中的恶意AJAX请求代码。</li>\n<li>向<a href=\"http://mybank.com发起ajax/\">http://mybank.com发起AJAX</a> HTTP请求，请求会默认把<a href=\"http://mybank.com对应cookie也同时发送过去./\">http://mybank.com对应cookie也同时发送过去。</a></li>\n<li>银行页面从发送的cookie中提取用户标识，验证用户无误，response中返回请求数据。此时数据就泄露了。</li>\n<li>而且由于Ajax在后台执行，用户无法感知这一过程。</li>\n</ol>\n<p>二、dom操作</p>\n<ol>\n<li>做一个假网站，里面用iframe嵌套一个银行网站 <a href=\"http://mybank.com/\">mybank.com</a>。</li>\n<li>把iframe宽高啥的调整到页面全部，这样用户进来除了域名，别的部分和银行的网站没有任何差别。</li>\n<li>这时如果用户输入账号密码，我们的主网站可以跨域访问到<a href=\"http://mybank.com的dom节点,就可以拿到用户的输入了,那么就完成了一次攻击/\">http://mybank.com的dom节点，就可以拿到用户的输入了，那么就完成了一次攻击</a></li>\n</ol>\n</blockquote>\n<p>所以针对这三点，浏览器做了同源限制：</p>\n<ul>\n<li><p>无法获取跨域缓存：<code>cookie</code> <code>localstorge</code> <code>indexDB</code> 等</p>\n</li>\n<li><p>无法访问非同源网页的<code> DOM （iframe）</code>。</p>\n</li>\n<li><p>无法向非同源地址发送 <code>AJAX</code> 请求 或 <code>Fetch</code> 请求（可以发送，但浏览器拒绝接受响应）。</p>\n</li>\n</ul>\n<p>总结一下：</p>\n<p>同源策略实际就是浏览器为了保证用户信息安全的策略，限制只有同源的文档或者脚本才能进行交互。其中同源是指<strong>协议</strong>、<strong>域名</strong>、<strong>端口</strong>三点相同。通过限制用户（一般是指开发者）通过操作<code>dom</code>、获取缓存信息以及发送<code>ajax / fetch</code> 请求等方式来获取用户信息来保证用户信息安全。</p>\n<h1 id=\"解决跨域通信\"><a href=\"#解决跨域通信\" class=\"headerlink\" title=\"解决跨域通信\"></a>解决跨域通信</h1><p>我们在开发中，避免不了要跨域获取信息，其中最常见的就是发送跨域请求（<code>ajax / fetch</code>）来获取资源。那么解决跨域通信问题就成了我们的日常。根据浏览器的同源限制，我们将解决跨域通信分为2个方向：</p>\n<ul>\n<li>针对<strong>跨域的网络请求</strong>，需要前后端配合操作来解决，主要方法包括：<ul>\n<li>CORS</li>\n<li>JSONP</li>\n<li>服务器代理</li>\n</ul>\n</li>\n<li>针对DOM级别的操作，我们只需要通过前端解决，主要方法包括：<ul>\n<li><code>postMassage</code>（HTML5 的 api， 允许两个窗口之间进行跨域发送消息）</li>\n<li><code>document.domain</code>（只能用于一、二级域名都相同的情况）</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>通信侧</th>\n<th>方法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>前端</td>\n<td><code>postMassage</code>（HTML5 的 api， 允许两个窗口之间进行跨域发送消息）、<br /><code>document.domain</code>（只能用于一、二级域名都相同的情况）</td>\n</tr>\n<tr>\n<td>前后端</td>\n<td><code>CORS</code>、<code>jsonp</code>、服务器代理</td>\n</tr>\n</tbody></table>\n<h2 id=\"CORS\"><a href=\"#CORS\" class=\"headerlink\" title=\"CORS\"></a>CORS</h2><p>CORS（<strong>跨域资源共享  Cross-origin resource sharing）</strong>是W3C标准，它允许浏览器向跨域服务器发出请求，解决了<strong>同源限制中AJAX 请求无法跨域</strong>的问题。这种跨域通信解决方案不需要用户做额外的操作，是浏览器和服务器共同实现的。</p>\n<p>在浏览器端，不需要用户额外配置，当用户在浏览器发送AJAX请求（例如在js代码中发起了ajax请求），浏览器会自动处理HTTP请求，同时会对服务器端返回的响应进行拦截处理，判断该响应是否同源，进而决定是返回正常的响应还是抛出错误。</p>\n<p>而服务器则需要手动配置CORS接口，实现对跨域请求的处理。常用的<strong>服务器CORS配置字段</strong>如下：</p>\n<table>\n<thead>\n<tr>\n<th>协议头参数</th>\n<th>说明</th>\n<th>是否必须</th>\n<th align=\"left\">备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Access-Control-Allow-Origin</code></td>\n<td>表示允许跨域请求的域 值为：<br />- 通配符<code>*</code>：接受任何域的跨域访问<br /><code>&lt;origin&gt;</code>：指定一个来源（只能指定一个）<br /><code>null</code> ：指定来源为 <code>null</code> <br />此时实际上就是不接受跨域，但是不推荐设置为该值。<br />因为浏览器在进行<code>CORS</code>判定时只会判断<code>Access-Control-Allow-Origin</code>字段是否存在而不会判断该字段的值，所以设置为<code>null</code>会导致安全问题</td>\n<td>T</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td><code>Access-Control-Allow-Methods</code></td>\n<td>服务器允许跨域请求的 <code>http</code> 方法列表</td>\n<td>T</td>\n<td align=\"left\">响应预检请求时，必须包含</td>\n</tr>\n<tr>\n<td><code>Access-Control-Allow-Headers</code></td>\n<td>列出了服务器支持的所有头信息字段，<br />这些字段可以用于预检请求的<code>Access-Control-Request-Headers</code></td>\n<td>F</td>\n<td align=\"left\">当预请求（<code>OPTIONS</code>）中包含<code>Access-Control-Request-Headers</code>时，服务器必须设置该字段配置</td>\n</tr>\n<tr>\n<td><code>Access-Control-Allow-Credentials</code></td>\n<td>表示是否允许发送Cookie，只有一个可选值：true（必为小写）。<br />如果不发送cookie，则直接省略，不写为false</td>\n<td>F</td>\n<td align=\"left\">CORS请求默认不发送<code>Cookie</code>和HTTP认证信息<br />要携带这些信息，需要发送方和服务器配置<br />服务器配置：<br />- <code>Access-Control-Allow-Credentials</code>为<code>true</code><br />- <code>Access-Control-Allow-Origin</code>不能为<code>*</code>，必须指定域名<br />发送方（JS）:<br/>开发者必须在AJAX请求中打开<code>withCredentials</code>属性</td>\n</tr>\n<tr>\n<td><code>Access-Control-Max-Age</code></td>\n<td>以秒为单位的缓存时间在有效时间内，<br />浏览器无须为同一请求再次发起预检请求</td>\n<td>F</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p>在Nginx中的配置：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-string\">location</span> <span class=\"hljs-string\">/</span> &#123;  <br>    <span class=\"hljs-string\">add_header</span> <span class=\"hljs-string\">Access-Control-Allow-Origin</span> <span class=\"hljs-string\">*;</span><br>    <span class=\"hljs-string\">add_header</span> <span class=\"hljs-string\">Access-Control-Allow-Methods</span> <span class=\"hljs-string\">&#x27;GET, POST, OPTIONS&#x27;</span><span class=\"hljs-string\">;</span><br>    <span class=\"hljs-string\">add_header</span> <span class=\"hljs-string\">Access-Control-Allow-Headers</span> <span class=\"hljs-string\">&#x27;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization&#x27;</span><span class=\"hljs-string\">;</span><br>\t\t<span class=\"hljs-string\">add_header</span> <span class=\"hljs-string\">Access-Control-Allow-Credentials</span> <span class=\"hljs-string\">&#x27;true&#x27;</span><span class=\"hljs-string\">;</span><br>\t\t<span class=\"hljs-string\">add_header</span> <span class=\"hljs-string\">Access-Control-Max-Age</span> <span class=\"hljs-number\">86400</span><span class=\"hljs-string\">;</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"CORS的判定流程\"><a href=\"#CORS的判定流程\" class=\"headerlink\" title=\"CORS的判定流程\"></a>CORS的判定流程</h3><p>CORS基本判定流程如图所示，主要分为三个阶段：</p>\n<ol>\n<li><strong>浏览器发起请求</strong>：处理请求头，增加<code>Origin</code>字段</li>\n<li><strong>服务器处理请求，并返回响应</strong>：服务器接收请求，根据当前服务器的CORS配置决定是否在响应头中写入<code>Access-Control-Allow-Origin</code>，并返回正常HTTP响应（注意，因为这里无论是否接收跨域请求，服务器都会返回一个正常HTTP响应，所以无法通过状态码来判断跨域请求是否成功）：<ol>\n<li>服务器已配置CORS，写入该字段</li>\n<li>服务器未配置CORS，不写入该字段</li>\n</ol>\n</li>\n<li><strong>浏览器处理响应</strong>：检查响应头是否存在<code>Access-Control-Allow-Origin</code>：<ol>\n<li>存在，服务器不允许跨域，浏览器抛出错误，错误类型为：<code>No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource.</code></li>\n<li>不存在，浏览器进一步比对该值是否包含当前域的值：<ol>\n<li>包含，服务器同意该源的跨域请求，浏览器正常返回响应</li>\n<li>不包含，服务器允许跨域请求，但拒绝当前源的请求，浏览器抛出错误，错误类型为：<code>The &#39;Access-Control-Allow-Origin&#39; header has a value &#39;[http://xxx.com](http://xxx.com/)&#39; that is not equal to the supplied origin.</code></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/206ffba5f7094472b7f81527a21c60a6~tplv-k3u1fbpfcp-watermark.image?\" alt=\"3.png\" width=\"100%\" />\n\n<p>在这三个阶段中，根据请求类型（<strong>简单请求 / 非简单请求</strong>）的不同，具体的流程处理和操作也会不一致。</p>\n<h3 id=\"简单请求和非简单请求\"><a href=\"#简单请求和非简单请求\" class=\"headerlink\" title=\"简单请求和非简单请求\"></a>简单请求和非简单请求</h3><p>什么是简单请求和非简单请求呢？实际上这个可以理解为根据当前请求的信息载量来进行区分的。对于信息载量较少的就是简单请求，信息载量多的就是非简单请求。对于这两种请求类型，有明确的定义。</p>\n<h4 id=\"简单请求\"><a href=\"#简单请求\" class=\"headerlink\" title=\"简单请求\"></a>简单请求</h4><ol>\n<li>使用 <code>GET、POST、HEAD</code> 其中一种请求方法。</li>\n<li>HTTP的头信息不超出以下几种字段：</li>\n</ol>\n<ul>\n<li><code>Accept</code></li>\n<li><code>Accept-Language</code></li>\n<li><code>Content-Language</code></li>\n<li><code>Last-Event-ID</code></li>\n<li><code>Content-Type</code>：只限于三个值 <code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code><ul>\n<li>这三个值也是直接用表单提交可以设置的值</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li><code>XMLHttpRequestUpload</code>：<ol>\n<li>请求中的任意<code>XMLHttpRequestUpload</code> 对象均没有注册任何事件监听器；</li>\n<li><code>XMLHttpRequestUpload</code> 对象可以使用 <code>XMLHttpRequest.upload</code> 属性访问。 </li>\n</ol>\n</li>\n<li>请求中没有使用 <code>ReadableStream</code> 对象。</li>\n</ol>\n<p>对于简单请求类型，整个CORS流程没什么变化（如上图一致），浏览器在第一阶段处理请求时，会直接在当前请求的请求头中增加<code>Origin</code>字段然后发送给服务器。</p>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58388e59c5c346039dcb6ac020b7ff80~tplv-k3u1fbpfcp-watermark.image?\" alt=\"1.png\" width=\"100%\" />\n\n<h4 id=\"非简单请求\"><a href=\"#非简单请求\" class=\"headerlink\" title=\"非简单请求\"></a>非简单请求</h4><p>除了简单请求，其他的都是非简单请求。</p>\n<p>非简单请求的流程有所不同。对于非简单请求，浏览器会在正式通信之前，增加一次HTTP查询请求，称为“预检“请求（preflight）。只有通过了预检请求，浏览器才会发出正式通信。这里预检请求的方法是<code>OPTIONS</code> 。一次非简单请求的流程如下：</p>\n<ul>\n<li>浏览器发起<code>OPTIONS</code>请求：当浏览器发现当前的请求是非简单请求，会先发起<code>OPTIONS</code> 请求。在<code>OPTIONS</code>的请求头中增加3个字段：<ul>\n<li><code>Origin</code></li>\n<li><code>Access-Control-Request-Method</code>：列出浏览器的<strong>正式请求</strong>中会用到的HTTP方法。</li>\n<li><code>Access-Control-Request-Headers</code>：指定浏览器的<strong>正式请求</strong>中会额外需要发送哪些头信息字段。</li>\n</ul>\n</li>\n<li>服务器接收<code>OPTIONS</code>请求，返回响应：服务器收到请求后，会检查服务器的CORS配置和请求头中CORS字段，决定如何返回响应：<ul>\n<li>服务器<strong>未配置CORS接口 or</strong> 服务器配置的CORS接口和请求头中的<strong>CORS字段不匹配</strong>：服务器<strong>否定</strong>此次预检请求，返回正常的HTTP响应，响应头中不包含CORS相关字段<code>（未配置 || 不匹配 ⇒ 否定：不包含）</code>。</li>\n<li>服务器<strong>已配置 and</strong> 配置的CORS接口和请求头的<strong>CORS字段匹配</strong>：服务器<strong>肯定</strong>此次预检请求，返回正常的HTTP响应，响应头中包含CORS相关字段<code>（配置 &amp;&amp; 匹配 ⇒ 肯定：包含）</code>；</li>\n</ul>\n</li>\n<li>浏览器处理响应：当浏览器接收到服务器的响应之后，检查响应头是否包含CORS相关字段：<ul>\n<li>不包含，浏览器抛出错误</li>\n<li>包含，服务器肯定此次预检请求，浏览器发出正式的<code>CORS</code>请求获取数据，这个正式的CORS请求的流程和简单请求一致。</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6503b02ce11748148b8653877f306e79~tplv-k3u1fbpfcp-watermark.image?\" alt=\"2.png\" width=\"100%\" />\n\n\n<p>下面列出了CORS请求中会用到的协议头字段以及说明：</p>\n<table>\n<thead>\n<tr>\n<th>协议头参数</th>\n<th>类型</th>\n<th>说明</th>\n<th>是否必须</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Origin</code></td>\n<td>请求头</td>\n<td>该字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。</td>\n<td>T</td>\n<td></td>\n</tr>\n<tr>\n<td><code>Access-Control-Request-Method</code></td>\n<td>请求头</td>\n<td>该字段用于预检请求，指名浏览器正式的CORS请求会用到的HTTP方法</td>\n<td>T</td>\n<td>发送预检请求时，必须包含</td>\n</tr>\n<tr>\n<td><code>Access-Control-Request-Headers</code></td>\n<td>请求头</td>\n<td>该字段用于预检请求，指名浏览器正式的CORS请求会额外发送的头信息字段</td>\n<td>T</td>\n<td>发送预检请求时，必须包含</td>\n</tr>\n<tr>\n<td><code>Access-Control-Allow-Origin</code></td>\n<td>响应头</td>\n<td>（同服务器配置字段含义）</td>\n<td>T</td>\n<td></td>\n</tr>\n<tr>\n<td><code>Access-Control-Expose-Headers</code></td>\n<td>响应头</td>\n<td>该字段指明服务器允许哪些响应头可以暴露给浏览器中运行的脚本（JS），以响应跨源请求。<br />在没有额外指明的情况下，CORS请求时，XMLHttpRequest对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<br /><code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。<br/>如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。</td>\n<td>F</td>\n<td></td>\n</tr>\n<tr>\n<td><code>Access-Control-Allow-Methods</code></td>\n<td>响应头</td>\n<td>（同服务器配置字段含义）</td>\n<td>T</td>\n<td></td>\n</tr>\n<tr>\n<td><code>Access-Control-Allow-Headers</code></td>\n<td>响应头</td>\n<td>（同服务器配置字段含义）</td>\n<td>F</td>\n<td></td>\n</tr>\n<tr>\n<td><code>Access-Control-Allow-Credentials</code></td>\n<td>响应头</td>\n<td>（同服务器配置字段含义）</td>\n<td>F</td>\n<td></td>\n</tr>\n<tr>\n<td><code>Access-Control-Max-Age</code></td>\n<td>响应头</td>\n<td>（同服务器配置字段含义）</td>\n<td>F</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"JSONP\"><a href=\"#JSONP\" class=\"headerlink\" title=\"JSONP\"></a>JSONP</h2><p>JSONP 的原理就是利用 <code>&lt;script&gt;</code> 标签的 <code>src</code> 属性没有跨域的限制，通过指向一个需要访问的地址，由服务端返回一个预先定义好的 <code>Javascript</code> 函数的调用，并且将服务器数据以该函数参数的形式传递过来，此方法需要前后端配合完成。</p>\n<ul>\n<li><code>script</code>标签 <code>src</code>可跨域</li>\n<li>将回调方法作为<code>get</code>参数传给后端</li>\n<li>后端返回一个<code>js</code>，调用这个回调，并把数据传给回调</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">//定义获取数据的回调方法</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getData</span>(<span class=\"hljs-params\">data</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(data);<br>&#125;<br><br><span class=\"hljs-comment\">// 创建一个script标签，并且告诉后端回调函数名叫 getData</span><br><span class=\"hljs-keyword\">var</span> body = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementsByTagName</span>(<span class=\"hljs-string\">&#x27;body&#x27;</span>)[<span class=\"hljs-number\">0</span>];<br><span class=\"hljs-keyword\">var</span> script = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">gerElement</span>(<span class=\"hljs-string\">&#x27;script&#x27;</span>);<br>script.<span class=\"hljs-property\">type</span> = <span class=\"hljs-string\">&#x27;text/javasctipt&#x27;</span>;<br>script.<span class=\"hljs-property\">src</span> = <span class=\"hljs-string\">&#x27;demo.js?callback=getData&#x27;</span>;<br>body.<span class=\"hljs-title function_\">appendChild</span>(script);<br><br><span class=\"hljs-comment\">//script 加载完毕之后从页面中删除,否则每次点击生成许多script标签</span><br>script.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span>.<span class=\"hljs-title function_\">removeChild</span>(script);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"服务器代理\"><a href=\"#服务器代理\" class=\"headerlink\" title=\"服务器代理\"></a>服务器代理</h2><p>浏览器对网络请求做了处理，所以通过从浏览器端发送的请求都会有跨域限制，但是服务器请求服务器就不存在这个问题。所以可以搭建一个代理服务器，将前端资源和代理服务器部署到一个域下，然后前端请求代理服务器，再通过代理服务器转发请求，从而实现请求跨域。</p>\n<h2 id=\"document-domain\"><a href=\"#document-domain\" class=\"headerlink\" title=\"document.domain\"></a>document.domain</h2><p>该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式。</p>\n<p>只需要给两个页面都添加 <code>document.domain = &#39;test.com&#39;</code>，通过在 <code>a.test.com</code> 创建一个 <code>iframe</code>，去控制 <code>iframe</code> 的 <code>window</code>，从而进行交互。</p>\n<h2 id=\"postMessage\"><a href=\"#postMessage\" class=\"headerlink\" title=\"postMessage\"></a>postMessage</h2><p><code>window.postMessage</code> 是一个 <code>HTML5</code> 的 <code>api</code>，允许两个窗口之间进行跨域发送消息。</p>\n<p>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// 发送消息端</span><br><span class=\"hljs-keyword\">var</span> receiver = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&#x27;receiver&#x27;</span>).<span class=\"hljs-property\">contentWindow</span>;<br><span class=\"hljs-keyword\">var</span> btn = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&#x27;send&#x27;</span>);<br>btn.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">e</span>) &#123;<br>    e.<span class=\"hljs-title function_\">preventDefault</span>();<br>    <span class=\"hljs-keyword\">var</span> val = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&#x27;text&#x27;</span>).<span class=\"hljs-property\">value</span>;<br>    receiver.<span class=\"hljs-title function_\">postMessage</span>(<span class=\"hljs-string\">&quot;Hello &quot;</span>+val+<span class=\"hljs-string\">&quot;！&quot;</span>, <span class=\"hljs-string\">&quot;http://res.42du.cn&quot;</span>);<br>&#125;); <br><br><span class=\"hljs-comment\">// 接收消息端</span><br><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;message&quot;</span>, receiveMessage, <span class=\"hljs-literal\">false</span>);<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">receiveMessage</span>(<span class=\"hljs-params\">event</span>)&#123;<br>  <span class=\"hljs-keyword\">if</span> (event.<span class=\"hljs-property\">origin</span> !== <span class=\"hljs-string\">&quot;http://www.42du.cn&quot;</span>)<br>    <span class=\"hljs-keyword\">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"需要跨域请求的情况\"><a href=\"#需要跨域请求的情况\" class=\"headerlink\" title=\"需要跨域请求的情况\"></a>需要跨域请求的情况</h1><ul>\n<li>由 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest\">XMLHttpRequest</a> 或者 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\">Fetch</a> 发起的跨源 HTTP 请求。</li>\n<li>Web 字体 (CSS 中通过<code>@font-face</code>使用跨源字体资源)，<a href=\"https://www.w3.org/TR/css-fonts-3/#font-fetching-requirements\">因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用</a>。</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL\">WebGL 贴图</a></li>\n<li>使用 <code>drawImage</code> 将 <code>Images/video</code> 画面绘制到 <code>canvas</code></li>\n</ul>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li><a href=\"https://juejin.im/post/6844903816060469262\">彻底理解浏览器的跨域</a></li>\n<li><a href=\"https://www.ruanyifeng.com/blog/2016/04/cors.html\">跨域资源共享 CORS 详解</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000004322487\">你真的会使用XMLHttpRequest吗？</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS\">跨源资源共享（CORS）</a></li>\n<li><a href=\"https://juejin.cn/post/6844903767226351623\">九种跨域方式实现原理（完整版）</a></li>\n</ul>\n","site":{"data":{"languages/zh-CN":{"name":"简体中文","home":{"menu":"首页","title":"首页"},"archive":{"menu":"归档","title":"归档","subtitle":"归档","post_total":"共计 %d 篇文章"},"category":{"menu":"分类","title":"分类","subtitle":"分类","post_total":"共计 %d 篇文章","more":"More..."},"tag":{"menu":"标签","title":"标签","subtitle":"标签","post_total":"共计 %d 篇文章"},"about":{"menu":"关于","title":"关于","subtitle":"关于"},"links":{"menu":"友链","title":"友链","subtitle":"友情链接"},"page404":{"menu":"页面不存在","title":"页面不存在","subtitle":"页面不存在"},"post":{"toc":"目录","prev_post":"上一篇","next_post":"下一篇","updated":"本文最后更新于：%s","meta":{"wordcount":"%s 字","min2read":"%s 分钟","views":"{} 次"},"copyright":{"author":"作者","posted":"发布于","updated":"更新于","licensed":"许可协议","CC":"CC - 知识共享许可协议","BY":"BY - 署名","SA":"SA - 相同方式共享","NC":"NC - 非商业性使用","ND":"ND - 禁止演绎"}},"footer":{"pv":"总访问量 {} 次","uv":"总访客数 {} 人"},"search":{"title":"搜索","keyword":"关键词"},"noscript_warning":"博客在允许 JavaScript 运行的环境下浏览效果更佳"}}},"more":"<h1 id=\"同源策略\"><a href=\"#同源策略\" class=\"headerlink\" title=\"同源策略\"></a>同源策略</h1><h2 id=\"什么是同源策略\"><a href=\"#什么是同源策略\" class=\"headerlink\" title=\"什么是同源策略\"></a>什么是同源策略</h2><p>同源策略是一个重要的<strong>安全策略</strong>，它用于<strong>限制</strong>一个源（origin）的文档或者它加载的脚本如何能与另一个源的资源进行<strong>交互</strong>。非同源下的文档和脚本（JS），不能跨域获取资源。</p>\n<p>其中<strong>同源</strong>是指：</p>\n<ul>\n<li>协议相同</li>\n<li>域名相同</li>\n<li>端口相同</li>\n</ul>\n<h2 id=\"为什么会存在同源策略\"><a href=\"#为什么会存在同源策略\" class=\"headerlink\" title=\"为什么会存在同源策略\"></a>为什么会存在同源策略</h2><p>同源策略是<strong>浏览器</strong>为了<strong>保护用户信息安全</strong>所执行的策略。1995年由 Netscape 公司引入的，目前所有的<strong>浏览器</strong>都执行这个策略。</p>\n<p>因为它的主要目的是为了保证用户信息安全，所以只要涉及到用户信息的获取途径都会被<strong>限制</strong>，这些信息获取途径包括：</p>\n<ul>\n<li>通过操作<strong>其他网站</strong>或者 <strong>iframe</strong>的 <code>dom</code> 来获取用户的表单数据</li>\n<li>通过获取<code>cookie</code>，<code>localstorge</code>，<code>sessionstorage</code>，<code>indexDB</code>等缓存信息，来获取用户信息</li>\n<li>通过发送 <code>ajax / fetch</code> 请求，来获取后端的用户信息（提交表单不受跨域限制）</li>\n</ul>\n<p>如果不对这些途径加以限制，就可能被恶意网站盗取用户信息。那么恶意是如何通过这几种途径获取信息的呢？举几个案例（来源于<a href=\"https://juejin.im/post/6844903816060469262\">彻底理解浏览器的跨域</a>）：</p>\n<blockquote>\n<p>一、cookie获取发送请求</p>\n<p>A 网站是一家银行，用户登录以后，A 网站在用户的机器上设置了一个 Cookie，包含了一些隐私信息（比如存款总额）。用户离开 A 网站以后，又去访问 B 网站，如果没有同源限制，B 网站可以读取 A 网站的 Cookie，那么隐私信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。<br>例如</p>\n<ol>\n<li>用户登录了自己的银行页面 <a href=\"http://mybank.com/\">http://mybank.com</a>，<a href=\"https://www.notion.so/b4dda8a6ca0b4a308ed8dd5d5f77861a\">mybank.com</a> 向用户的cookie中添加用户标识。</li>\n<li>用户浏览了恶意页面 <a href=\"http://evil.com/\">evil.com</a>。执行了页面中的恶意AJAX请求代码。</li>\n<li>向<a href=\"http://mybank.com发起ajax/\">http://mybank.com发起AJAX</a> HTTP请求，请求会默认把<a href=\"http://mybank.com对应cookie也同时发送过去./\">http://mybank.com对应cookie也同时发送过去。</a></li>\n<li>银行页面从发送的cookie中提取用户标识，验证用户无误，response中返回请求数据。此时数据就泄露了。</li>\n<li>而且由于Ajax在后台执行，用户无法感知这一过程。</li>\n</ol>\n<p>二、dom操作</p>\n<ol>\n<li>做一个假网站，里面用iframe嵌套一个银行网站 <a href=\"http://mybank.com/\">mybank.com</a>。</li>\n<li>把iframe宽高啥的调整到页面全部，这样用户进来除了域名，别的部分和银行的网站没有任何差别。</li>\n<li>这时如果用户输入账号密码，我们的主网站可以跨域访问到<a href=\"http://mybank.com的dom节点,就可以拿到用户的输入了,那么就完成了一次攻击/\">http://mybank.com的dom节点，就可以拿到用户的输入了，那么就完成了一次攻击</a></li>\n</ol>\n</blockquote>\n<p>所以针对这三点，浏览器做了同源限制：</p>\n<ul>\n<li><p>无法获取跨域缓存：<code>cookie</code> <code>localstorge</code> <code>indexDB</code> 等</p>\n</li>\n<li><p>无法访问非同源网页的<code> DOM （iframe）</code>。</p>\n</li>\n<li><p>无法向非同源地址发送 <code>AJAX</code> 请求 或 <code>Fetch</code> 请求（可以发送，但浏览器拒绝接受响应）。</p>\n</li>\n</ul>\n<p>总结一下：</p>\n<p>同源策略实际就是浏览器为了保证用户信息安全的策略，限制只有同源的文档或者脚本才能进行交互。其中同源是指<strong>协议</strong>、<strong>域名</strong>、<strong>端口</strong>三点相同。通过限制用户（一般是指开发者）通过操作<code>dom</code>、获取缓存信息以及发送<code>ajax / fetch</code> 请求等方式来获取用户信息来保证用户信息安全。</p>\n<h1 id=\"解决跨域通信\"><a href=\"#解决跨域通信\" class=\"headerlink\" title=\"解决跨域通信\"></a>解决跨域通信</h1><p>我们在开发中，避免不了要跨域获取信息，其中最常见的就是发送跨域请求（<code>ajax / fetch</code>）来获取资源。那么解决跨域通信问题就成了我们的日常。根据浏览器的同源限制，我们将解决跨域通信分为2个方向：</p>\n<ul>\n<li>针对<strong>跨域的网络请求</strong>，需要前后端配合操作来解决，主要方法包括：<ul>\n<li>CORS</li>\n<li>JSONP</li>\n<li>服务器代理</li>\n</ul>\n</li>\n<li>针对DOM级别的操作，我们只需要通过前端解决，主要方法包括：<ul>\n<li><code>postMassage</code>（HTML5 的 api， 允许两个窗口之间进行跨域发送消息）</li>\n<li><code>document.domain</code>（只能用于一、二级域名都相同的情况）</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>通信侧</th>\n<th>方法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>前端</td>\n<td><code>postMassage</code>（HTML5 的 api， 允许两个窗口之间进行跨域发送消息）、<br /><code>document.domain</code>（只能用于一、二级域名都相同的情况）</td>\n</tr>\n<tr>\n<td>前后端</td>\n<td><code>CORS</code>、<code>jsonp</code>、服务器代理</td>\n</tr>\n</tbody></table>\n<h2 id=\"CORS\"><a href=\"#CORS\" class=\"headerlink\" title=\"CORS\"></a>CORS</h2><p>CORS（<strong>跨域资源共享  Cross-origin resource sharing）</strong>是W3C标准，它允许浏览器向跨域服务器发出请求，解决了<strong>同源限制中AJAX 请求无法跨域</strong>的问题。这种跨域通信解决方案不需要用户做额外的操作，是浏览器和服务器共同实现的。</p>\n<p>在浏览器端，不需要用户额外配置，当用户在浏览器发送AJAX请求（例如在js代码中发起了ajax请求），浏览器会自动处理HTTP请求，同时会对服务器端返回的响应进行拦截处理，判断该响应是否同源，进而决定是返回正常的响应还是抛出错误。</p>\n<p>而服务器则需要手动配置CORS接口，实现对跨域请求的处理。常用的<strong>服务器CORS配置字段</strong>如下：</p>\n<table>\n<thead>\n<tr>\n<th>协议头参数</th>\n<th>说明</th>\n<th>是否必须</th>\n<th align=\"left\">备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Access-Control-Allow-Origin</code></td>\n<td>表示允许跨域请求的域 值为：<br />- 通配符<code>*</code>：接受任何域的跨域访问<br /><code>&lt;origin&gt;</code>：指定一个来源（只能指定一个）<br /><code>null</code> ：指定来源为 <code>null</code> <br />此时实际上就是不接受跨域，但是不推荐设置为该值。<br />因为浏览器在进行<code>CORS</code>判定时只会判断<code>Access-Control-Allow-Origin</code>字段是否存在而不会判断该字段的值，所以设置为<code>null</code>会导致安全问题</td>\n<td>T</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td><code>Access-Control-Allow-Methods</code></td>\n<td>服务器允许跨域请求的 <code>http</code> 方法列表</td>\n<td>T</td>\n<td align=\"left\">响应预检请求时，必须包含</td>\n</tr>\n<tr>\n<td><code>Access-Control-Allow-Headers</code></td>\n<td>列出了服务器支持的所有头信息字段，<br />这些字段可以用于预检请求的<code>Access-Control-Request-Headers</code></td>\n<td>F</td>\n<td align=\"left\">当预请求（<code>OPTIONS</code>）中包含<code>Access-Control-Request-Headers</code>时，服务器必须设置该字段配置</td>\n</tr>\n<tr>\n<td><code>Access-Control-Allow-Credentials</code></td>\n<td>表示是否允许发送Cookie，只有一个可选值：true（必为小写）。<br />如果不发送cookie，则直接省略，不写为false</td>\n<td>F</td>\n<td align=\"left\">CORS请求默认不发送<code>Cookie</code>和HTTP认证信息<br />要携带这些信息，需要发送方和服务器配置<br />服务器配置：<br />- <code>Access-Control-Allow-Credentials</code>为<code>true</code><br />- <code>Access-Control-Allow-Origin</code>不能为<code>*</code>，必须指定域名<br />发送方（JS）:<br/>开发者必须在AJAX请求中打开<code>withCredentials</code>属性</td>\n</tr>\n<tr>\n<td><code>Access-Control-Max-Age</code></td>\n<td>以秒为单位的缓存时间在有效时间内，<br />浏览器无须为同一请求再次发起预检请求</td>\n<td>F</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p>在Nginx中的配置：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-string\">location</span> <span class=\"hljs-string\">/</span> &#123;  <br>    <span class=\"hljs-string\">add_header</span> <span class=\"hljs-string\">Access-Control-Allow-Origin</span> <span class=\"hljs-string\">*;</span><br>    <span class=\"hljs-string\">add_header</span> <span class=\"hljs-string\">Access-Control-Allow-Methods</span> <span class=\"hljs-string\">&#x27;GET, POST, OPTIONS&#x27;</span><span class=\"hljs-string\">;</span><br>    <span class=\"hljs-string\">add_header</span> <span class=\"hljs-string\">Access-Control-Allow-Headers</span> <span class=\"hljs-string\">&#x27;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization&#x27;</span><span class=\"hljs-string\">;</span><br>\t\t<span class=\"hljs-string\">add_header</span> <span class=\"hljs-string\">Access-Control-Allow-Credentials</span> <span class=\"hljs-string\">&#x27;true&#x27;</span><span class=\"hljs-string\">;</span><br>\t\t<span class=\"hljs-string\">add_header</span> <span class=\"hljs-string\">Access-Control-Max-Age</span> <span class=\"hljs-number\">86400</span><span class=\"hljs-string\">;</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"CORS的判定流程\"><a href=\"#CORS的判定流程\" class=\"headerlink\" title=\"CORS的判定流程\"></a>CORS的判定流程</h3><p>CORS基本判定流程如图所示，主要分为三个阶段：</p>\n<ol>\n<li><strong>浏览器发起请求</strong>：处理请求头，增加<code>Origin</code>字段</li>\n<li><strong>服务器处理请求，并返回响应</strong>：服务器接收请求，根据当前服务器的CORS配置决定是否在响应头中写入<code>Access-Control-Allow-Origin</code>，并返回正常HTTP响应（注意，因为这里无论是否接收跨域请求，服务器都会返回一个正常HTTP响应，所以无法通过状态码来判断跨域请求是否成功）：<ol>\n<li>服务器已配置CORS，写入该字段</li>\n<li>服务器未配置CORS，不写入该字段</li>\n</ol>\n</li>\n<li><strong>浏览器处理响应</strong>：检查响应头是否存在<code>Access-Control-Allow-Origin</code>：<ol>\n<li>存在，服务器不允许跨域，浏览器抛出错误，错误类型为：<code>No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource.</code></li>\n<li>不存在，浏览器进一步比对该值是否包含当前域的值：<ol>\n<li>包含，服务器同意该源的跨域请求，浏览器正常返回响应</li>\n<li>不包含，服务器允许跨域请求，但拒绝当前源的请求，浏览器抛出错误，错误类型为：<code>The &#39;Access-Control-Allow-Origin&#39; header has a value &#39;[http://xxx.com](http://xxx.com/)&#39; that is not equal to the supplied origin.</code></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/206ffba5f7094472b7f81527a21c60a6~tplv-k3u1fbpfcp-watermark.image?\" alt=\"3.png\" width=\"100%\" />\n\n<p>在这三个阶段中，根据请求类型（<strong>简单请求 / 非简单请求</strong>）的不同，具体的流程处理和操作也会不一致。</p>\n<h3 id=\"简单请求和非简单请求\"><a href=\"#简单请求和非简单请求\" class=\"headerlink\" title=\"简单请求和非简单请求\"></a>简单请求和非简单请求</h3><p>什么是简单请求和非简单请求呢？实际上这个可以理解为根据当前请求的信息载量来进行区分的。对于信息载量较少的就是简单请求，信息载量多的就是非简单请求。对于这两种请求类型，有明确的定义。</p>\n<h4 id=\"简单请求\"><a href=\"#简单请求\" class=\"headerlink\" title=\"简单请求\"></a>简单请求</h4><ol>\n<li>使用 <code>GET、POST、HEAD</code> 其中一种请求方法。</li>\n<li>HTTP的头信息不超出以下几种字段：</li>\n</ol>\n<ul>\n<li><code>Accept</code></li>\n<li><code>Accept-Language</code></li>\n<li><code>Content-Language</code></li>\n<li><code>Last-Event-ID</code></li>\n<li><code>Content-Type</code>：只限于三个值 <code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code><ul>\n<li>这三个值也是直接用表单提交可以设置的值</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li><code>XMLHttpRequestUpload</code>：<ol>\n<li>请求中的任意<code>XMLHttpRequestUpload</code> 对象均没有注册任何事件监听器；</li>\n<li><code>XMLHttpRequestUpload</code> 对象可以使用 <code>XMLHttpRequest.upload</code> 属性访问。 </li>\n</ol>\n</li>\n<li>请求中没有使用 <code>ReadableStream</code> 对象。</li>\n</ol>\n<p>对于简单请求类型，整个CORS流程没什么变化（如上图一致），浏览器在第一阶段处理请求时，会直接在当前请求的请求头中增加<code>Origin</code>字段然后发送给服务器。</p>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58388e59c5c346039dcb6ac020b7ff80~tplv-k3u1fbpfcp-watermark.image?\" alt=\"1.png\" width=\"100%\" />\n\n<h4 id=\"非简单请求\"><a href=\"#非简单请求\" class=\"headerlink\" title=\"非简单请求\"></a>非简单请求</h4><p>除了简单请求，其他的都是非简单请求。</p>\n<p>非简单请求的流程有所不同。对于非简单请求，浏览器会在正式通信之前，增加一次HTTP查询请求，称为“预检“请求（preflight）。只有通过了预检请求，浏览器才会发出正式通信。这里预检请求的方法是<code>OPTIONS</code> 。一次非简单请求的流程如下：</p>\n<ul>\n<li>浏览器发起<code>OPTIONS</code>请求：当浏览器发现当前的请求是非简单请求，会先发起<code>OPTIONS</code> 请求。在<code>OPTIONS</code>的请求头中增加3个字段：<ul>\n<li><code>Origin</code></li>\n<li><code>Access-Control-Request-Method</code>：列出浏览器的<strong>正式请求</strong>中会用到的HTTP方法。</li>\n<li><code>Access-Control-Request-Headers</code>：指定浏览器的<strong>正式请求</strong>中会额外需要发送哪些头信息字段。</li>\n</ul>\n</li>\n<li>服务器接收<code>OPTIONS</code>请求，返回响应：服务器收到请求后，会检查服务器的CORS配置和请求头中CORS字段，决定如何返回响应：<ul>\n<li>服务器<strong>未配置CORS接口 or</strong> 服务器配置的CORS接口和请求头中的<strong>CORS字段不匹配</strong>：服务器<strong>否定</strong>此次预检请求，返回正常的HTTP响应，响应头中不包含CORS相关字段<code>（未配置 || 不匹配 ⇒ 否定：不包含）</code>。</li>\n<li>服务器<strong>已配置 and</strong> 配置的CORS接口和请求头的<strong>CORS字段匹配</strong>：服务器<strong>肯定</strong>此次预检请求，返回正常的HTTP响应，响应头中包含CORS相关字段<code>（配置 &amp;&amp; 匹配 ⇒ 肯定：包含）</code>；</li>\n</ul>\n</li>\n<li>浏览器处理响应：当浏览器接收到服务器的响应之后，检查响应头是否包含CORS相关字段：<ul>\n<li>不包含，浏览器抛出错误</li>\n<li>包含，服务器肯定此次预检请求，浏览器发出正式的<code>CORS</code>请求获取数据，这个正式的CORS请求的流程和简单请求一致。</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6503b02ce11748148b8653877f306e79~tplv-k3u1fbpfcp-watermark.image?\" alt=\"2.png\" width=\"100%\" />\n\n\n<p>下面列出了CORS请求中会用到的协议头字段以及说明：</p>\n<table>\n<thead>\n<tr>\n<th>协议头参数</th>\n<th>类型</th>\n<th>说明</th>\n<th>是否必须</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Origin</code></td>\n<td>请求头</td>\n<td>该字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。</td>\n<td>T</td>\n<td></td>\n</tr>\n<tr>\n<td><code>Access-Control-Request-Method</code></td>\n<td>请求头</td>\n<td>该字段用于预检请求，指名浏览器正式的CORS请求会用到的HTTP方法</td>\n<td>T</td>\n<td>发送预检请求时，必须包含</td>\n</tr>\n<tr>\n<td><code>Access-Control-Request-Headers</code></td>\n<td>请求头</td>\n<td>该字段用于预检请求，指名浏览器正式的CORS请求会额外发送的头信息字段</td>\n<td>T</td>\n<td>发送预检请求时，必须包含</td>\n</tr>\n<tr>\n<td><code>Access-Control-Allow-Origin</code></td>\n<td>响应头</td>\n<td>（同服务器配置字段含义）</td>\n<td>T</td>\n<td></td>\n</tr>\n<tr>\n<td><code>Access-Control-Expose-Headers</code></td>\n<td>响应头</td>\n<td>该字段指明服务器允许哪些响应头可以暴露给浏览器中运行的脚本（JS），以响应跨源请求。<br />在没有额外指明的情况下，CORS请求时，XMLHttpRequest对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<br /><code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。<br/>如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。</td>\n<td>F</td>\n<td></td>\n</tr>\n<tr>\n<td><code>Access-Control-Allow-Methods</code></td>\n<td>响应头</td>\n<td>（同服务器配置字段含义）</td>\n<td>T</td>\n<td></td>\n</tr>\n<tr>\n<td><code>Access-Control-Allow-Headers</code></td>\n<td>响应头</td>\n<td>（同服务器配置字段含义）</td>\n<td>F</td>\n<td></td>\n</tr>\n<tr>\n<td><code>Access-Control-Allow-Credentials</code></td>\n<td>响应头</td>\n<td>（同服务器配置字段含义）</td>\n<td>F</td>\n<td></td>\n</tr>\n<tr>\n<td><code>Access-Control-Max-Age</code></td>\n<td>响应头</td>\n<td>（同服务器配置字段含义）</td>\n<td>F</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"JSONP\"><a href=\"#JSONP\" class=\"headerlink\" title=\"JSONP\"></a>JSONP</h2><p>JSONP 的原理就是利用 <code>&lt;script&gt;</code> 标签的 <code>src</code> 属性没有跨域的限制，通过指向一个需要访问的地址，由服务端返回一个预先定义好的 <code>Javascript</code> 函数的调用，并且将服务器数据以该函数参数的形式传递过来，此方法需要前后端配合完成。</p>\n<ul>\n<li><code>script</code>标签 <code>src</code>可跨域</li>\n<li>将回调方法作为<code>get</code>参数传给后端</li>\n<li>后端返回一个<code>js</code>，调用这个回调，并把数据传给回调</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">//定义获取数据的回调方法</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getData</span>(<span class=\"hljs-params\">data</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(data);<br>&#125;<br><br><span class=\"hljs-comment\">// 创建一个script标签，并且告诉后端回调函数名叫 getData</span><br><span class=\"hljs-keyword\">var</span> body = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementsByTagName</span>(<span class=\"hljs-string\">&#x27;body&#x27;</span>)[<span class=\"hljs-number\">0</span>];<br><span class=\"hljs-keyword\">var</span> script = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">gerElement</span>(<span class=\"hljs-string\">&#x27;script&#x27;</span>);<br>script.<span class=\"hljs-property\">type</span> = <span class=\"hljs-string\">&#x27;text/javasctipt&#x27;</span>;<br>script.<span class=\"hljs-property\">src</span> = <span class=\"hljs-string\">&#x27;demo.js?callback=getData&#x27;</span>;<br>body.<span class=\"hljs-title function_\">appendChild</span>(script);<br><br><span class=\"hljs-comment\">//script 加载完毕之后从页面中删除,否则每次点击生成许多script标签</span><br>script.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span>.<span class=\"hljs-title function_\">removeChild</span>(script);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"服务器代理\"><a href=\"#服务器代理\" class=\"headerlink\" title=\"服务器代理\"></a>服务器代理</h2><p>浏览器对网络请求做了处理，所以通过从浏览器端发送的请求都会有跨域限制，但是服务器请求服务器就不存在这个问题。所以可以搭建一个代理服务器，将前端资源和代理服务器部署到一个域下，然后前端请求代理服务器，再通过代理服务器转发请求，从而实现请求跨域。</p>\n<h2 id=\"document-domain\"><a href=\"#document-domain\" class=\"headerlink\" title=\"document.domain\"></a>document.domain</h2><p>该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式。</p>\n<p>只需要给两个页面都添加 <code>document.domain = &#39;test.com&#39;</code>，通过在 <code>a.test.com</code> 创建一个 <code>iframe</code>，去控制 <code>iframe</code> 的 <code>window</code>，从而进行交互。</p>\n<h2 id=\"postMessage\"><a href=\"#postMessage\" class=\"headerlink\" title=\"postMessage\"></a>postMessage</h2><p><code>window.postMessage</code> 是一个 <code>HTML5</code> 的 <code>api</code>，允许两个窗口之间进行跨域发送消息。</p>\n<p>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// 发送消息端</span><br><span class=\"hljs-keyword\">var</span> receiver = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&#x27;receiver&#x27;</span>).<span class=\"hljs-property\">contentWindow</span>;<br><span class=\"hljs-keyword\">var</span> btn = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&#x27;send&#x27;</span>);<br>btn.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">e</span>) &#123;<br>    e.<span class=\"hljs-title function_\">preventDefault</span>();<br>    <span class=\"hljs-keyword\">var</span> val = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&#x27;text&#x27;</span>).<span class=\"hljs-property\">value</span>;<br>    receiver.<span class=\"hljs-title function_\">postMessage</span>(<span class=\"hljs-string\">&quot;Hello &quot;</span>+val+<span class=\"hljs-string\">&quot;！&quot;</span>, <span class=\"hljs-string\">&quot;http://res.42du.cn&quot;</span>);<br>&#125;); <br><br><span class=\"hljs-comment\">// 接收消息端</span><br><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;message&quot;</span>, receiveMessage, <span class=\"hljs-literal\">false</span>);<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">receiveMessage</span>(<span class=\"hljs-params\">event</span>)&#123;<br>  <span class=\"hljs-keyword\">if</span> (event.<span class=\"hljs-property\">origin</span> !== <span class=\"hljs-string\">&quot;http://www.42du.cn&quot;</span>)<br>    <span class=\"hljs-keyword\">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"需要跨域请求的情况\"><a href=\"#需要跨域请求的情况\" class=\"headerlink\" title=\"需要跨域请求的情况\"></a>需要跨域请求的情况</h1><ul>\n<li>由 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest\">XMLHttpRequest</a> 或者 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\">Fetch</a> 发起的跨源 HTTP 请求。</li>\n<li>Web 字体 (CSS 中通过<code>@font-face</code>使用跨源字体资源)，<a href=\"https://www.w3.org/TR/css-fonts-3/#font-fetching-requirements\">因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用</a>。</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL\">WebGL 贴图</a></li>\n<li>使用 <code>drawImage</code> 将 <code>Images/video</code> 画面绘制到 <code>canvas</code></li>\n</ul>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li><a href=\"https://juejin.im/post/6844903816060469262\">彻底理解浏览器的跨域</a></li>\n<li><a href=\"https://www.ruanyifeng.com/blog/2016/04/cors.html\">跨域资源共享 CORS 详解</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000004322487\">你真的会使用XMLHttpRequest吗？</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS\">跨源资源共享（CORS）</a></li>\n<li><a href=\"https://juejin.cn/post/6844903767226351623\">九种跨域方式实现原理（完整版）</a></li>\n</ul>\n"},{"title":"浏览器缓存策略","date":"2023-03-03T09:42:33.000Z","excerpt":"众所周知，web开发过程中，网页资源响应速度一直是作为网站性能好坏的重要评估标准之一，而缓存技术一直以来在WEB技术体系中都扮演着非常重要的角色，通过缓存技术以及相应的缓存命中策略可以缩短网络请求时间，通过将耗时计算以及耗时传输的结果存起来，在不发生变更的情况下直接复用该结果，从而在保证结果正确性的同时大大提高网站的性能。","_content":"# 前言\n\n众所周知，web开发过程中，网页资源响应速度一直是作为网站性能好坏的重要评估标准之一，而缓存技术一直以来在WEB技术体系中都扮演着非常重要的角色，通过缓存技术以及相应的缓存命中策略可以缩短网络请求时间，通过将耗时计算以及耗时传输的结果存起来，在不发生变更的情况下直接复用该结果，从而在保证结果正确性的同时大大提高网站的性能。\n\n> 在实际WEB开发过程中，缓存技术会涉及到不同层、不同端，比如：用户层、系统层、代理层、前端、后端、服务端等，**每一层的缓存目标都是一致的，就是尽快返回请求数据、减少延迟**，但每层使用的技术实现是各有不同，面对不同层、不同端的优劣，选用不同的技术来提升系统响应效率。如图展示了各层相关的缓存技术：\n><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/947553dab6904876a2deccc67ef27eb8~tplv-k3u1fbpfcp-watermark.image?\" alt=\"Untitled.png\" width=\"100%\" />\n\n如上图所示，**浏览器缓存**属于用户层的缓存技术，它的主要任务就是一个把已经请求过的web资源（`html`，`js`，`css`，`image`…）拷贝一份副本到本地，在下一次再次请求该资源时，根据缓存命中机制选择是使用这份副本来直接响应请求，还是向源服务器重新请求最新的资源。\n\n浏览器缓存也是前端开发中最常会接触到的缓存技术，当我们开发了最新的版本之后，需要将打包结果也就是静态资源（`html，js，css`）部署到服务器上。此时因为浏览器缓存，可能存在即使已经在服务器上更新了资源，但是用户进入网站时并不会看到最新的版本，这里就需要我们了解浏览器的缓存，从而避免这种情况的发生；同时还要利用缓存技术，缓存不常更新的静态资源，提高用户打开网页的速度。\n\n接下来就详细的了解一下浏览器缓存。\n\n\n# 查看浏览器缓存\n## 缓存对象\n首先浏览器缓存的对象是一次HTTP响应报文的整体，包括响应行，响应头和响应体。其中，常见的HTTP请求方法中只能存储GET响应。通过在`firefox`的`about:cache`我们可以查看到浏览器缓存的HTTP响应：\n\n打开`baidu.com`，查看`network`控制面板，找到任意一个`js`资源，记住资源名：\n<img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f45247da25be4526882aa52250cf763d~tplv-k3u1fbpfcp-watermark.image?\" alt=\"Untitled 1.png\" width=\"100%\" />\n\n查看`firefox`缓存：\n<img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/812c0386d15f46ba99364f574b3620cd~tplv-k3u1fbpfcp-watermark.image?\" alt=\"Untitled 2.png\" width=\"100%\" />\n\n`disk cache`的所有缓存内容列表：\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8fd74bfec9a49ff84083287439bfe87~tplv-k3u1fbpfcp-watermark.image?\" alt=\"Untitled 3.png\" width=\"100%\" />\n\n找到刚才的`js`资源名，打开查看缓存内容：\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d28440dbdaae49c3b718c3331595813c~tplv-k3u1fbpfcp-watermark.image?\" alt=\"Untitled 4.png\" width=\"100%\" />\n\n但是并不是所有的GET响应都会被浏览器缓存，只要状态码为以下这些时，响应才会被缓存：\n\n- `200`：一个检索请求的成功响应\n    - HTML文档、js、css、图片、字体文件等\n- `301`：永久重定向\n- `404`：错误响应\n- `206`：不完全响应\n\n## 资源缓存位置\n\n> 浏览器获取缓存的顺序为 Service Worker Cache、Memory Cache、Disk Cache、（至于 Push Cache 属于 HTTP2 待验证）。\n> \n- `from memory cache`：是把资源存到内存中，当进程退出时（关闭浏览器），内存中的数据会清空，下次访问要执行别的缓存策略。\n- `from disk cache`：是把资源缓存在磁盘中，进程退出时不受影响，下次访问可以继续执行此次缓存策略。\n- `Sevice Worker Cache（https）`：开发者人为存储的永久性存储，用于离线缓存的处理。`Application -> Cache Storage` 查看。\n- `Push Cache（http2）`：Push Cache 是 HTTP2 在 sever push 阶段存在的缓存。\n\n\n# 浏览器缓存策略\n\n缓存命中机制主要分为两个阶段：**强缓存**和**协商缓存。其中无论是哪种缓存命中，最终使用的都是浏览器缓存到本地的资源。区别在于强缓存不发生网络请求。**\n\n**强缓存**主要是浏览器自行判断资源是否过期，如果不过期则直接使用缓存的资源（强缓存命中），不再进行网络请求；\n\n**协商缓存**则是在强缓存阶段无法命中的情况下，浏览器发起请求，询问服务器是否可以使用本地缓存资源，如果服务器检查发现浏览器本地的资源没有过期，则返回304告诉浏览器可以使用本地的缓存资源（协商缓存命中）；\n\n如果**强缓存和协商缓存都没有命中**的情况下，服务器会返回最新的资源，浏览器拿到资源后会更新缓存的资源信息。\n\n当前资源是否能被缓存以及是否能通过浏览器缓存机制命中（浏览器是否启动缓存），主要是服务器来设置。当该资源首次被请求时，**服务器通过设置HTTP响应的响应头来设置该资源的缓存信息。**主要是以下几个字段：\n\n- `Expires`\n- `cache-control`\n- `Etag`\n- `Last-Modified`\n\n\n## 强缓存\n> **强缓存是利用`Expires`或者`Cache-Control`这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期。**\n\n强缓存就是直接由浏览器判断缓存是否命中，**不经过网络**。当浏览器发起HTTP请求前，首先会查看当前的缓存列表，找到该资源的响应头，拿到`Cache-Control`或者`Expires`字段，通过对两个字段判断强缓存是否命中。当强缓存命中时，HTTP状态码为200，资源从缓存中加载（ `from memory cache` / `from disk cache`）。\n\n**优先级**：其中`Cache-Control` 的优先级大于`Expires` ，其实还有个`Pragma` 字段，它的优先级最高，但是不常用。\n\n通过控制台`Network` 面板查看：\n\n\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/155d9d56354d41d2b26318fc15028abf~tplv-k3u1fbpfcp-watermark.image?\" alt=\"Untitled 5.png\" width=\"100%\" />\n\n\n\n### `Expires` （优先级最低）\n\n- HTTP 1.0 用于缓存管理的`header`字段，由服务器返回，用GMT格式的字符串表示。\n- 值表示一个资源过期的时间，描述的是绝对时间，且该绝对时间属于服务端的时间系统。\n- 判断方法：浏览器发起下一次请求时，当前HTTP发起的请求时间 `(this http request time) < (expires设置的值)`，资源没有过期，缓存命中。\n- 弊端：`Expires`遵循的是服务端的时间系统，而请求时间遵循的是客户端的时间系统，如果两者时间不是一致的，就可能产生误差。例如手动修改本地客户端的时间，那么就可能影响缓存命中结果。\n\n\n\n### `Cache-Control`（优先级第二）\n\n为了解决Expires因为客户端和服务器端时间不统一带来的问题，HTTP 1.1 提出了新的`header` 也就是 `Cache-Control` ，这个字段使用相对时间，进行比较的时候用的都是客户端的时间，相对来更有效与安全。\n\n- HTTP 1.1\n- 值是一个相对时间，以秒为单位，用数值表示\n- 判断方法：浏览器发起下一次请求时，当前HTTP发起的请求时间`(this http request time) < (last http request time + cache-control 设置的值)` ，资源没有过期，缓存命中。\n\n```jsx\nCache-Control: public, max-age=31536000\n```\n\n该`header`字段的其他取值如下：\n\n| 字段名 | 位置 | 说明 |\n| --- | --- | --- |\n| no-cache | 请求头,响应头 | 强制客户端向服务器发送请求（禁止**强缓存**）。这个值不是禁止客户端或者代理服务器缓存响应。 |\n| no-store | 请求头,响应头 | 禁止一切缓存。客户端和代理服务器都不能缓存响应。 |\n| max-age | 请求头,响应头 | 设置资源（representations）可以被缓存多长时间，单位是秒。 |\n| no-transform | 请求头,响应头 | 代理不可更改媒体类型 |\n| cache-extension | 请求头,响应头 | 新指令标记（token） |\n| s-maxage | 响应头 | 和max-age同理，只不过是针对代理服务器缓存而言。 |\n| private | 响应头 | 不能被代理服务器缓存 |\n| public | 响应头 | 响应可以被任何缓存区缓存 |\n| must-revalidate | 响应头 | 在缓存过期前可以使用，缓存过期以后必须向服务器验证。 |\n| proxy-revalidate | 响应头 | 要求中间缓存服务器对缓存的响应有效性需再次确认（代理服务器需要发送请求给服务器端确认资源有效性，不能直接返回缓存） |\n| only-if-cached | 请求头 | 从缓存中获取资源 |\n| min-fresh | 请求头 | 单位：秒，期望在指定的时间内，响应仍有效 |\n| max-stale | 请求头 | 单位：秒， 接受已过期的响应 |\n\n\n### `Pragma` （优先级最高）\n除了 `Expires`和`Cache-Control`以外，还有`Pragma`字段，但是这个字段用得很少，它只有一个值就是 `no-cache`，含义等同于`Cache-Control` 取值为 `no-cache`，表示禁止强缓存，强制客户端发送http请求给客户端。\n\n\n## 协商缓存\n\n协商缓存是指，当强缓存没有命中的情况下，浏览器会发送http请求给服务端，此时服务端并不会直接处理请求，而是会再进行一次缓存命中判断，这个就是协商缓存。如果缓存命中成功，则会返回一个304的状态码，告诉浏览器当前资源没有过期。浏览器接收到304响应后，就会使用本地缓存的响应。\n\n> 304响应是一个只有响应头，响应体为空的响应。\n\n\n>![Untitled 6.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e69def0f32c141e0827436b8ec8cc2df~tplv-k3u1fbpfcp-watermark.image?)\n\n### `Last-Modified` / `If-Modified-Since`\n\n- 该字段是资源最后的修改时间。\n- 浏览器发送请求时，会将上次响应头中的 `Last-Modified` 赋值给 本次请求头中的 `If-Modified-Since` 字段。服务端中接收到请求之后，会将这个字段和当前资源最后的修改时间做对比，\n    - 如果 `If-Modified-Since` （上一次资源修改时间） < 服务器上资源的最后修改时间，则说明当前资源被**修改过了**，服务端需要返回新的资源给服务端，此时响应200，返回正常的响应。同时这次响应会返回新的`Last-Modified` 值，用于更新浏览器缓存。\n    - 如果 `If-Modified-Since` （上一次资源修改时间）≥ 服务器上资源的最后修改时间，则说明没有修改过资源，则返回**304**状态码，不会返回资源内容。\n- 弊端：\n    - 短时间内资源发生了变化，这个字段并不会发生变化，缓存命中可能失效。\n    - 如果出现了服务器资源因为反复修改，但资源内容并没发生变化，此时浏览器再次请求服务器，实际上应该认为缓存命中（实际内容没有变化），但是此时通过该字段的比较会导致缓存命中失效。\n\n### `Etag` / `If-None-Match` （优先级最高）\n- 为了解决Last-Modifed的缓存命中问题，可以通过`Etag`来管理协商缓存命中。\n- 该字段是当前资源在服务器的唯一标识（生成规则有服务器决定），是基于文件内容进行编码的，如果文件内容不发生变动，那么该标识不会发生变更。\n- 服务端收到响应以后，根据当前资源内容重新生成一份`Etag` ，比较该值和`If-None-Match` 是否相等，相等则返回**304**，不相等则返回200和正常响应。但同`Last-Modified` 的区别在于即使服务器重新生成的`Etag`字段和原来的没有变化，但是因为重新生成了，304响应中同样会返回`Etag`字段。\n\n\n\n缓存流程图示\n\n<img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e78f0f10bfdf44239d5881c9a85e74d9~tplv-k3u1fbpfcp-watermark.image?\" alt=\"缓存流程图示.jpg\" width=\"100%\" />\n\n# 用户操作执行的缓存策略\n一些涉及到缓存判断的用户行为操作\n\n| 行为 | 可以使用的缓存策略 | 说明 |\n| --- | --- | --- |\n| 在URL输入栏中输入然后回车 / 访问书签 | 强缓存,协商缓存 |  |\n| 地址栏回车 / 正常重新加载（command  + r） | 协商缓存 | 在请求头加入 Cache-Control: max-age=0  使强缓存无效 |\n| F5 / 点击工具栏刷新按钮 / 右键菜单重新加载（command + r） | 协商缓存 | 在请求头加入 Cache-Control: max-age=0  使强缓存无效 |\n| ctrl + F5 （command + shift + r） | 协商缓存 | 在请求头加入Cache-Control: no-cache 使强缓存无效 |\n\n\n><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3738c65c47f1453ba4e539ed41d9fd4d~tplv-k3u1fbpfcp-watermark.image?\" alt=\"用户刷新\" width=\"100%\" />\n\n\n\n\n# 参考\n\n- [5分钟看懂系列：HTTP缓存机制详解](https://segmentfault.com/a/1190000021716418)\n- [f5到底刷新了点什么，你知道吗](https://juejin.cn/post/6844903725543194631)\n- [前端优化：浏览器缓存技术介绍](https://juejin.cn/post/6844903672556552205)\n- [深入理解HTTP缓存机制及原理](https://juejin.cn/post/6844903801778864136)\n","source":"_posts/浏览器缓存策略.md","raw":"---\ntitle: 浏览器缓存策略\ndate: 2023-03-03 17:42:33\ncategory: [浏览器]\ntags: <span class=\"label label-primary\">浏览器缓存</span> <span class=\"label label-primary\">HTTP</span>\nexcerpt: 众所周知，web开发过程中，网页资源响应速度一直是作为网站性能好坏的重要评估标准之一，而缓存技术一直以来在WEB技术体系中都扮演着非常重要的角色，通过缓存技术以及相应的缓存命中策略可以缩短网络请求时间，通过将耗时计算以及耗时传输的结果存起来，在不发生变更的情况下直接复用该结果，从而在保证结果正确性的同时大大提高网站的性能。\n---\n# 前言\n\n众所周知，web开发过程中，网页资源响应速度一直是作为网站性能好坏的重要评估标准之一，而缓存技术一直以来在WEB技术体系中都扮演着非常重要的角色，通过缓存技术以及相应的缓存命中策略可以缩短网络请求时间，通过将耗时计算以及耗时传输的结果存起来，在不发生变更的情况下直接复用该结果，从而在保证结果正确性的同时大大提高网站的性能。\n\n> 在实际WEB开发过程中，缓存技术会涉及到不同层、不同端，比如：用户层、系统层、代理层、前端、后端、服务端等，**每一层的缓存目标都是一致的，就是尽快返回请求数据、减少延迟**，但每层使用的技术实现是各有不同，面对不同层、不同端的优劣，选用不同的技术来提升系统响应效率。如图展示了各层相关的缓存技术：\n><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/947553dab6904876a2deccc67ef27eb8~tplv-k3u1fbpfcp-watermark.image?\" alt=\"Untitled.png\" width=\"100%\" />\n\n如上图所示，**浏览器缓存**属于用户层的缓存技术，它的主要任务就是一个把已经请求过的web资源（`html`，`js`，`css`，`image`…）拷贝一份副本到本地，在下一次再次请求该资源时，根据缓存命中机制选择是使用这份副本来直接响应请求，还是向源服务器重新请求最新的资源。\n\n浏览器缓存也是前端开发中最常会接触到的缓存技术，当我们开发了最新的版本之后，需要将打包结果也就是静态资源（`html，js，css`）部署到服务器上。此时因为浏览器缓存，可能存在即使已经在服务器上更新了资源，但是用户进入网站时并不会看到最新的版本，这里就需要我们了解浏览器的缓存，从而避免这种情况的发生；同时还要利用缓存技术，缓存不常更新的静态资源，提高用户打开网页的速度。\n\n接下来就详细的了解一下浏览器缓存。\n\n\n# 查看浏览器缓存\n## 缓存对象\n首先浏览器缓存的对象是一次HTTP响应报文的整体，包括响应行，响应头和响应体。其中，常见的HTTP请求方法中只能存储GET响应。通过在`firefox`的`about:cache`我们可以查看到浏览器缓存的HTTP响应：\n\n打开`baidu.com`，查看`network`控制面板，找到任意一个`js`资源，记住资源名：\n<img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f45247da25be4526882aa52250cf763d~tplv-k3u1fbpfcp-watermark.image?\" alt=\"Untitled 1.png\" width=\"100%\" />\n\n查看`firefox`缓存：\n<img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/812c0386d15f46ba99364f574b3620cd~tplv-k3u1fbpfcp-watermark.image?\" alt=\"Untitled 2.png\" width=\"100%\" />\n\n`disk cache`的所有缓存内容列表：\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8fd74bfec9a49ff84083287439bfe87~tplv-k3u1fbpfcp-watermark.image?\" alt=\"Untitled 3.png\" width=\"100%\" />\n\n找到刚才的`js`资源名，打开查看缓存内容：\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d28440dbdaae49c3b718c3331595813c~tplv-k3u1fbpfcp-watermark.image?\" alt=\"Untitled 4.png\" width=\"100%\" />\n\n但是并不是所有的GET响应都会被浏览器缓存，只要状态码为以下这些时，响应才会被缓存：\n\n- `200`：一个检索请求的成功响应\n    - HTML文档、js、css、图片、字体文件等\n- `301`：永久重定向\n- `404`：错误响应\n- `206`：不完全响应\n\n## 资源缓存位置\n\n> 浏览器获取缓存的顺序为 Service Worker Cache、Memory Cache、Disk Cache、（至于 Push Cache 属于 HTTP2 待验证）。\n> \n- `from memory cache`：是把资源存到内存中，当进程退出时（关闭浏览器），内存中的数据会清空，下次访问要执行别的缓存策略。\n- `from disk cache`：是把资源缓存在磁盘中，进程退出时不受影响，下次访问可以继续执行此次缓存策略。\n- `Sevice Worker Cache（https）`：开发者人为存储的永久性存储，用于离线缓存的处理。`Application -> Cache Storage` 查看。\n- `Push Cache（http2）`：Push Cache 是 HTTP2 在 sever push 阶段存在的缓存。\n\n\n# 浏览器缓存策略\n\n缓存命中机制主要分为两个阶段：**强缓存**和**协商缓存。其中无论是哪种缓存命中，最终使用的都是浏览器缓存到本地的资源。区别在于强缓存不发生网络请求。**\n\n**强缓存**主要是浏览器自行判断资源是否过期，如果不过期则直接使用缓存的资源（强缓存命中），不再进行网络请求；\n\n**协商缓存**则是在强缓存阶段无法命中的情况下，浏览器发起请求，询问服务器是否可以使用本地缓存资源，如果服务器检查发现浏览器本地的资源没有过期，则返回304告诉浏览器可以使用本地的缓存资源（协商缓存命中）；\n\n如果**强缓存和协商缓存都没有命中**的情况下，服务器会返回最新的资源，浏览器拿到资源后会更新缓存的资源信息。\n\n当前资源是否能被缓存以及是否能通过浏览器缓存机制命中（浏览器是否启动缓存），主要是服务器来设置。当该资源首次被请求时，**服务器通过设置HTTP响应的响应头来设置该资源的缓存信息。**主要是以下几个字段：\n\n- `Expires`\n- `cache-control`\n- `Etag`\n- `Last-Modified`\n\n\n## 强缓存\n> **强缓存是利用`Expires`或者`Cache-Control`这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期。**\n\n强缓存就是直接由浏览器判断缓存是否命中，**不经过网络**。当浏览器发起HTTP请求前，首先会查看当前的缓存列表，找到该资源的响应头，拿到`Cache-Control`或者`Expires`字段，通过对两个字段判断强缓存是否命中。当强缓存命中时，HTTP状态码为200，资源从缓存中加载（ `from memory cache` / `from disk cache`）。\n\n**优先级**：其中`Cache-Control` 的优先级大于`Expires` ，其实还有个`Pragma` 字段，它的优先级最高，但是不常用。\n\n通过控制台`Network` 面板查看：\n\n\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/155d9d56354d41d2b26318fc15028abf~tplv-k3u1fbpfcp-watermark.image?\" alt=\"Untitled 5.png\" width=\"100%\" />\n\n\n\n### `Expires` （优先级最低）\n\n- HTTP 1.0 用于缓存管理的`header`字段，由服务器返回，用GMT格式的字符串表示。\n- 值表示一个资源过期的时间，描述的是绝对时间，且该绝对时间属于服务端的时间系统。\n- 判断方法：浏览器发起下一次请求时，当前HTTP发起的请求时间 `(this http request time) < (expires设置的值)`，资源没有过期，缓存命中。\n- 弊端：`Expires`遵循的是服务端的时间系统，而请求时间遵循的是客户端的时间系统，如果两者时间不是一致的，就可能产生误差。例如手动修改本地客户端的时间，那么就可能影响缓存命中结果。\n\n\n\n### `Cache-Control`（优先级第二）\n\n为了解决Expires因为客户端和服务器端时间不统一带来的问题，HTTP 1.1 提出了新的`header` 也就是 `Cache-Control` ，这个字段使用相对时间，进行比较的时候用的都是客户端的时间，相对来更有效与安全。\n\n- HTTP 1.1\n- 值是一个相对时间，以秒为单位，用数值表示\n- 判断方法：浏览器发起下一次请求时，当前HTTP发起的请求时间`(this http request time) < (last http request time + cache-control 设置的值)` ，资源没有过期，缓存命中。\n\n```jsx\nCache-Control: public, max-age=31536000\n```\n\n该`header`字段的其他取值如下：\n\n| 字段名 | 位置 | 说明 |\n| --- | --- | --- |\n| no-cache | 请求头,响应头 | 强制客户端向服务器发送请求（禁止**强缓存**）。这个值不是禁止客户端或者代理服务器缓存响应。 |\n| no-store | 请求头,响应头 | 禁止一切缓存。客户端和代理服务器都不能缓存响应。 |\n| max-age | 请求头,响应头 | 设置资源（representations）可以被缓存多长时间，单位是秒。 |\n| no-transform | 请求头,响应头 | 代理不可更改媒体类型 |\n| cache-extension | 请求头,响应头 | 新指令标记（token） |\n| s-maxage | 响应头 | 和max-age同理，只不过是针对代理服务器缓存而言。 |\n| private | 响应头 | 不能被代理服务器缓存 |\n| public | 响应头 | 响应可以被任何缓存区缓存 |\n| must-revalidate | 响应头 | 在缓存过期前可以使用，缓存过期以后必须向服务器验证。 |\n| proxy-revalidate | 响应头 | 要求中间缓存服务器对缓存的响应有效性需再次确认（代理服务器需要发送请求给服务器端确认资源有效性，不能直接返回缓存） |\n| only-if-cached | 请求头 | 从缓存中获取资源 |\n| min-fresh | 请求头 | 单位：秒，期望在指定的时间内，响应仍有效 |\n| max-stale | 请求头 | 单位：秒， 接受已过期的响应 |\n\n\n### `Pragma` （优先级最高）\n除了 `Expires`和`Cache-Control`以外，还有`Pragma`字段，但是这个字段用得很少，它只有一个值就是 `no-cache`，含义等同于`Cache-Control` 取值为 `no-cache`，表示禁止强缓存，强制客户端发送http请求给客户端。\n\n\n## 协商缓存\n\n协商缓存是指，当强缓存没有命中的情况下，浏览器会发送http请求给服务端，此时服务端并不会直接处理请求，而是会再进行一次缓存命中判断，这个就是协商缓存。如果缓存命中成功，则会返回一个304的状态码，告诉浏览器当前资源没有过期。浏览器接收到304响应后，就会使用本地缓存的响应。\n\n> 304响应是一个只有响应头，响应体为空的响应。\n\n\n>![Untitled 6.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e69def0f32c141e0827436b8ec8cc2df~tplv-k3u1fbpfcp-watermark.image?)\n\n### `Last-Modified` / `If-Modified-Since`\n\n- 该字段是资源最后的修改时间。\n- 浏览器发送请求时，会将上次响应头中的 `Last-Modified` 赋值给 本次请求头中的 `If-Modified-Since` 字段。服务端中接收到请求之后，会将这个字段和当前资源最后的修改时间做对比，\n    - 如果 `If-Modified-Since` （上一次资源修改时间） < 服务器上资源的最后修改时间，则说明当前资源被**修改过了**，服务端需要返回新的资源给服务端，此时响应200，返回正常的响应。同时这次响应会返回新的`Last-Modified` 值，用于更新浏览器缓存。\n    - 如果 `If-Modified-Since` （上一次资源修改时间）≥ 服务器上资源的最后修改时间，则说明没有修改过资源，则返回**304**状态码，不会返回资源内容。\n- 弊端：\n    - 短时间内资源发生了变化，这个字段并不会发生变化，缓存命中可能失效。\n    - 如果出现了服务器资源因为反复修改，但资源内容并没发生变化，此时浏览器再次请求服务器，实际上应该认为缓存命中（实际内容没有变化），但是此时通过该字段的比较会导致缓存命中失效。\n\n### `Etag` / `If-None-Match` （优先级最高）\n- 为了解决Last-Modifed的缓存命中问题，可以通过`Etag`来管理协商缓存命中。\n- 该字段是当前资源在服务器的唯一标识（生成规则有服务器决定），是基于文件内容进行编码的，如果文件内容不发生变动，那么该标识不会发生变更。\n- 服务端收到响应以后，根据当前资源内容重新生成一份`Etag` ，比较该值和`If-None-Match` 是否相等，相等则返回**304**，不相等则返回200和正常响应。但同`Last-Modified` 的区别在于即使服务器重新生成的`Etag`字段和原来的没有变化，但是因为重新生成了，304响应中同样会返回`Etag`字段。\n\n\n\n缓存流程图示\n\n<img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e78f0f10bfdf44239d5881c9a85e74d9~tplv-k3u1fbpfcp-watermark.image?\" alt=\"缓存流程图示.jpg\" width=\"100%\" />\n\n# 用户操作执行的缓存策略\n一些涉及到缓存判断的用户行为操作\n\n| 行为 | 可以使用的缓存策略 | 说明 |\n| --- | --- | --- |\n| 在URL输入栏中输入然后回车 / 访问书签 | 强缓存,协商缓存 |  |\n| 地址栏回车 / 正常重新加载（command  + r） | 协商缓存 | 在请求头加入 Cache-Control: max-age=0  使强缓存无效 |\n| F5 / 点击工具栏刷新按钮 / 右键菜单重新加载（command + r） | 协商缓存 | 在请求头加入 Cache-Control: max-age=0  使强缓存无效 |\n| ctrl + F5 （command + shift + r） | 协商缓存 | 在请求头加入Cache-Control: no-cache 使强缓存无效 |\n\n\n><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3738c65c47f1453ba4e539ed41d9fd4d~tplv-k3u1fbpfcp-watermark.image?\" alt=\"用户刷新\" width=\"100%\" />\n\n\n\n\n# 参考\n\n- [5分钟看懂系列：HTTP缓存机制详解](https://segmentfault.com/a/1190000021716418)\n- [f5到底刷新了点什么，你知道吗](https://juejin.cn/post/6844903725543194631)\n- [前端优化：浏览器缓存技术介绍](https://juejin.cn/post/6844903672556552205)\n- [深入理解HTTP缓存机制及原理](https://juejin.cn/post/6844903801778864136)\n","slug":"浏览器缓存策略","published":1,"updated":"2023-03-03T12:56:57.902Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clesk19he0015dddf98ez7pua","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>众所周知，web开发过程中，网页资源响应速度一直是作为网站性能好坏的重要评估标准之一，而缓存技术一直以来在WEB技术体系中都扮演着非常重要的角色，通过缓存技术以及相应的缓存命中策略可以缩短网络请求时间，通过将耗时计算以及耗时传输的结果存起来，在不发生变更的情况下直接复用该结果，从而在保证结果正确性的同时大大提高网站的性能。</p>\n<blockquote>\n<p>在实际WEB开发过程中，缓存技术会涉及到不同层、不同端，比如：用户层、系统层、代理层、前端、后端、服务端等，<strong>每一层的缓存目标都是一致的，就是尽快返回请求数据、减少延迟</strong>，但每层使用的技术实现是各有不同，面对不同层、不同端的优劣，选用不同的技术来提升系统响应效率。如图展示了各层相关的缓存技术：<br><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/947553dab6904876a2deccc67ef27eb8~tplv-k3u1fbpfcp-watermark.image?\" alt=\"Untitled.png\" width=\"100%\" /></p>\n</blockquote>\n<p>如上图所示，<strong>浏览器缓存</strong>属于用户层的缓存技术，它的主要任务就是一个把已经请求过的web资源（<code>html</code>，<code>js</code>，<code>css</code>，<code>image</code>…）拷贝一份副本到本地，在下一次再次请求该资源时，根据缓存命中机制选择是使用这份副本来直接响应请求，还是向源服务器重新请求最新的资源。</p>\n<p>浏览器缓存也是前端开发中最常会接触到的缓存技术，当我们开发了最新的版本之后，需要将打包结果也就是静态资源（<code>html，js，css</code>）部署到服务器上。此时因为浏览器缓存，可能存在即使已经在服务器上更新了资源，但是用户进入网站时并不会看到最新的版本，这里就需要我们了解浏览器的缓存，从而避免这种情况的发生；同时还要利用缓存技术，缓存不常更新的静态资源，提高用户打开网页的速度。</p>\n<p>接下来就详细的了解一下浏览器缓存。</p>\n<h1 id=\"查看浏览器缓存\"><a href=\"#查看浏览器缓存\" class=\"headerlink\" title=\"查看浏览器缓存\"></a>查看浏览器缓存</h1><h2 id=\"缓存对象\"><a href=\"#缓存对象\" class=\"headerlink\" title=\"缓存对象\"></a>缓存对象</h2><p>首先浏览器缓存的对象是一次HTTP响应报文的整体，包括响应行，响应头和响应体。其中，常见的HTTP请求方法中只能存储GET响应。通过在<code>firefox</code>的<code>about:cache</code>我们可以查看到浏览器缓存的HTTP响应：</p>\n<p>打开<code>baidu.com</code>，查看<code>network</code>控制面板，找到任意一个<code>js</code>资源，记住资源名：<br><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f45247da25be4526882aa52250cf763d~tplv-k3u1fbpfcp-watermark.image?\" alt=\"Untitled 1.png\" width=\"100%\" /></p>\n<p>查看<code>firefox</code>缓存：<br><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/812c0386d15f46ba99364f574b3620cd~tplv-k3u1fbpfcp-watermark.image?\" alt=\"Untitled 2.png\" width=\"100%\" /></p>\n<p><code>disk cache</code>的所有缓存内容列表：<br><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8fd74bfec9a49ff84083287439bfe87~tplv-k3u1fbpfcp-watermark.image?\" alt=\"Untitled 3.png\" width=\"100%\" /></p>\n<p>找到刚才的<code>js</code>资源名，打开查看缓存内容：<br><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d28440dbdaae49c3b718c3331595813c~tplv-k3u1fbpfcp-watermark.image?\" alt=\"Untitled 4.png\" width=\"100%\" /></p>\n<p>但是并不是所有的GET响应都会被浏览器缓存，只要状态码为以下这些时，响应才会被缓存：</p>\n<ul>\n<li><code>200</code>：一个检索请求的成功响应<ul>\n<li>HTML文档、js、css、图片、字体文件等</li>\n</ul>\n</li>\n<li><code>301</code>：永久重定向</li>\n<li><code>404</code>：错误响应</li>\n<li><code>206</code>：不完全响应</li>\n</ul>\n<h2 id=\"资源缓存位置\"><a href=\"#资源缓存位置\" class=\"headerlink\" title=\"资源缓存位置\"></a>资源缓存位置</h2><blockquote>\n<p>浏览器获取缓存的顺序为 Service Worker Cache、Memory Cache、Disk Cache、（至于 Push Cache 属于 HTTP2 待验证）。</p>\n</blockquote>\n<ul>\n<li><code>from memory cache</code>：是把资源存到内存中，当进程退出时（关闭浏览器），内存中的数据会清空，下次访问要执行别的缓存策略。</li>\n<li><code>from disk cache</code>：是把资源缓存在磁盘中，进程退出时不受影响，下次访问可以继续执行此次缓存策略。</li>\n<li><code>Sevice Worker Cache（https）</code>：开发者人为存储的永久性存储，用于离线缓存的处理。<code>Application -&gt; Cache Storage</code> 查看。</li>\n<li><code>Push Cache（http2）</code>：Push Cache 是 HTTP2 在 sever push 阶段存在的缓存。</li>\n</ul>\n<h1 id=\"浏览器缓存策略\"><a href=\"#浏览器缓存策略\" class=\"headerlink\" title=\"浏览器缓存策略\"></a>浏览器缓存策略</h1><p>缓存命中机制主要分为两个阶段：<strong>强缓存</strong>和<strong>协商缓存。其中无论是哪种缓存命中，最终使用的都是浏览器缓存到本地的资源。区别在于强缓存不发生网络请求。</strong></p>\n<p><strong>强缓存</strong>主要是浏览器自行判断资源是否过期，如果不过期则直接使用缓存的资源（强缓存命中），不再进行网络请求；</p>\n<p><strong>协商缓存</strong>则是在强缓存阶段无法命中的情况下，浏览器发起请求，询问服务器是否可以使用本地缓存资源，如果服务器检查发现浏览器本地的资源没有过期，则返回304告诉浏览器可以使用本地的缓存资源（协商缓存命中）；</p>\n<p>如果<strong>强缓存和协商缓存都没有命中</strong>的情况下，服务器会返回最新的资源，浏览器拿到资源后会更新缓存的资源信息。</p>\n<p>当前资源是否能被缓存以及是否能通过浏览器缓存机制命中（浏览器是否启动缓存），主要是服务器来设置。当该资源首次被请求时，<strong>服务器通过设置HTTP响应的响应头来设置该资源的缓存信息。</strong>主要是以下几个字段：</p>\n<ul>\n<li><code>Expires</code></li>\n<li><code>cache-control</code></li>\n<li><code>Etag</code></li>\n<li><code>Last-Modified</code></li>\n</ul>\n<h2 id=\"强缓存\"><a href=\"#强缓存\" class=\"headerlink\" title=\"强缓存\"></a>强缓存</h2><blockquote>\n<p><strong>强缓存是利用<code>Expires</code>或者<code>Cache-Control</code>这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期。</strong></p>\n</blockquote>\n<p>强缓存就是直接由浏览器判断缓存是否命中，<strong>不经过网络</strong>。当浏览器发起HTTP请求前，首先会查看当前的缓存列表，找到该资源的响应头，拿到<code>Cache-Control</code>或者<code>Expires</code>字段，通过对两个字段判断强缓存是否命中。当强缓存命中时，HTTP状态码为200，资源从缓存中加载（ <code>from memory cache</code> / <code>from disk cache</code>）。</p>\n<p><strong>优先级</strong>：其中<code>Cache-Control</code> 的优先级大于<code>Expires</code> ，其实还有个<code>Pragma</code> 字段，它的优先级最高，但是不常用。</p>\n<p>通过控制台<code>Network</code> 面板查看：</p>\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/155d9d56354d41d2b26318fc15028abf~tplv-k3u1fbpfcp-watermark.image?\" alt=\"Untitled 5.png\" width=\"100%\" />\n\n\n\n<h3 id=\"Expires-（优先级最低）\"><a href=\"#Expires-（优先级最低）\" class=\"headerlink\" title=\"Expires （优先级最低）\"></a><code>Expires</code> （优先级最低）</h3><ul>\n<li>HTTP 1.0 用于缓存管理的<code>header</code>字段，由服务器返回，用GMT格式的字符串表示。</li>\n<li>值表示一个资源过期的时间，描述的是绝对时间，且该绝对时间属于服务端的时间系统。</li>\n<li>判断方法：浏览器发起下一次请求时，当前HTTP发起的请求时间 <code>(this http request time) &lt; (expires设置的值)</code>，资源没有过期，缓存命中。</li>\n<li>弊端：<code>Expires</code>遵循的是服务端的时间系统，而请求时间遵循的是客户端的时间系统，如果两者时间不是一致的，就可能产生误差。例如手动修改本地客户端的时间，那么就可能影响缓存命中结果。</li>\n</ul>\n<h3 id=\"Cache-Control（优先级第二）\"><a href=\"#Cache-Control（优先级第二）\" class=\"headerlink\" title=\"Cache-Control（优先级第二）\"></a><code>Cache-Control</code>（优先级第二）</h3><p>为了解决Expires因为客户端和服务器端时间不统一带来的问题，HTTP 1.1 提出了新的<code>header</code> 也就是 <code>Cache-Control</code> ，这个字段使用相对时间，进行比较的时候用的都是客户端的时间，相对来更有效与安全。</p>\n<ul>\n<li>HTTP 1.1</li>\n<li>值是一个相对时间，以秒为单位，用数值表示</li>\n<li>判断方法：浏览器发起下一次请求时，当前HTTP发起的请求时间<code>(this http request time) &lt; (last http request time + cache-control 设置的值)</code> ，资源没有过期，缓存命中。</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-title class_\">Cache</span>-<span class=\"hljs-title class_\">Control</span>: public, max-age=<span class=\"hljs-number\">31536000</span><br></code></pre></td></tr></table></figure>\n\n<p>该<code>header</code>字段的其他取值如下：</p>\n<table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>位置</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>no-cache</td>\n<td>请求头,响应头</td>\n<td>强制客户端向服务器发送请求（禁止<strong>强缓存</strong>）。这个值不是禁止客户端或者代理服务器缓存响应。</td>\n</tr>\n<tr>\n<td>no-store</td>\n<td>请求头,响应头</td>\n<td>禁止一切缓存。客户端和代理服务器都不能缓存响应。</td>\n</tr>\n<tr>\n<td>max-age</td>\n<td>请求头,响应头</td>\n<td>设置资源（representations）可以被缓存多长时间，单位是秒。</td>\n</tr>\n<tr>\n<td>no-transform</td>\n<td>请求头,响应头</td>\n<td>代理不可更改媒体类型</td>\n</tr>\n<tr>\n<td>cache-extension</td>\n<td>请求头,响应头</td>\n<td>新指令标记（token）</td>\n</tr>\n<tr>\n<td>s-maxage</td>\n<td>响应头</td>\n<td>和max-age同理，只不过是针对代理服务器缓存而言。</td>\n</tr>\n<tr>\n<td>private</td>\n<td>响应头</td>\n<td>不能被代理服务器缓存</td>\n</tr>\n<tr>\n<td>public</td>\n<td>响应头</td>\n<td>响应可以被任何缓存区缓存</td>\n</tr>\n<tr>\n<td>must-revalidate</td>\n<td>响应头</td>\n<td>在缓存过期前可以使用，缓存过期以后必须向服务器验证。</td>\n</tr>\n<tr>\n<td>proxy-revalidate</td>\n<td>响应头</td>\n<td>要求中间缓存服务器对缓存的响应有效性需再次确认（代理服务器需要发送请求给服务器端确认资源有效性，不能直接返回缓存）</td>\n</tr>\n<tr>\n<td>only-if-cached</td>\n<td>请求头</td>\n<td>从缓存中获取资源</td>\n</tr>\n<tr>\n<td>min-fresh</td>\n<td>请求头</td>\n<td>单位：秒，期望在指定的时间内，响应仍有效</td>\n</tr>\n<tr>\n<td>max-stale</td>\n<td>请求头</td>\n<td>单位：秒， 接受已过期的响应</td>\n</tr>\n</tbody></table>\n<h3 id=\"Pragma-（优先级最高）\"><a href=\"#Pragma-（优先级最高）\" class=\"headerlink\" title=\"Pragma （优先级最高）\"></a><code>Pragma</code> （优先级最高）</h3><p>除了 <code>Expires</code>和<code>Cache-Control</code>以外，还有<code>Pragma</code>字段，但是这个字段用得很少，它只有一个值就是 <code>no-cache</code>，含义等同于<code>Cache-Control</code> 取值为 <code>no-cache</code>，表示禁止强缓存，强制客户端发送http请求给客户端。</p>\n<h2 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h2><p>协商缓存是指，当强缓存没有命中的情况下，浏览器会发送http请求给服务端，此时服务端并不会直接处理请求，而是会再进行一次缓存命中判断，这个就是协商缓存。如果缓存命中成功，则会返回一个304的状态码，告诉浏览器当前资源没有过期。浏览器接收到304响应后，就会使用本地缓存的响应。</p>\n<blockquote>\n<p>304响应是一个只有响应头，响应体为空的响应。</p>\n</blockquote>\n<blockquote>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e69def0f32c141e0827436b8ec8cc2df~tplv-k3u1fbpfcp-watermark.image\" alt=\"Untitled 6.png\"></p>\n</blockquote>\n<h3 id=\"Last-Modified-If-Modified-Since\"><a href=\"#Last-Modified-If-Modified-Since\" class=\"headerlink\" title=\"Last-Modified / If-Modified-Since\"></a><code>Last-Modified</code> / <code>If-Modified-Since</code></h3><ul>\n<li>该字段是资源最后的修改时间。</li>\n<li>浏览器发送请求时，会将上次响应头中的 <code>Last-Modified</code> 赋值给 本次请求头中的 <code>If-Modified-Since</code> 字段。服务端中接收到请求之后，会将这个字段和当前资源最后的修改时间做对比，<ul>\n<li>如果 <code>If-Modified-Since</code> （上一次资源修改时间） &lt; 服务器上资源的最后修改时间，则说明当前资源被<strong>修改过了</strong>，服务端需要返回新的资源给服务端，此时响应200，返回正常的响应。同时这次响应会返回新的<code>Last-Modified</code> 值，用于更新浏览器缓存。</li>\n<li>如果 <code>If-Modified-Since</code> （上一次资源修改时间）≥ 服务器上资源的最后修改时间，则说明没有修改过资源，则返回<strong>304</strong>状态码，不会返回资源内容。</li>\n</ul>\n</li>\n<li>弊端：<ul>\n<li>短时间内资源发生了变化，这个字段并不会发生变化，缓存命中可能失效。</li>\n<li>如果出现了服务器资源因为反复修改，但资源内容并没发生变化，此时浏览器再次请求服务器，实际上应该认为缓存命中（实际内容没有变化），但是此时通过该字段的比较会导致缓存命中失效。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Etag-If-None-Match-（优先级最高）\"><a href=\"#Etag-If-None-Match-（优先级最高）\" class=\"headerlink\" title=\"Etag / If-None-Match （优先级最高）\"></a><code>Etag</code> / <code>If-None-Match</code> （优先级最高）</h3><ul>\n<li>为了解决Last-Modifed的缓存命中问题，可以通过<code>Etag</code>来管理协商缓存命中。</li>\n<li>该字段是当前资源在服务器的唯一标识（生成规则有服务器决定），是基于文件内容进行编码的，如果文件内容不发生变动，那么该标识不会发生变更。</li>\n<li>服务端收到响应以后，根据当前资源内容重新生成一份<code>Etag</code> ，比较该值和<code>If-None-Match</code> 是否相等，相等则返回<strong>304</strong>，不相等则返回200和正常响应。但同<code>Last-Modified</code> 的区别在于即使服务器重新生成的<code>Etag</code>字段和原来的没有变化，但是因为重新生成了，304响应中同样会返回<code>Etag</code>字段。</li>\n</ul>\n<p>缓存流程图示</p>\n<img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e78f0f10bfdf44239d5881c9a85e74d9~tplv-k3u1fbpfcp-watermark.image?\" alt=\"缓存流程图示.jpg\" width=\"100%\" />\n\n<h1 id=\"用户操作执行的缓存策略\"><a href=\"#用户操作执行的缓存策略\" class=\"headerlink\" title=\"用户操作执行的缓存策略\"></a>用户操作执行的缓存策略</h1><p>一些涉及到缓存判断的用户行为操作</p>\n<table>\n<thead>\n<tr>\n<th>行为</th>\n<th>可以使用的缓存策略</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>在URL输入栏中输入然后回车 / 访问书签</td>\n<td>强缓存,协商缓存</td>\n<td></td>\n</tr>\n<tr>\n<td>地址栏回车 / 正常重新加载（command  + r）</td>\n<td>协商缓存</td>\n<td>在请求头加入 Cache-Control: max-age=0  使强缓存无效</td>\n</tr>\n<tr>\n<td>F5 / 点击工具栏刷新按钮 / 右键菜单重新加载（command + r）</td>\n<td>协商缓存</td>\n<td>在请求头加入 Cache-Control: max-age=0  使强缓存无效</td>\n</tr>\n<tr>\n<td>ctrl + F5 （command + shift + r）</td>\n<td>协商缓存</td>\n<td>在请求头加入Cache-Control: no-cache 使强缓存无效</td>\n</tr>\n</tbody></table>\n<blockquote>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3738c65c47f1453ba4e539ed41d9fd4d~tplv-k3u1fbpfcp-watermark.image?\" alt=\"用户刷新\" width=\"100%\" />\n</blockquote>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li><a href=\"https://segmentfault.com/a/1190000021716418\">5分钟看懂系列：HTTP缓存机制详解</a></li>\n<li><a href=\"https://juejin.cn/post/6844903725543194631\">f5到底刷新了点什么，你知道吗</a></li>\n<li><a href=\"https://juejin.cn/post/6844903672556552205\">前端优化：浏览器缓存技术介绍</a></li>\n<li><a href=\"https://juejin.cn/post/6844903801778864136\">深入理解HTTP缓存机制及原理</a></li>\n</ul>\n","site":{"data":{"languages/zh-CN":{"name":"简体中文","home":{"menu":"首页","title":"首页"},"archive":{"menu":"归档","title":"归档","subtitle":"归档","post_total":"共计 %d 篇文章"},"category":{"menu":"分类","title":"分类","subtitle":"分类","post_total":"共计 %d 篇文章","more":"More..."},"tag":{"menu":"标签","title":"标签","subtitle":"标签","post_total":"共计 %d 篇文章"},"about":{"menu":"关于","title":"关于","subtitle":"关于"},"links":{"menu":"友链","title":"友链","subtitle":"友情链接"},"page404":{"menu":"页面不存在","title":"页面不存在","subtitle":"页面不存在"},"post":{"toc":"目录","prev_post":"上一篇","next_post":"下一篇","updated":"本文最后更新于：%s","meta":{"wordcount":"%s 字","min2read":"%s 分钟","views":"{} 次"},"copyright":{"author":"作者","posted":"发布于","updated":"更新于","licensed":"许可协议","CC":"CC - 知识共享许可协议","BY":"BY - 署名","SA":"SA - 相同方式共享","NC":"NC - 非商业性使用","ND":"ND - 禁止演绎"}},"footer":{"pv":"总访问量 {} 次","uv":"总访客数 {} 人"},"search":{"title":"搜索","keyword":"关键词"},"noscript_warning":"博客在允许 JavaScript 运行的环境下浏览效果更佳"}}},"more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>众所周知，web开发过程中，网页资源响应速度一直是作为网站性能好坏的重要评估标准之一，而缓存技术一直以来在WEB技术体系中都扮演着非常重要的角色，通过缓存技术以及相应的缓存命中策略可以缩短网络请求时间，通过将耗时计算以及耗时传输的结果存起来，在不发生变更的情况下直接复用该结果，从而在保证结果正确性的同时大大提高网站的性能。</p>\n<blockquote>\n<p>在实际WEB开发过程中，缓存技术会涉及到不同层、不同端，比如：用户层、系统层、代理层、前端、后端、服务端等，<strong>每一层的缓存目标都是一致的，就是尽快返回请求数据、减少延迟</strong>，但每层使用的技术实现是各有不同，面对不同层、不同端的优劣，选用不同的技术来提升系统响应效率。如图展示了各层相关的缓存技术：<br><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/947553dab6904876a2deccc67ef27eb8~tplv-k3u1fbpfcp-watermark.image?\" alt=\"Untitled.png\" width=\"100%\" /></p>\n</blockquote>\n<p>如上图所示，<strong>浏览器缓存</strong>属于用户层的缓存技术，它的主要任务就是一个把已经请求过的web资源（<code>html</code>，<code>js</code>，<code>css</code>，<code>image</code>…）拷贝一份副本到本地，在下一次再次请求该资源时，根据缓存命中机制选择是使用这份副本来直接响应请求，还是向源服务器重新请求最新的资源。</p>\n<p>浏览器缓存也是前端开发中最常会接触到的缓存技术，当我们开发了最新的版本之后，需要将打包结果也就是静态资源（<code>html，js，css</code>）部署到服务器上。此时因为浏览器缓存，可能存在即使已经在服务器上更新了资源，但是用户进入网站时并不会看到最新的版本，这里就需要我们了解浏览器的缓存，从而避免这种情况的发生；同时还要利用缓存技术，缓存不常更新的静态资源，提高用户打开网页的速度。</p>\n<p>接下来就详细的了解一下浏览器缓存。</p>\n<h1 id=\"查看浏览器缓存\"><a href=\"#查看浏览器缓存\" class=\"headerlink\" title=\"查看浏览器缓存\"></a>查看浏览器缓存</h1><h2 id=\"缓存对象\"><a href=\"#缓存对象\" class=\"headerlink\" title=\"缓存对象\"></a>缓存对象</h2><p>首先浏览器缓存的对象是一次HTTP响应报文的整体，包括响应行，响应头和响应体。其中，常见的HTTP请求方法中只能存储GET响应。通过在<code>firefox</code>的<code>about:cache</code>我们可以查看到浏览器缓存的HTTP响应：</p>\n<p>打开<code>baidu.com</code>，查看<code>network</code>控制面板，找到任意一个<code>js</code>资源，记住资源名：<br><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f45247da25be4526882aa52250cf763d~tplv-k3u1fbpfcp-watermark.image?\" alt=\"Untitled 1.png\" width=\"100%\" /></p>\n<p>查看<code>firefox</code>缓存：<br><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/812c0386d15f46ba99364f574b3620cd~tplv-k3u1fbpfcp-watermark.image?\" alt=\"Untitled 2.png\" width=\"100%\" /></p>\n<p><code>disk cache</code>的所有缓存内容列表：<br><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8fd74bfec9a49ff84083287439bfe87~tplv-k3u1fbpfcp-watermark.image?\" alt=\"Untitled 3.png\" width=\"100%\" /></p>\n<p>找到刚才的<code>js</code>资源名，打开查看缓存内容：<br><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d28440dbdaae49c3b718c3331595813c~tplv-k3u1fbpfcp-watermark.image?\" alt=\"Untitled 4.png\" width=\"100%\" /></p>\n<p>但是并不是所有的GET响应都会被浏览器缓存，只要状态码为以下这些时，响应才会被缓存：</p>\n<ul>\n<li><code>200</code>：一个检索请求的成功响应<ul>\n<li>HTML文档、js、css、图片、字体文件等</li>\n</ul>\n</li>\n<li><code>301</code>：永久重定向</li>\n<li><code>404</code>：错误响应</li>\n<li><code>206</code>：不完全响应</li>\n</ul>\n<h2 id=\"资源缓存位置\"><a href=\"#资源缓存位置\" class=\"headerlink\" title=\"资源缓存位置\"></a>资源缓存位置</h2><blockquote>\n<p>浏览器获取缓存的顺序为 Service Worker Cache、Memory Cache、Disk Cache、（至于 Push Cache 属于 HTTP2 待验证）。</p>\n</blockquote>\n<ul>\n<li><code>from memory cache</code>：是把资源存到内存中，当进程退出时（关闭浏览器），内存中的数据会清空，下次访问要执行别的缓存策略。</li>\n<li><code>from disk cache</code>：是把资源缓存在磁盘中，进程退出时不受影响，下次访问可以继续执行此次缓存策略。</li>\n<li><code>Sevice Worker Cache（https）</code>：开发者人为存储的永久性存储，用于离线缓存的处理。<code>Application -&gt; Cache Storage</code> 查看。</li>\n<li><code>Push Cache（http2）</code>：Push Cache 是 HTTP2 在 sever push 阶段存在的缓存。</li>\n</ul>\n<h1 id=\"浏览器缓存策略\"><a href=\"#浏览器缓存策略\" class=\"headerlink\" title=\"浏览器缓存策略\"></a>浏览器缓存策略</h1><p>缓存命中机制主要分为两个阶段：<strong>强缓存</strong>和<strong>协商缓存。其中无论是哪种缓存命中，最终使用的都是浏览器缓存到本地的资源。区别在于强缓存不发生网络请求。</strong></p>\n<p><strong>强缓存</strong>主要是浏览器自行判断资源是否过期，如果不过期则直接使用缓存的资源（强缓存命中），不再进行网络请求；</p>\n<p><strong>协商缓存</strong>则是在强缓存阶段无法命中的情况下，浏览器发起请求，询问服务器是否可以使用本地缓存资源，如果服务器检查发现浏览器本地的资源没有过期，则返回304告诉浏览器可以使用本地的缓存资源（协商缓存命中）；</p>\n<p>如果<strong>强缓存和协商缓存都没有命中</strong>的情况下，服务器会返回最新的资源，浏览器拿到资源后会更新缓存的资源信息。</p>\n<p>当前资源是否能被缓存以及是否能通过浏览器缓存机制命中（浏览器是否启动缓存），主要是服务器来设置。当该资源首次被请求时，<strong>服务器通过设置HTTP响应的响应头来设置该资源的缓存信息。</strong>主要是以下几个字段：</p>\n<ul>\n<li><code>Expires</code></li>\n<li><code>cache-control</code></li>\n<li><code>Etag</code></li>\n<li><code>Last-Modified</code></li>\n</ul>\n<h2 id=\"强缓存\"><a href=\"#强缓存\" class=\"headerlink\" title=\"强缓存\"></a>强缓存</h2><blockquote>\n<p><strong>强缓存是利用<code>Expires</code>或者<code>Cache-Control</code>这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期。</strong></p>\n</blockquote>\n<p>强缓存就是直接由浏览器判断缓存是否命中，<strong>不经过网络</strong>。当浏览器发起HTTP请求前，首先会查看当前的缓存列表，找到该资源的响应头，拿到<code>Cache-Control</code>或者<code>Expires</code>字段，通过对两个字段判断强缓存是否命中。当强缓存命中时，HTTP状态码为200，资源从缓存中加载（ <code>from memory cache</code> / <code>from disk cache</code>）。</p>\n<p><strong>优先级</strong>：其中<code>Cache-Control</code> 的优先级大于<code>Expires</code> ，其实还有个<code>Pragma</code> 字段，它的优先级最高，但是不常用。</p>\n<p>通过控制台<code>Network</code> 面板查看：</p>\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/155d9d56354d41d2b26318fc15028abf~tplv-k3u1fbpfcp-watermark.image?\" alt=\"Untitled 5.png\" width=\"100%\" />\n\n\n\n<h3 id=\"Expires-（优先级最低）\"><a href=\"#Expires-（优先级最低）\" class=\"headerlink\" title=\"Expires （优先级最低）\"></a><code>Expires</code> （优先级最低）</h3><ul>\n<li>HTTP 1.0 用于缓存管理的<code>header</code>字段，由服务器返回，用GMT格式的字符串表示。</li>\n<li>值表示一个资源过期的时间，描述的是绝对时间，且该绝对时间属于服务端的时间系统。</li>\n<li>判断方法：浏览器发起下一次请求时，当前HTTP发起的请求时间 <code>(this http request time) &lt; (expires设置的值)</code>，资源没有过期，缓存命中。</li>\n<li>弊端：<code>Expires</code>遵循的是服务端的时间系统，而请求时间遵循的是客户端的时间系统，如果两者时间不是一致的，就可能产生误差。例如手动修改本地客户端的时间，那么就可能影响缓存命中结果。</li>\n</ul>\n<h3 id=\"Cache-Control（优先级第二）\"><a href=\"#Cache-Control（优先级第二）\" class=\"headerlink\" title=\"Cache-Control（优先级第二）\"></a><code>Cache-Control</code>（优先级第二）</h3><p>为了解决Expires因为客户端和服务器端时间不统一带来的问题，HTTP 1.1 提出了新的<code>header</code> 也就是 <code>Cache-Control</code> ，这个字段使用相对时间，进行比较的时候用的都是客户端的时间，相对来更有效与安全。</p>\n<ul>\n<li>HTTP 1.1</li>\n<li>值是一个相对时间，以秒为单位，用数值表示</li>\n<li>判断方法：浏览器发起下一次请求时，当前HTTP发起的请求时间<code>(this http request time) &lt; (last http request time + cache-control 设置的值)</code> ，资源没有过期，缓存命中。</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-title class_\">Cache</span>-<span class=\"hljs-title class_\">Control</span>: public, max-age=<span class=\"hljs-number\">31536000</span><br></code></pre></td></tr></table></figure>\n\n<p>该<code>header</code>字段的其他取值如下：</p>\n<table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>位置</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>no-cache</td>\n<td>请求头,响应头</td>\n<td>强制客户端向服务器发送请求（禁止<strong>强缓存</strong>）。这个值不是禁止客户端或者代理服务器缓存响应。</td>\n</tr>\n<tr>\n<td>no-store</td>\n<td>请求头,响应头</td>\n<td>禁止一切缓存。客户端和代理服务器都不能缓存响应。</td>\n</tr>\n<tr>\n<td>max-age</td>\n<td>请求头,响应头</td>\n<td>设置资源（representations）可以被缓存多长时间，单位是秒。</td>\n</tr>\n<tr>\n<td>no-transform</td>\n<td>请求头,响应头</td>\n<td>代理不可更改媒体类型</td>\n</tr>\n<tr>\n<td>cache-extension</td>\n<td>请求头,响应头</td>\n<td>新指令标记（token）</td>\n</tr>\n<tr>\n<td>s-maxage</td>\n<td>响应头</td>\n<td>和max-age同理，只不过是针对代理服务器缓存而言。</td>\n</tr>\n<tr>\n<td>private</td>\n<td>响应头</td>\n<td>不能被代理服务器缓存</td>\n</tr>\n<tr>\n<td>public</td>\n<td>响应头</td>\n<td>响应可以被任何缓存区缓存</td>\n</tr>\n<tr>\n<td>must-revalidate</td>\n<td>响应头</td>\n<td>在缓存过期前可以使用，缓存过期以后必须向服务器验证。</td>\n</tr>\n<tr>\n<td>proxy-revalidate</td>\n<td>响应头</td>\n<td>要求中间缓存服务器对缓存的响应有效性需再次确认（代理服务器需要发送请求给服务器端确认资源有效性，不能直接返回缓存）</td>\n</tr>\n<tr>\n<td>only-if-cached</td>\n<td>请求头</td>\n<td>从缓存中获取资源</td>\n</tr>\n<tr>\n<td>min-fresh</td>\n<td>请求头</td>\n<td>单位：秒，期望在指定的时间内，响应仍有效</td>\n</tr>\n<tr>\n<td>max-stale</td>\n<td>请求头</td>\n<td>单位：秒， 接受已过期的响应</td>\n</tr>\n</tbody></table>\n<h3 id=\"Pragma-（优先级最高）\"><a href=\"#Pragma-（优先级最高）\" class=\"headerlink\" title=\"Pragma （优先级最高）\"></a><code>Pragma</code> （优先级最高）</h3><p>除了 <code>Expires</code>和<code>Cache-Control</code>以外，还有<code>Pragma</code>字段，但是这个字段用得很少，它只有一个值就是 <code>no-cache</code>，含义等同于<code>Cache-Control</code> 取值为 <code>no-cache</code>，表示禁止强缓存，强制客户端发送http请求给客户端。</p>\n<h2 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h2><p>协商缓存是指，当强缓存没有命中的情况下，浏览器会发送http请求给服务端，此时服务端并不会直接处理请求，而是会再进行一次缓存命中判断，这个就是协商缓存。如果缓存命中成功，则会返回一个304的状态码，告诉浏览器当前资源没有过期。浏览器接收到304响应后，就会使用本地缓存的响应。</p>\n<blockquote>\n<p>304响应是一个只有响应头，响应体为空的响应。</p>\n</blockquote>\n<blockquote>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e69def0f32c141e0827436b8ec8cc2df~tplv-k3u1fbpfcp-watermark.image\" alt=\"Untitled 6.png\"></p>\n</blockquote>\n<h3 id=\"Last-Modified-If-Modified-Since\"><a href=\"#Last-Modified-If-Modified-Since\" class=\"headerlink\" title=\"Last-Modified / If-Modified-Since\"></a><code>Last-Modified</code> / <code>If-Modified-Since</code></h3><ul>\n<li>该字段是资源最后的修改时间。</li>\n<li>浏览器发送请求时，会将上次响应头中的 <code>Last-Modified</code> 赋值给 本次请求头中的 <code>If-Modified-Since</code> 字段。服务端中接收到请求之后，会将这个字段和当前资源最后的修改时间做对比，<ul>\n<li>如果 <code>If-Modified-Since</code> （上一次资源修改时间） &lt; 服务器上资源的最后修改时间，则说明当前资源被<strong>修改过了</strong>，服务端需要返回新的资源给服务端，此时响应200，返回正常的响应。同时这次响应会返回新的<code>Last-Modified</code> 值，用于更新浏览器缓存。</li>\n<li>如果 <code>If-Modified-Since</code> （上一次资源修改时间）≥ 服务器上资源的最后修改时间，则说明没有修改过资源，则返回<strong>304</strong>状态码，不会返回资源内容。</li>\n</ul>\n</li>\n<li>弊端：<ul>\n<li>短时间内资源发生了变化，这个字段并不会发生变化，缓存命中可能失效。</li>\n<li>如果出现了服务器资源因为反复修改，但资源内容并没发生变化，此时浏览器再次请求服务器，实际上应该认为缓存命中（实际内容没有变化），但是此时通过该字段的比较会导致缓存命中失效。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Etag-If-None-Match-（优先级最高）\"><a href=\"#Etag-If-None-Match-（优先级最高）\" class=\"headerlink\" title=\"Etag / If-None-Match （优先级最高）\"></a><code>Etag</code> / <code>If-None-Match</code> （优先级最高）</h3><ul>\n<li>为了解决Last-Modifed的缓存命中问题，可以通过<code>Etag</code>来管理协商缓存命中。</li>\n<li>该字段是当前资源在服务器的唯一标识（生成规则有服务器决定），是基于文件内容进行编码的，如果文件内容不发生变动，那么该标识不会发生变更。</li>\n<li>服务端收到响应以后，根据当前资源内容重新生成一份<code>Etag</code> ，比较该值和<code>If-None-Match</code> 是否相等，相等则返回<strong>304</strong>，不相等则返回200和正常响应。但同<code>Last-Modified</code> 的区别在于即使服务器重新生成的<code>Etag</code>字段和原来的没有变化，但是因为重新生成了，304响应中同样会返回<code>Etag</code>字段。</li>\n</ul>\n<p>缓存流程图示</p>\n<img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e78f0f10bfdf44239d5881c9a85e74d9~tplv-k3u1fbpfcp-watermark.image?\" alt=\"缓存流程图示.jpg\" width=\"100%\" />\n\n<h1 id=\"用户操作执行的缓存策略\"><a href=\"#用户操作执行的缓存策略\" class=\"headerlink\" title=\"用户操作执行的缓存策略\"></a>用户操作执行的缓存策略</h1><p>一些涉及到缓存判断的用户行为操作</p>\n<table>\n<thead>\n<tr>\n<th>行为</th>\n<th>可以使用的缓存策略</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>在URL输入栏中输入然后回车 / 访问书签</td>\n<td>强缓存,协商缓存</td>\n<td></td>\n</tr>\n<tr>\n<td>地址栏回车 / 正常重新加载（command  + r）</td>\n<td>协商缓存</td>\n<td>在请求头加入 Cache-Control: max-age=0  使强缓存无效</td>\n</tr>\n<tr>\n<td>F5 / 点击工具栏刷新按钮 / 右键菜单重新加载（command + r）</td>\n<td>协商缓存</td>\n<td>在请求头加入 Cache-Control: max-age=0  使强缓存无效</td>\n</tr>\n<tr>\n<td>ctrl + F5 （command + shift + r）</td>\n<td>协商缓存</td>\n<td>在请求头加入Cache-Control: no-cache 使强缓存无效</td>\n</tr>\n</tbody></table>\n<blockquote>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3738c65c47f1453ba4e539ed41d9fd4d~tplv-k3u1fbpfcp-watermark.image?\" alt=\"用户刷新\" width=\"100%\" />\n</blockquote>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li><a href=\"https://segmentfault.com/a/1190000021716418\">5分钟看懂系列：HTTP缓存机制详解</a></li>\n<li><a href=\"https://juejin.cn/post/6844903725543194631\">f5到底刷新了点什么，你知道吗</a></li>\n<li><a href=\"https://juejin.cn/post/6844903672556552205\">前端优化：浏览器缓存技术介绍</a></li>\n<li><a href=\"https://juejin.cn/post/6844903801778864136\">深入理解HTTP缓存机制及原理</a></li>\n</ul>\n"}],"PostAsset":[{"_id":"source/_posts/this指针/1.png","post":"clesk19gg0006dddf8ug88ob6","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/this指针/2.png","post":"clesk19gg0006dddf8ug88ob6","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/this指针/3.png","post":"clesk19gg0006dddf8ug88ob6","slug":"3.png","modified":1,"renderable":1},{"_id":"source/_posts/this指针/4.png","post":"clesk19gg0006dddf8ug88ob6","slug":"4.png","modified":1,"renderable":1},{"_id":"source/_posts/this指针/5.png","post":"clesk19gg0006dddf8ug88ob6","slug":"5.png","modified":1,"renderable":1},{"_id":"source/_posts/this指针/7.png","post":"clesk19gg0006dddf8ug88ob6","slug":"7.png","modified":1,"renderable":1},{"_id":"source/_posts/this指针/8.png","post":"clesk19gg0006dddf8ug88ob6","slug":"8.png","modified":1,"renderable":1},{"_id":"source/_posts/this指针/this.png","post":"clesk19gg0006dddf8ug88ob6","slug":"this.png","modified":1,"renderable":1},{"_id":"source/_posts/浏览器同源策略/1.png","post":"clesk19gu000cdddf9jelhpk1","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/浏览器同源策略/2.png","post":"clesk19gu000cdddf9jelhpk1","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/浏览器同源策略/3.png","post":"clesk19gu000cdddf9jelhpk1","slug":"3.png","modified":1,"renderable":1},{"_id":"source/_posts/BFC/1.png","post":"clesk19fy0001dddf2ayc9v46","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/BFC/2.png","post":"clesk19fy0001dddf2ayc9v46","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/BFC/3.png","post":"clesk19fy0001dddf2ayc9v46","slug":"3.png","modified":1,"renderable":1},{"_id":"source/_posts/BFC/4.png","post":"clesk19fy0001dddf2ayc9v46","slug":"4.png","modified":1,"renderable":1},{"_id":"source/_posts/BFC/5.png","post":"clesk19fy0001dddf2ayc9v46","slug":"5.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"clesk19gp0007dddf00brfmpu","category_id":"clesk19ga0004dddf3ddxh0jy","_id":"clesk19gz000mdddfe8vcfjd1"},{"post_id":"clesk19gp0007dddf00brfmpu","category_id":"clesk19gx000gdddfc9yiezox","_id":"clesk19h1000pdddf58brezhk"},{"post_id":"clesk19fy0001dddf2ayc9v46","category_id":"clesk19ga0004dddf3ddxh0jy","_id":"clesk19ha000rdddfffjt1ibt"},{"post_id":"clesk19fy0001dddf2ayc9v46","category_id":"clesk19gy000jdddf0okffdyh","_id":"clesk19ha000tdddfeasnc6sg"},{"post_id":"clesk19gq0008dddf3r0l7kcm","category_id":"clesk19h0000ndddf0ajv5peo","_id":"clesk19hb000vdddf2ln1fp78"},{"post_id":"clesk19gu000cdddf9jelhpk1","category_id":"clesk19ha000sdddf4c0da5j5","_id":"clesk19hb000xdddfhuuk2a4l"},{"post_id":"clesk19gg0006dddf8ug88ob6","category_id":"clesk19ga0004dddf3ddxh0jy","_id":"clesk19hc0010dddfh7fz8u4c"},{"post_id":"clesk19gg0006dddf8ug88ob6","category_id":"clesk19hb000ydddf25aegwt5","_id":"clesk19hc0011dddf6eoyf35e"},{"post_id":"clesk19g70003dddffkmthmwi","category_id":"clesk19ga0004dddf3ddxh0jy","_id":"clesk19hc0012dddfhxd99mzt"},{"post_id":"clesk19g70003dddffkmthmwi","category_id":"clesk19hb000wdddf29hk77ki","_id":"clesk19hc0013dddf3936bgf9"},{"post_id":"clesk19g70003dddffkmthmwi","category_id":"clesk19hb000zdddfbmv1cgw3","_id":"clesk19hd0014dddfdbyf6bdg"},{"post_id":"clesk19he0015dddf98ez7pua","category_id":"clesk19ha000sdddf4c0da5j5","_id":"clesk19hu0017dddfexfo1eep"}],"PostTag":[{"post_id":"clesk19fy0001dddf2ayc9v46","tag_id":"clesk19gf0005dddf4r53cj18","_id":"clesk19gu000bdddf5kk6egzg"},{"post_id":"clesk19g70003dddffkmthmwi","tag_id":"clesk19gs000adddf562tgj75","_id":"clesk19gx000fdddf3we820eh"},{"post_id":"clesk19gg0006dddf8ug88ob6","tag_id":"clesk19gw000edddffngwetao","_id":"clesk19gy000idddff6dibk83"},{"post_id":"clesk19gp0007dddf00brfmpu","tag_id":"clesk19gs000adddf562tgj75","_id":"clesk19gz000ldddf3zid4sye"},{"post_id":"clesk19gq0008dddf3r0l7kcm","tag_id":"clesk19gy000kdddf0cmadi7c","_id":"clesk19h1000qdddf9jpbgxk5"},{"post_id":"clesk19gu000cdddf9jelhpk1","tag_id":"clesk19h0000odddf6k9o8zt9","_id":"clesk19hb000udddf4vr6b67x"},{"post_id":"clesk19he0015dddf98ez7pua","tag_id":"clesk19hg0016dddf2eb0gsgw","_id":"clesk19hu0018dddfc537f4hz"}],"Tag":[{"name":"<span class=\"label label-primary\">BFC</span> <span class=\"label label-primary\">CSS渲染</span>","_id":"clesk19gf0005dddf4r53cj18"},{"name":"<span class=\"label label-primary\">正则表达式</span>","_id":"clesk19gs000adddf562tgj75"},{"name":"<span class=\"label label-primary\">this</span> <span class=\"label label-primary\">箭头函数</span>","_id":"clesk19gw000edddffngwetao"},{"name":"<span class=\"label label-primary\">字体渲染</span> <span class=\"label label-primary\">ttf</span> <span class=\"label label-primary\">字符编码</span>","_id":"clesk19gy000kdddf0cmadi7c"},{"name":"<span class=\"label label-primary\">浏览器安全</span> <span class=\"label label-primary\">CORS</span>","_id":"clesk19h0000odddf6k9o8zt9"},{"name":"<span class=\"label label-primary\">浏览器缓存</span> <span class=\"label label-primary\">HTTP</span>","_id":"clesk19hg0016dddf2eb0gsgw"}]}}