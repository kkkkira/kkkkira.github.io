<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>meetOrSlice算法</title>
    <link href="/2023/03/03/meetOrSlice%E7%AE%97%E6%B3%95/"/>
    <url>/2023/03/03/meetOrSlice%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>本文重点是实现<code>preserveAspectRatio</code>中<code>&lt;meetOrSlice&gt;</code>参数的效果，也是<code>background-size</code>中值为<code>cover</code>，<code>contain</code>属性效果。在实现之前，简单介绍一下<strong>SVG</strong>中的<code>viewport</code>, <code>viewBox</code>和<code>preserveAspectRatio</code>的关系。</p><h2 id="画布"><a href="#画布" class="headerlink" title="画布"></a>画布</h2><p> 当我们创建SVG标签时，实际上是创建了一个<strong>隐形的无限延伸</strong>的画布。</p><h2 id="视窗（viewport）"><a href="#视窗（viewport）" class="headerlink" title="视窗（viewport）"></a>视窗（viewport）</h2><p> 画布是无限延伸的，但是人的视野是有限的，我们需要设置一个固定的区域，然后在这个固定的区域去绘制图形，使其可见。所以我们通过给SVG设置<code>width</code>和<code>height</code>属性（或者通过css设置宽高）设置一个可见区域，这个区域就是<strong>viewport</strong>，也就是视窗。这个区域是初始坐标系。</p><p> 在不做任何坐标系转换 (transform) 的情况下，我们绘制一个SVG图形，实际是绘制在画布上，但是是以<strong>viewport</strong>的坐标系为参考坐标系绘制的。可以理解为画布是绘制实体，视窗是用来确定具体绘制的位置和尺寸的。</p><h2 id="viewBox"><a href="#viewBox" class="headerlink" title="viewBox"></a>viewBox</h2><p> 什么是<strong>viewBox</strong>呢？</p><p> 可以理解为我们手里有一个任意尺寸的方形框，即<strong>viewBox</strong>，这个框可以在视窗的区域内任意位置游走。我们通过设置<strong>viewBox</strong>的属性值，可以指定这个框的尺寸（width, height），以及具体游走在视窗的那个位置（x, y）。</p><p> 在框内的画面就是我们最终看到的画面，我们将框内的区域“裁剪”出来，然后通过缩放填充整个视窗。而具体的缩放规则就要看<strong>preserveAspectRatio</strong>属性设置的值。</p><h2 id="preserveAspectRatio"><a href="#preserveAspectRatio" class="headerlink" title="preserveAspectRatio"></a>preserveAspectRatio</h2><p> 我们通过<strong>viewBox</strong>裁剪了一个区域，然后将这个区域缩放填充整个视窗。为了便于理解，我们将通过viewBox裁剪出来的区域称为<strong>content</strong>，将视窗称为<strong>box</strong>。</p><p> 为了使<strong>content</strong>在缩放过程不变形，我们需要保持<strong>content</strong>的宽高比，如果<strong>content</strong>和<strong>box</strong>的宽高比相等，则<strong>content</strong>通过缩放可以刚好填满整个<strong>box</strong>。但是如果宽高比不相等，那应该如何填充？</p><p> <strong>preserveAspectRatio</strong>就是为了解决这个问题而产生的。<strong>preserveAspectRatio</strong>中有两个参数<code>&lt;align&gt;</code>和<code>&lt;meetOrSlice&gt;</code>，一个值决定<strong>content</strong>按照什么规则缩放，一个值决定缩放后的<strong>content</strong>与<strong>box</strong>的对齐方式。</p><p> 其中<code>&lt;meetOrSlice&gt;</code>属性值的效果和<code>background-size</code>中<code>cover</code>和<code>contain</code> 类似。</p><p>关于更详细的SVG坐标系的解释，参考这两篇文章：</p><p><a href="https://www.w3cplus.com/html5/nesting-svgs.html">理解SVG坐标系统和变换： 建立新视窗</a></p><p><a href="https://www.w3cplus.com/html5/svg-coordinate-systems.html">理解SVG坐标系和变换：视窗,viewBox和preserveAspectRatio</a></p><p>接下来就详细介绍一下<code>&lt;meetOrSlice&gt;</code>是如何控制填充效果的。</p><h1 id="二、meetOrSlice定义"><a href="#二、meetOrSlice定义" class="headerlink" title="二、meetOrSlice定义"></a>二、meetOrSlice定义</h1><p>为了行文方便，仍然用<strong>content</strong>和<strong>box</strong>分别代指用于填充的矩形图和被填充的盒子。因为本文重点在于探索和实现<strong>preserveAspectRatio</strong>的<code>&lt;meetOrSlice&gt;</code>效果，在这里就不对<code>&lt;align&gt;</code>参数展开介绍了。</p><p><code>&lt;meetOrSlice&gt;</code>参数有两个值：<code>meet</code>和<code>slice</code>，其中<code>meet</code>类似于<code>background-size</code>中的<code>contain</code>，<code>slice</code>类似于<code>background-size</code>中的<code>cover</code>。</p><p>在<a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/preserveAspectRatio">MDN preserveAspectRatio</a>对这两个属性值是这样描述的：</p><blockquote><ul><li>meet (默认值)  图形将缩放到:<ul><li>宽高比将会被保留</li><li>整个SVG的viewbox在视图范围内是可见的</li><li>尽可能的放大SVG的viewbox，同时仍然满足其他的条件。</li></ul></li></ul><p>在这种情况下，如果图形的宽高比和视图窗口不匹配，则某些视图将会超出viewbox范围（即SVG的viewbox视图将会比可视窗口小）。</p><ul><li>slice 图形将缩放到:<ul><li>宽高比将会被保留</li><li>整个视图窗口将覆盖viewbox</li><li>SVG的viewbox属性将会被尽可能的缩小，但是仍然符合其他标准。</li></ul></li></ul><p>在这种情况下，如果SVG的viewbox宽高比与可视区域不匹配，则viewbox的某些区域将会延伸到视图窗口外部（即SVG的viewbox将会比可视窗口大）。</p></blockquote><p>简单概括就是两句话，在保持<strong>content</strong>宽高比不变的情况下：</p><p><code>meet / contain </code>：缩放，使<strong>box</strong>包含(contain)完整的<strong>content</strong>，<strong>box</strong>内部可能产生空白。重点：不产生“越界”现象</p><p><code>slice / cover</code>：缩放，使<strong>content</strong>覆盖(cover)<strong>box</strong>全部区域，<strong>content</strong>可能会超出<strong>box</strong>区域。重点：不产生空白区域</p><h1 id="三、理解meetOrSlice的填充规则"><a href="#三、理解meetOrSlice的填充规则" class="headerlink" title="三、理解meetOrSlice的填充规则"></a>三、理解meetOrSlice的填充规则</h1><p> 在了解了这个两个属性值的含义之后，我们再来探究这两个值的具体计算规则。<strong>box</strong>和<strong>content</strong>都是矩形，我们将矩形分为三类：正方形、竖向矩形、横向矩形：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c1618d33f9c79~tplv-t2oaga2asx-image.image"><br><strong>box</strong>和<strong>content</strong>分别有可能是其中的任意一类，通过排列组合可以得到9种对应关系（相等，同向，异向）：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c161e53a40906~tplv-t2oaga2asx-image.image"></p><p>为了更精确的对比所有尺寸得到的结果，我们分别设置三种类型的<strong>box</strong>尺寸，以及三种类型的<strong>content</strong>尺寸，如下：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c16219b143378~tplv-t2oaga2asx-image.image"></p><p>在<strong>SVG</strong>中，设置<code>meet</code>和<code>slice</code>，得到的结果如下（SVG缩放中会影响到矩形的边框宽度，所以同样的边框宽度因为缩放比例不同会导致最终的视觉宽度不同）：<br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c162390e34466~tplv-t2oaga2asx-image.image"></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c1625c3a49f49~tplv-t2oaga2asx-image.image"></p><p>根据定义和实验结果，我们可以发现：</p><ul><li><p><code>meet</code>模式下，为了使 <strong>content</strong>最大程度的被完整包含在<strong>box</strong>内部，总是<strong>content</strong>的<strong>长边</strong>与<strong>box</strong>对应边对齐。</p></li><li><p><code>slice</code>模式下，为了使<strong>box</strong>被填满，总是<strong>content</strong>的<strong>短边</strong>与<strong>box</strong>对应边对齐。</p></li></ul><p>但这两点并不能包含全部情况，我们看👇例子：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c1632ee3c06e3~tplv-t2oaga2asx-image.image"></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c16354a9da897~tplv-t2oaga2asx-image.image"></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c16379452d7e0~tplv-t2oaga2asx-image.image"></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c1639f03b62ff~tplv-t2oaga2asx-image.image"></p><p>从上面的4个例子中可以发现，当<strong>box</strong>和<strong>content</strong>都是同向的矩形（均为横向或者竖向）时，<code>meet</code>情况下，还需要继续判断短边的长度；而在<code>slice</code>的情况下还需要继续判断长边的长度。</p><p>所以我们可以这样描述：</p><ul><li><p><code>meet</code>：总是比较两者的<strong>长边</strong>：</p><ul><li><p>长边同边（同边：都是横向或者竖向矩形）：假设都为横向矩形，根据宽高比计算在<strong>同一个宽度</strong>下两者的高度，判断哪个的高度更高（反之同理）：</p><ul><li>如果<code>contentHeight &gt; boxHeight</code>（此时<strong>box</strong>更“扁”）：为了使<strong>content</strong>被完整包含在<strong>box</strong>里，需要让<strong>content</strong>的高等于<strong>box</strong>的高（对齐高）</li><li>如果<code>boxHeight &gt; contentHeight</code>（此时<strong>content</strong>更“扁”）：使<strong>content</strong>的宽等于<strong>box</strong>的宽（对齐宽）</li></ul></li><li><p>长边异边（异边：一个为横向另一个为竖向）：假设<strong>content</strong>为横向，长边为宽，<strong>box</strong>为竖向，长边为高（可以理解为content更扁一点），则使<strong>content</strong>的宽等于<strong>box</strong>的宽（对齐宽），反之同理。</p></li></ul></li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c17e213819216~tplv-t2oaga2asx-image.image"></p><ul><li><code>slice</code>：总是比较两者的<strong>短边</strong>：<ul><li>短边同边（同边：同上描述）：假设都为横向矩形，根据宽高比计算在<strong>同一个宽度</strong>下两者的高度，判断哪个的高度更高：<ul><li>如果<code>contentHeight &gt; boxHeight</code>（此时box更“扁”） ：使<strong>content</strong>的宽等于<strong>box</strong>的宽（对齐宽）</li><li>如果<code>boxHeight &gt; contentHeight</code>（此时content更“扁”）：使<strong>content</strong>的高等于<strong>box</strong>的高（对齐高）</li></ul></li><li>短边异边（异边：同上描述）：假设<strong>content</strong>为横向，短边为高，<strong>box</strong>为竖向，短边为宽，（content更扁），使<strong>content</strong>的高等于<strong>box</strong>的高（对齐高），反之同理。</li></ul></li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/29/171c18c514237275~tplv-t2oaga2asx-image.image"></p><p>现在，我们已经知道<code>meet</code>和<code>slice</code>的缩放规律，根据图，我们可以进一步归纳逻辑。在这里，根据矩形形状的特点，使用“扁”作为统一标准：同宽情况下，高度越小，越扁。</p><p>在保持<strong>content</strong>宽高比缩放的情况下，比较<strong>content</strong>和<strong>box</strong>的“扁”度：</p><ul><li><p>meet</p><ul><li>box &gt; content  =&gt; 对齐高：<strong>content</strong>的宽高同时乘以一个值使<strong>content</strong>的高等于<strong>box</strong>高</li><li>box &lt; content =&gt; 对齐宽：<strong>content</strong>的宽高同时乘以一个值使<strong>content</strong>的宽等于<strong>box</strong>宽</li></ul></li><li><p>slice</p><ul><li>box &gt; content  =&gt; 对齐宽：同上</li><li>box &lt; content =&gt;对齐高： 同上</li></ul></li></ul><p>伪代码可以这样描述：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">if(type == <span class="hljs-string">&#x27;meet&#x27;</span>)&#123;<br>  if(<span class="hljs-keyword">box_扁 </span>&gt; content_扁)&#123;<br>   content_高 * <span class="hljs-keyword">scale </span>= <span class="hljs-keyword">box_高;</span><br><span class="hljs-keyword"></span>   content_宽 * <span class="hljs-keyword">scale </span>= new_content_宽;<br>  &#125;else&#123;<br>content_宽 * <span class="hljs-keyword">scale </span>= <span class="hljs-keyword">box_宽;</span><br><span class="hljs-keyword"></span>content_高 * <span class="hljs-keyword">scale </span>= new_content_高;<br>  &#125;<br>&#125;else if(type == <span class="hljs-string">&#x27;slice&#x27;</span>)&#123;<br> if(<span class="hljs-keyword">box_扁 </span>&gt; content_扁)&#123;<br>content_宽 * <span class="hljs-keyword">scale </span>= <span class="hljs-keyword">box_宽;</span><br><span class="hljs-keyword"></span>content_高 * <span class="hljs-keyword">scale </span>= new_content_高;<br>  &#125;else&#123;<br>content_高 * <span class="hljs-keyword">scale </span>= <span class="hljs-keyword">box_高;</span><br><span class="hljs-keyword"></span>   content_宽 * <span class="hljs-keyword">scale </span>= new_content_宽;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四、实现meetOrSlice方法"><a href="#四、实现meetOrSlice方法" class="headerlink" title="四、实现meetOrSlice方法"></a>四、实现meetOrSlice方法</h1><p>根据伪代码的描述，为了真正实现这个算法，我们需要：</p><ul><li><p>得到一个矩形的“<strong>扁</strong>”度</p></li><li><p>得到<strong>scale</strong>值</p></li></ul><p>其实上面两点非常容易获取：</p><ul><li><p>如果一个矩形越扁，意味着宽高比越大，所以可以通过宽高比 <code>width / height</code> 来获取“扁”度。</p></li><li><p>而<strong>scale</strong>，在伪代码中其实已经能发现scale的计算方法（假设对齐宽）：</p></li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">contentW * scale <span class="hljs-operator">=</span> boxW<span class="hljs-comment">;</span><br><span class="hljs-attribute">scale</span> <span class="hljs-operator">=</span> boxW / contentW<span class="hljs-comment">;</span><br><br><br>所以缩放后的content宽高为：<br><span class="hljs-attribute">newContentW</span> <span class="hljs-operator">=</span> scale * contentW<span class="hljs-comment">;</span><br><span class="hljs-attribute">newContentH</span> <span class="hljs-operator">=</span> scale * contentH<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>由此，我们就可以写出<code>meet</code>和<code>slice</code>方法了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">meetOrSlice</span>(<span class="hljs-params">type, boxW, boxH, contentW, contentH</span>)&#123;<br>    <span class="hljs-keyword">let</span> boxRadio = boxW / boxH,<br>        contentRadio = contentW / contentH,<br>        scaleW = (boxW / contentW) || <span class="hljs-number">1</span>,<br>        scaleH = (boxH / contentH) || <span class="hljs-number">1</span>,<br>        scale = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(type == <span class="hljs-string">&#x27;meet&#x27;</span>)&#123;<br>        scale = boxRadio &gt;= contentRadio ? scaleH : scaleW;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type == <span class="hljs-string">&#x27;slice&#x27;</span>)&#123;<br>        scale = boxRadio &gt;= contentRadio ? scaleW : scaleH;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">w</span>: scale * contentW,<br>        <span class="hljs-attr">h</span>: scale * contentH<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后和SVG对比一下效果，其中关于边框的两个问题： </p><ul><li>svg中边框宽度不一致：是因为SVG缩放中会连同边框一起缩放 </li><li>svg中部分 部分边框被裁切：是因为svg内部矩形的x,y定位，是以边框的中线为标准计算的，所以当坐标点为<code>(0,0)</code>时，会有一半的边框超出svg的窗口范围，导致被截断。</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c1656567c3728~tplv-t2oaga2asx-image.image"></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c165994da0a5e~tplv-t2oaga2asx-image.image"><br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/28/171c165af0998dc9~tplv-t2oaga2asx-image.image"></p><p><a href="https://github.com/kkkkira/demo/blob/master/meetOrSlice/index.html">点击查看源码</a></p><p>完结，撒花🎉。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.w3cplus.com/html5/nesting-svgs.html">理解SVG坐标系统和变换： 建立新视窗</a></p><p><a href="https://www.w3cplus.com/html5/svg-coordinate-systems.html">理解SVG坐标系和变换：视窗,viewBox和preserveAspectRatio</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/preserveAspectRatio">MDN preserveAspectRatio</a></p>]]></content>
    
    
    <categories>
      
      <category>Web前端</category>
      
      <category>SVG</category>
      
    </categories>
    
    
    <tags>
      
      <tag>&lt;span class=&quot;label label-primary&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;label label-primary&quot;&gt;正则表达式&lt;/span&gt;</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS正则表达式入门</title>
    <link href="/2023/03/03/JS%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8/"/>
    <url>/2023/03/03/JS%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="简单理解正则表达式"><a href="#简单理解正则表达式" class="headerlink" title="简单理解正则表达式"></a>简单理解正则表达式</h2><p>正则表达式是用于匹配字符串中字符组合的模式，可以这样定义：</p><blockquote><p>正则表达式是对字符串（包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为“元字符”））操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。正则表达式是一种文本模式，该模式描述在搜索文本时要匹配的一个或多个字符串。</p><p>胡军伟, 秦奕青, 张伟. 正则表达式在Web信息抽取中的应用[J]. 北京信息科技大学学报(自然科学版), 2011, 26(6):86-89.</p></blockquote><p>可以简单理解为，正则表达式就是对字符串操作的一种逻辑公式，就像数学公式一样，通过按照一定的规则，组合使用<code>+ - * / （）=</code> 以及数字或者变量，形成一个表达式。正则表达式也是使用一些具有特殊含义的<strong>特定符号</strong>，来抽象表达符合某种规则的字符串。这种特定符号，我们称之为<strong>元字符</strong>。元字符按功能又可以分为以下几种类型：</p><ul><li>字符</li><li>位置</li><li>量词</li><li>分支</li><li>分组</li><li>引用</li></ul><p>通过对不同类型的元字符进行任意组合，就可以生成一个模式，使用这个模式，就可以在任意字符串中匹配你想要的内容。在js中，我们一般使用 <code>/表达式/ </code>的字面量来表示这是一个正则表达式。</p><h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><p>在一个字符串中，如果我们想要要匹配某个或者某种类型的字符，我们可以选择<strong>精确匹配</strong>和<strong>模糊匹配</strong>。</p><h4 id="模糊匹配"><a href="#模糊匹配" class="headerlink" title="模糊匹配"></a>模糊匹配</h4><p>模糊匹配就是一个<strong>元字符</strong>可以表示某一类字符集。</p><p>下表列出了一些常用的元字符集：</p><table><thead><tr><th>字符</th><th>定义</th><th>描述</th></tr></thead><tbody><tr><td><code>.</code></td><td>通用符</td><td>匹配除换行符（<code>\n</code>、<code>\r</code>）之外的任何单个字符</td></tr><tr><td><code>\s</code></td><td>空白符（space）</td><td>匹配任何<strong>空白字符</strong>，包括<strong>空格</strong>、<strong>换页符</strong>、<strong>换行符</strong>、<strong>回车符</strong>、<strong>制表符</strong>、<strong>垂直制表符</strong><br />等价于 <code>[ \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]</code><br />⚠️ 这里有一个空格符号<br />⚠️ 记忆：空格符（十进制、八进制、十六进制） +  表中的特殊符号（十进制、八进制、十六进制）</td></tr><tr><td><code>\S</code></td><td>非空白符</td><td>匹配任何<strong>非</strong>空白字符<br />等价于<code>[^ \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]</code>（这里的<code>^</code>表示<strong>非</strong>的意思）</td></tr><tr><td><code>\d</code></td><td>数字符（digital）</td><td>匹配一个数字。等价于<code>[0-9]</code></td></tr><tr><td><code>\D</code></td><td>非数字符</td><td>匹配一个非数字符。等价于<code>[^0-9]</code></td></tr><tr><td><code>\w</code></td><td>字母、数字、下划线符（word）</td><td>匹配一个单字字符（字母、数字或者下划线）。<br />等价于 <code>[A-Za-z0-9_]</code>。</td></tr><tr><td><code>\W</code></td><td>非（字母、数字、下划线）符</td><td>匹配一个非单字字符。<br />等价于 <code>[^A-Za-z0-9_]</code>。</td></tr><tr><td><code>\f</code></td><td>换页符（特殊符号）</td><td></td></tr><tr><td><code>\n</code></td><td>换行符（特殊符号）</td><td></td></tr><tr><td><code>\r</code></td><td>回车符（特殊符号）</td><td></td></tr><tr><td><code>\t</code></td><td>制表符（特殊符号）</td><td></td></tr><tr><td><code>\v</code></td><td>垂直制表符（特殊符号）</td><td></td></tr><tr><td><code>[xyz]</code></td><td>自定义字符集</td><td>你可以在字符集中任意组合元字符和普通字符，形成一个自定义字符集，从而使字符串去匹配方括号中的任意字符。<br />可以使用 <code>-</code> 破折号代表范围<br />🌰<br /><code>[xyz]</code>：可以匹配<code>x</code> <code>y</code> <code>z</code> 三个字符中的任意一个<br /><code>[0-9a-z]</code>：等价于<code>[0123456789zbcdefghijklmnopqrstuvwxyz]</code> 表示匹配任意一个数字或者小写字母<br /><code>[\dAa-z]</code> ：表示可以匹配任意一个数字（<code>\d</code>）或者小写字母(<code>a-z</code>)以及大写字母<code>A</code></td></tr><tr><td><code>[^xyz]</code></td><td>自定义（排除）字符集</td><td>在方括号内部的开头加上<code>^</code>，表示匹配任意一个<strong>不是</strong>自定义字符集内部的字符。如果在中间加上非呢？<br />🌰<br /><code>[^xyz]</code>：匹配<strong>排除</strong><code>x</code> <code>y</code> <code>z</code> 以外的任意一个字符<br /><code>[^\dAa-z]</code> ：表示可以匹配任意一个 <strong>不是</strong> 数字（<code>\d</code>） 且<strong>不是</strong>小写字母(<code>a-z</code>)且<strong>不是</strong>大写字母<code>A</code>的字符</td></tr></tbody></table><h4 id="精确匹配"><a href="#精确匹配" class="headerlink" title="精确匹配"></a>精确匹配</h4><p>除<strong>元字符</strong>外，其他任意一个字符，只匹配字符本身。例如<code>/a/</code>，只能匹配字符串<code>abc</code>中的<code>a</code>。</p><p> 如果想要匹配元字符<strong>本身</strong>，使用转义符号<code>\</code>进行转义。</p><p>🌰 想要匹配 <code>.</code> ，则写成<code>\.</code></p><p>🌰 想要匹配<code>+</code>（量词类型元字符），则写成<code>\+</code></p><h4 id="单字符匹配"><a href="#单字符匹配" class="headerlink" title="单字符匹配"></a>单字符匹配</h4><p>⚠️ 无论是模糊匹配还是精确匹配，在<strong>不加量词</strong>的情况下，一个<strong>字符符号</strong>（元字符或者普通符号）只能匹配单个字符。我们可以把正则里面的符号理解为占位符，一个萝卜一个坑。所以只要当前这个符号匹配到了字符，坑就被占了，下一个字符就需要有新的符号去匹配。所以我们如果要匹配多个字符，只要将多个<strong>字符符号</strong>组合在一起，形成一个子串模式，就能匹配一个满足条件的连续字符串。</p><h5 id="匹配数字"><a href="#匹配数字" class="headerlink" title="匹配数字"></a>匹配数字</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;the id is: 123&#x27;</span>;<br><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/\d/</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(reg)); <br><span class="hljs-comment">// [ &#x27;1&#x27;, index: 11, input: &#x27;the id is: 123&#x27;, groups: undefined ]</span><br><span class="hljs-comment">// match方法返回一个数组，其中数组的第一个元素表示匹配到的内容。</span><br><span class="hljs-comment">// 可以看到每次只匹配一个字符</span><br></code></pre></td></tr></table></figure><h5 id="替换空白符号"><a href="#替换空白符号" class="headerlink" title="替换空白符号"></a>替换空白符号</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;the space is: \n,\f,\r,\t,\v&#x27;</span>;<br><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/\s/g</span>;<span class="hljs-comment">// 将整个字符串中的空白符都替换为#</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">replace</span>(reg, <span class="hljs-string">&#x27;#&#x27;</span>));<br><span class="hljs-comment">// 一次只会匹配成功一个，replace方法的说明在下面</span><br><span class="hljs-comment">//the#space#is:##,#,#,#,#</span><br></code></pre></td></tr></table></figure><h5 id="删除所有非单字符"><a href="#删除所有非单字符" class="headerlink" title="删除所有非单字符"></a>删除所有非单字符</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;删除当前行中非数字(delete not number)123，(not word)非英文字母和非下划线_的符号！&#x27;</span>;<br><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/\W/g</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">replace</span>(reg, <span class="hljs-string">&#x27;&#x27;</span>));<br><span class="hljs-comment">//deletenotnumber123notword_</span><br></code></pre></td></tr></table></figure><h5 id="自定义字符集"><a href="#自定义字符集" class="headerlink" title="自定义字符集"></a>自定义字符集</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;在字符串中只留下字符集中的字符: 数字123，通配符. 普通英文字母wwwww&#x27;</span>;<br><br><span class="hljs-keyword">let</span> reg1 = <span class="hljs-regexp">/[^\.数w]/g</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">replace</span>(reg1, <span class="hljs-string">&#x27;&#x27;</span>));<br><span class="hljs-comment">// 数.wwwww</span><br><br><span class="hljs-keyword">let</span> reg2 = <span class="hljs-regexp">/[\.数w]/g</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">replace</span>(reg1, <span class="hljs-string">&#x27;&#x27;</span>));<br><span class="hljs-comment">//在字符串中只留下字符集中的字符: 字123，通配符 普通英文字母</span><br></code></pre></td></tr></table></figure><h2 id="位置类型"><a href="#位置类型" class="headerlink" title="位置类型"></a>位置类型</h2><p>什么是位置，什么又是位置字符呢？</p><p>其实在一个连续的字符串中，相邻字符之间是存在一个位置的，我们可以把这个位置理解为空字符。如图所示（图源网络）：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/5/1731e6ec5794d5c5~tplv-t2oaga2asx-image.image"></p><p>在正则中，我们除了可以匹配具体字符以外，还可以使用元字符来表示具体要匹配哪个位置。</p><p>在js中，表示位置的元字符分为4类：</p><table><thead><tr><th>位置</th><th>相关元字符</th></tr></thead><tbody><tr><td>开始</td><td><code>^</code></td></tr><tr><td>结尾</td><td><code>$</code></td></tr><tr><td>单词边界</td><td><code>\b</code> <code>\B</code></td></tr><tr><td>断言</td><td><code>(?=)</code><br /><code>(?!)</code><br /><code>(?&lt;=)</code><br /><code>(?&lt;!)</code></td></tr></tbody></table><h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><p>元字符<code>^</code>既可以表示位置，也可以代表非。</p><ul><li>表示位置时：这个元字符写在整个正则表达式的最开始。</li><li>表示非时：写在方括号<code>[]</code>的最开始。</li></ul><p>当表示开始位置，代表当前正则表达式<strong>必须</strong>从字符串的<strong>最开始</strong>进行匹配。如果不存在这个元字符，只要字符串中任意一个子串满足正则表达式即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/^\d/</span>;<span class="hljs-comment">// 表示匹配到的字符串必须以数字开头</span><br><span class="hljs-keyword">let</span> str1 = <span class="hljs-string">&quot;abcdefg123&quot;</span>;<br><span class="hljs-keyword">let</span> str2 = <span class="hljs-string">&quot;123abcd&quot;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg.<span class="hljs-title function_">test</span>(str1)) <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg.<span class="hljs-title function_">test</span>(str2)) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>我们通常情况下都是对一个连续的单行字符串进行匹配，<code>^</code> 表示整个字符串的最开始。如果想要匹配多行文本中每行的开头，需要满足两个条件：</p><ol><li>当前字符串需要使用换行符<code>\n</code>分割形成多行文本，<code>^</code>表示换行符<strong>后</strong>紧跟的位置</li><li>需要将正则的多行标志<code>multiple</code>置为<code>true</code>（之后说明）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/^\d+/mg</span>;<span class="hljs-comment">// m表示开启多行匹配。匹配当前多行文本中所有以数字开头的行，并获取开头的数字内容</span><br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;123ad\n0abc123\nabc123&#x27;</span>;<br><span class="hljs-keyword">let</span> a = str.<span class="hljs-title function_">match</span>(reg);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br><br><span class="hljs-comment">//[ &#x27;123&#x27;, &#x27;0&#x27; ]</span><br></code></pre></td></tr></table></figure><h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><p>元字符 <code>$</code> 表示结束位置。匹配输入的结束。同 <code>^</code> 一样，如果多行标志被设置为 <code>true</code>，那么也匹配换行符<code>\n</code><strong>前</strong>紧贴的位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/\d$/</span>;<span class="hljs-comment">// 表示匹配到的字符串必须以数字结尾</span><br><span class="hljs-keyword">let</span> str1 = <span class="hljs-string">&quot;abcdefg123&quot;</span>;<br><span class="hljs-keyword">let</span> str2 = <span class="hljs-string">&quot;123abcd&quot;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg.<span class="hljs-title function_">test</span>(str1)) <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg.<span class="hljs-title function_">test</span>(str2)) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/\d+$/mg</span>;<span class="hljs-comment">// m表示开启多行匹配。匹配当前多行文本中所有以数字开头的行，并获取开头的数字内容</span><br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;123ad\n0abc2\nabc3&#x27;</span>;<br><span class="hljs-keyword">let</span> a = str.<span class="hljs-title function_">match</span>(reg);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br><br><span class="hljs-comment">//[ &#x27;2&#x27;, &#x27;3&#x27; ]</span><br></code></pre></td></tr></table></figure><h4 id="单词边界"><a href="#单词边界" class="headerlink" title="单词边界"></a>单词边界</h4><p>其实在这里，<code>\b</code> 表示单词边界的位置，<code>\B</code>表示<strong>非单词边界</strong>的位置。</p><p>那什么是单词呢？我们回到之前的字符类型的元字符表可以看到，<code>\w</code>其实就是word，连续的word形成了words，就是代表了这里的单词。我们已经知道<code>\w</code>等价于<code>[A-Za-z0-9_]</code>，所以这里的单词就是指带了这些字符。</p><p>那边界的定义又是什么？</p><p>我们已知，每两个相邻字符之间，都存在一个位置，如果相邻两个字符都属于<code>\w</code>，那这两个相邻字符之间的位置就叫<strong>非单词边界<code>\B</code><strong>；如果两个相邻字符</strong>只有一个</strong>字符属于<code>\w</code>，或者<strong>两个都不属于</strong><code>\w</code>，那它们之间的位置就叫做**单词边界<code>\b</code>**。 （<code>b</code>可以理解为<code>break</code>）</p><p>需要注意的一点，字符串的开始和结束，都算作单词边界。可以理解为在字符串的开始和结束，存在一个空字符<code>&quot;&quot;</code> ，那么无论相邻的字符是否属于<code>\w</code>，都存在一个空字符<code>&quot;&quot;</code>不属于<code>\w</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> breakReg = <span class="hljs-regexp">/\b/g</span>,<br>    notBreakReg = <span class="hljs-regexp">/\B/g</span>;<br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;word_break.mp3&quot;</span>;<br><span class="hljs-keyword">let</span> bStr = str.<span class="hljs-title function_">replace</span>(breakReg, <span class="hljs-string">&quot;|&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Bstr</span> = str.<span class="hljs-title function_">replace</span>(notBreakReg, <span class="hljs-string">&quot;|&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;bStr is: &quot;</span>, bStr);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Bstr is: &quot;</span>, <span class="hljs-title class_">Bstr</span>);<br><br><br><span class="hljs-comment">// bStr is:  |word_break|.|mp3|</span><br><span class="hljs-comment">// Bstr is:  w|o|r|d|_|b|r|e|a|k.m|p|3</span><br></code></pre></td></tr></table></figure><h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><blockquote><p>零宽断言正如它的名字一样，是一种零宽度的匹配，它匹配到的内容不会保存到匹配结果中去，最终匹配结果只是一个位置而已。<br>作用是给指定位置添加一个限定条件，用来规定此位置之前或者之后的字符必须满足限定条件才能使正则中的字表达式匹配成功。</p><p>​                                                          ——源自博客《正则表达式零宽断言详解》</p></blockquote><p>听起来断言很复杂，其实道理很简单。所谓断言，其实就是我们的正则表达式在<strong>匹配位置</strong>的时候，必须要满足一定的条件才行。这里的条件，就是一个子表达式，其中断言又分为：</p><ul><li>先行：<ul><li>正向：<code>(?=子表达式)</code></li><li>负向：<code>(?!子表达式)</code></li></ul></li><li>后行：<ul><li>正向：<code>(?&lt;=子表达式)</code></li><li>负向：<code>(?&lt;!子表达式)</code></li></ul></li></ul><p>在这里，先行和后行为相反组，表示匹配的位置在前还是在后；正向和负向为相反组，表示是否满足条件。组合起来的意思就是：</p><ul><li>正向先行<code>(?=)</code>：匹配<strong>满足</strong>子表达式的字符串<strong>前面</strong>的位置</li><li>正向后行<code>(?&lt;=)</code>：匹配<strong>满足</strong>子表达式的字符串<strong>后面</strong>的位置</li><li>负向先行<code>(?!)</code>：匹配<strong>不满足</strong>子表达式的字符串<strong>前面</strong>的位置</li><li>负向后行<code>(?&lt;!)</code>：匹配<strong>不满足</strong>子表达式的字符串<strong>后面</strong>的位置</li></ul><p>简单记忆：</p><ul><li>正向：满足</li><li>负向：不满足</li><li>先行：前面</li><li>后行：后面</li></ul><h5 id="正向（先-后）行"><a href="#正向（先-后）行" class="headerlink" title="正向（先/后）行"></a>正向（先/后）行</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;在js前面插入===,后面插入---: 前端基础三件套html,css,js; node, npm, react或者vue是新的三件套&#x27;</span>;<br><br><span class="hljs-keyword">let</span> reg1 = <span class="hljs-regexp">/(?=js)/g</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">replace</span>(reg1, <span class="hljs-string">&#x27;===&#x27;</span>));<br><span class="hljs-comment">// 在===js前面插入===,后面插入---: 前端基础三件套html,css,===js; node, npm, react或者vue是新的三件套</span><br><br><br><span class="hljs-keyword">let</span> reg2 = <span class="hljs-regexp">/(?&lt;=js)/g</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">replace</span>(reg2, <span class="hljs-string">&#x27;---&#x27;</span>));<br><span class="hljs-comment">// 在js---前面插入===,后面插入---: 前端基础三件套html,css,js---; node, npm, react或者vue是新的三件套</span><br></code></pre></td></tr></table></figure><h5 id="负向（先-后）行"><a href="#负向（先-后）行" class="headerlink" title="负向（先/后）行"></a>负向（先/后）行</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;the number is 0000&#x27;</span>; <br><span class="hljs-comment">// 在所有非字母和非空白符的字符前插入 ===，后面插入---</span><br><span class="hljs-comment">// 实际上在这个字符串中会有三个字符会匹配成功：数字字符、字符串的开始空字符、结束空字符。</span><br><br><span class="hljs-keyword">let</span> reg1 = <span class="hljs-regexp">/(?![a-zA-Z\s])/g</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">replace</span>(reg1, <span class="hljs-string">&#x27;===&#x27;</span>));<br><span class="hljs-comment">// the number is ===0===0===0===0===</span><br><span class="hljs-comment">// 最后一个===实际上是匹配到了结束空字符&#x27;&#x27;，在结束空字符前插入了===</span><br><br><span class="hljs-keyword">let</span> reg2 = <span class="hljs-regexp">/(?&lt;![a-zA-Z\s])/g</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">replace</span>(reg2, <span class="hljs-string">&#x27;---&#x27;</span>));<br><span class="hljs-comment">// ---the number is 0---0---0---0---</span><br><span class="hljs-comment">// 第一个---实际上是匹配到了开始空字符&#x27;&#x27;，在开始空字符后插入了---</span><br></code></pre></td></tr></table></figure><h2 id="量词类型"><a href="#量词类型" class="headerlink" title="量词类型"></a>量词类型</h2><p>根据前面的了解，我们知道 一个符号只能匹配一个字符，如果要匹配多个字符，就需要组合多个符号（包括元字符和普通字符）来进行匹配。但是如果要匹配一个连续重复的字符串<code>aaaaaaaaa</code>，按照前面的逻辑，我们的正则表达式要写出 <code>/aaaaaaaaa/</code> 才行。有没有更简便的方法呢？</p><p>答案是有的。</p><p>在正则中，存在这种量词类型的元字符，来简化表达式本身。例如上面的正则表达式我们可以写成<code>/a&#123;9&#125;/</code>，表示当前满足条件，能匹配成功的子串包含9个连续的a。</p><p>量词类型的元字符用来表示重复次数，具体重复的对象，是前面紧跟的子模式。</p><p>其中，量词元字符包括：</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td><code>*</code></td><td>重复0到n次</td></tr><tr><td><code>+</code></td><td>重复1到n次</td></tr><tr><td><code>?</code></td><td>出现0次或者1次</td></tr><tr><td><code>&#123;n&#125;</code></td><td>重复n次</td></tr><tr><td><code>&#123;n,&#125;</code></td><td>至少重复n次</td></tr><tr><td><code>&#123;n, m&#125;</code></td><td>重复n到m次</td></tr></tbody></table><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;the number is 0000123122, phone number is 057-9981013&#x27;</span>;<br><br><span class="hljs-keyword">let</span> reg1 = <span class="hljs-regexp">/\d+/g</span>;<br><span class="hljs-keyword">let</span> reg2 = <span class="hljs-regexp">/[num]&#123;3&#125;/g</span>;<br><span class="hljs-keyword">let</span> reg3 = <span class="hljs-regexp">/0&#123;2,4&#125;/g</span>;<br><span class="hljs-keyword">let</span> reg4 = <span class="hljs-regexp">/,?/</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(reg1))<br><span class="hljs-comment">// [ &#x27;0000123122&#x27;, &#x27;057&#x27;, &#x27;9981013&#x27; ]</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(reg2))<br><span class="hljs-comment">// [ &#x27;num&#x27;, &#x27;num&#x27; ]</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(reg3))<br><span class="hljs-comment">// [ &#x27;0000&#x27; ]</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg4.<span class="hljs-title function_">test</span>(str))<br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="分组类型"><a href="#分组类型" class="headerlink" title="分组类型"></a>分组类型</h2><p>我们已知如何匹配一段由一个字符重复n次构成的字符串，例如 <code>aaaaaa</code> 。假如现在我们的字符串是<code>123xyzxyzxyz1axyzxyz</code>，很明显，这串字符中也存在重复的子串，但是并不满足单字符重复的特点，我们无法使用已经学到的东西来写出正则表达式。这个时候，就是分组类型的元字符上场的时候了。</p><p>分组由圆括号 <code>()</code> 来表示。括号内部是子表达式，表示一个子串的匹配模式。说白了，分组就是把一些特殊的单字符组合看作一个单元，我们在匹配时，遇到这样的单元就当做一个整体来处理。具体是哪些特殊字符的组合，就可以任意定义，然后写成子模式。例如上面的字符串，我们把<code>xyz</code>看作一个单元，想要匹配出<code>xyz</code>，就可以这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;123xyzxyzxyz1axyzxyz&quot;</span>;<br><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/(xyz)/g</span>;<br><span class="hljs-keyword">let</span> match = str.<span class="hljs-title function_">match</span>(reg);<br><br><span class="hljs-comment">// [ &#x27;xyz&#x27;, &#x27;xyz&#x27;, &#x27;xyz&#x27;, &#x27;xyz&#x27;, &#x27;xyz&#x27; ]</span><br></code></pre></td></tr></table></figure><p>如果把连续的两个甚至多个<code>xyz</code>看作一个单元来匹配，只需要需要在分组后添加量词即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;123xyzxyzxyz1axyzxyz&quot;</span>;<br><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/(xyz)+/g</span>;<br><span class="hljs-keyword">let</span> match = str.<span class="hljs-title function_">match</span>(reg);<br><br><span class="hljs-comment">// [ &#x27;xyzxyzxyz&#x27;, &#x27;xyzxyz&#x27; ]</span><br></code></pre></td></tr></table></figure><p>在分组类型的元字符中，有三种类型：</p><table><thead><tr><th><strong>捕获分组</strong></th><th><strong><code>（子表达式）</code></strong></th></tr></thead><tbody><tr><td><strong>命名捕获分组</strong></td><td><strong>(?<name>子表达式)</strong></td></tr><tr><td><strong>非捕获分组</strong></td><td><strong><code>(?:子表达式)</code></strong></td></tr></tbody></table><h5 id="捕获与非捕获"><a href="#捕获与非捕获" class="headerlink" title="捕获与非捕获"></a>捕获与非捕获</h5><p>其区别就在于，当我们使用捕获分组的时候，每个子表达式匹配到的内容都会被分别记录下来，后面我们可以通过相应的api或者是引用类型的元字符获取到不同分组的匹配项；而非捕获分组就是不记录这个匹配项。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/(\d+)(?:[a-z]+)/</span>;<br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;123abcd&quot;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(reg))<br><span class="hljs-comment">// [ &#x27;123abcd&#x27;, &#x27;123&#x27;, index: 0, input: &#x27;123abcd&#x27;, groups: undefined ]</span><br><span class="hljs-comment">// 在这里，123abcd是整个正则匹配到的内容，而123则是我们捕获分组匹配到的内容</span><br><span class="hljs-comment">// 可以看到，此时非捕获分组匹配到的内容并没有被保存下来，我们无法单独获取</span><br></code></pre></td></tr></table></figure><h5 id="匿名捕获与命名捕获"><a href="#匿名捕获与命名捕获" class="headerlink" title="匿名捕获与命名捕获"></a>匿名捕获与命名捕获</h5><p>其中捕获分组又分为命名和匿名分组，匿名分组则使用索引值来获取，而命名分组除了可以使用索引值访问以外，还可以通过指定的属性访问获取。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/(\d+)(?&lt;char&gt;[a-z]+)/</span>;<br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;123abcd&quot;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(reg))<br></code></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/5/1731e6ccb87320ec~tplv-t2oaga2asx-image.image"></p><p>从结果中我们可以看到，使用命名捕获分组匹配到的分组，不但可以通过索引值来获取，还可以通过<code>groups.char</code>获取。</p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>引用，其实就是对捕获分组匹配到的内容的引用。</p><p>在两个地方可以使用引用：</p><ul><li>在表达式本式中</li><li>在相关的函数中</li></ul><h5 id="表达式中的引用"><a href="#表达式中的引用" class="headerlink" title="表达式中的引用"></a>表达式中的引用</h5><p>在表达式中，有两种方法来获取引用：</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td><code>\n</code></td><td>匿名捕获分组的引用。它返回第n个子捕获匹配到的具体的内容(捕获的数目以左括号计数，即不论是否嵌套分组，命名捕获还是匿名捕获，都是按照左括号来计算，第一个左括号捕获的分组就是<code>\1</code>, 第二个分组就是<code>\2</code> …)。</td></tr><tr><td><code>\k&lt;name&gt;</code></td><td>返回具体某个命名捕获分组的内容。</td></tr></tbody></table><p>例如：判断一个字符串数组所有元素是否完全相等</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>];<br><span class="hljs-keyword">let</span> str = arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;,&#x27;</span>); <span class="hljs-comment">// abc,abc,abc</span><br><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/(\w+),\1/</span>; <span class="hljs-comment">// 在这里，\1 就表示了第一个分组获取到的具体内容。</span><br><br><span class="hljs-keyword">let</span> match = reg.<span class="hljs-title function_">test</span>(str);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(match); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>当然我们也可以使用命名捕获：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;item&#x27;</span>, <span class="hljs-string">&#x27;item&#x27;</span>, <span class="hljs-string">&#x27;item&#x27;</span>];<br><span class="hljs-keyword">let</span> str = arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;,&#x27;</span>)+<span class="hljs-string">&#x27;,&#x27;</span>;<span class="hljs-comment">// item,item,item,</span><br><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/(?&lt;element&gt;\w+)(,)\k&lt;element&gt;\2/</span>; <span class="hljs-comment">// 等价于/(?&lt;element&gt;\w+)(,)\1\2/</span><br><br><span class="hljs-keyword">let</span> match = reg.<span class="hljs-title function_">test</span>(str);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(match); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h5 id="相关函数中的引用"><a href="#相关函数中的引用" class="headerlink" title="相关函数中的引用"></a>相关函数中的引用</h5><p>在函数中有两种，一种是特殊字符指代，一种是函数参数。</p><p>例如在<code>string.prototype.replace</code>中，可以使用特殊字符 <code>$n</code> 来指代分组，同样的，数字 <code>n </code>代表分组索引。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 交换位置</span><br><span class="hljs-keyword">let</span> names = <span class="hljs-string">&#x27;john,marry,jerry&#x27;</span>;<br><span class="hljs-keyword">let</span> new_names = names.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(\w+),(\w+),(\w+)/</span>, <span class="hljs-string">&#x27;$2,$3,$1&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(new_names); <br><br><span class="hljs-comment">// marry,jerry,john</span><br></code></pre></td></tr></table></figure><p>也可以在函数参数中使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 交换位置</span><br><span class="hljs-keyword">let</span> names = <span class="hljs-string">&#x27;john,marry,jerry&#x27;</span>;<br><span class="hljs-keyword">let</span> new_names = names.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(\w+),(\w+),(\w+)/</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">content, n1, n2, n3</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;n3&#125;</span> <span class="hljs-subst">$&#123;n2&#125;</span> <span class="hljs-subst">$&#123;n1&#125;</span>`</span>;<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(new_names); <br><span class="hljs-comment">// jerry marry john</span><br></code></pre></td></tr></table></figure><p>具体的 <code>replace</code> 方法介绍在下面。</p><h2 id="分支类型"><a href="#分支类型" class="headerlink" title="分支类型"></a>分支类型</h2><p>当我们在匹配一个字符串时，如果存在其中某部分子串，既可以是A，又可以是B，就可以使用分支元字符。</p><table><thead><tr><th>元字符</th><th>定义</th></tr></thead><tbody><tr><td>`</td><td>`</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> strArr = [<span class="hljs-string">&#x27;year&#x27;</span>,<span class="hljs-string">&#x27;mouth&#x27;</span>,<span class="hljs-string">&#x27;day&#x27;</span>];<br><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/mouth|day/</span>;<span class="hljs-comment">//  匹配mouth或者day</span><br><br>strArr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">str</span> =&gt;</span> &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str, <span class="hljs-string">&quot;: &quot;</span>, reg.<span class="hljs-title function_">test</span>(str));<br>&#125;)<br><br><br><span class="hljs-comment">// year :  false</span><br><span class="hljs-comment">// mouth :  true</span><br><span class="hljs-comment">// day :  true</span><br></code></pre></td></tr></table></figure><p>如果需要匹配这样一个字符串，既可以是A，又可以是B，同时又要满足C的时候，还可以结合分组来使用</p><p>例如匹配 <code>&quot;window98 / window2000 / window10&quot;</code> 这样一个字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> wins = [<span class="hljs-string">&#x27;window98&#x27;</span>,<span class="hljs-string">&#x27;window2000&#x27;</span>, <span class="hljs-string">&#x27;window10&#x27;</span>, <span class="hljs-string">&#x27;window99&#x27;</span>];<br><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/window(98|2000|10)/</span>;<br><br>wins.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">str</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str, <span class="hljs-string">&quot;: &quot;</span>, reg.<span class="hljs-title function_">test</span>(str));<br>&#125;)<br><br><span class="hljs-comment">// window98 :  true</span><br><span class="hljs-comment">// window2000 :  true</span><br><span class="hljs-comment">// window10 :  true</span><br><span class="hljs-comment">// window99 :  false</span><br></code></pre></td></tr></table></figure><h2 id="JS中的正则"><a href="#JS中的正则" class="headerlink" title="JS中的正则"></a>JS中的正则</h2><p>JS中与正则相关的主要有两种对象，<code>String</code> 对象和 <code>RegExp</code> 对象。</p><h3 id="RegExp对象"><a href="#RegExp对象" class="headerlink" title="RegExp对象"></a>RegExp对象</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/5/1731e6dd6df72f7b~tplv-t2oaga2asx-image.image"></p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><h5 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/\d/</span><br></code></pre></td></tr></table></figure><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;ab+c&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>); <span class="hljs-comment">// 使用字符串创建</span><br><span class="hljs-keyword">let</span> reg1 =<span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-regexp">/ab+c/</span>, <span class="hljs-string">&#x27;i&#x27;</span>); <span class="hljs-comment">// 使用字面量创建</span><br></code></pre></td></tr></table></figure><h5 id="工厂函数"><a href="#工厂函数" class="headerlink" title="工厂函数"></a>工厂函数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> reg = <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;ab+c&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>);<span class="hljs-comment">// 使用字符串创建</span><br><span class="hljs-keyword">let</span> reg1 =<span class="hljs-title class_">RegExp</span>(<span class="hljs-regexp">/ab+c/</span>, <span class="hljs-string">&#x27;i&#x27;</span>);<span class="hljs-comment">// 使用字面量创建</span><br></code></pre></td></tr></table></figure><p>注意：在使用RegExp方法创建正则表达式时，如果想要 <code>string</code> 类型的参数中使用元字符时，需要转义，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 想要构建出 /\d+/ 这样的表达式</span><br><span class="hljs-keyword">let</span> reg = <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;\d+&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>);<br><span class="hljs-comment">// 此时创建出来的结果是 /d+/ 而不是目标表达式</span><br><br><span class="hljs-comment">// 正确的写法应该是：</span><br><span class="hljs-comment">// RegExp(&#x27;\\d+&#x27;, &#x27;i&#x27;);</span><br></code></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/5/1731e6e2936db248~tplv-t2oaga2asx-image.image"></p><h4 id="lastIndex"><a href="#lastIndex" class="headerlink" title="lastIndex"></a>lastIndex</h4><p>保存了当前正则实例上次匹配的位置。表示下次匹配从哪里开始。这个属性只有正则表达式使用了表示全局检索的 “<code>g</code>“ 标志时，该属性才会起作用。所以当我们在使用全局匹配时，需要注意当前这个值是否被修改。<strong>MDN</strong>中是这样定义的：</p><blockquote><ul><li>如果 <code>lastIndex</code> 大于字符串的长度，则 <code>regexp.test</code> 和 <code>regexp.exec</code> 将会匹配失败，然后 <code>lastIndex</code> 被设置为 0。</li><li>如果 <code>lastIndex</code> 等于字符串的长度，且该正则表达式匹配空字符串，则该正则表达式匹配从 <code>lastIndex</code> 开始的字符串。（then the regular expression matches input starting at <code>lastIndex</code>.）</li><li>如果 <code>lastIndex</code> 等于字符串的长度，且该正则表达式不匹配空字符串 ，则该正则表达式不匹配字符串，<code>lastIndex</code> 被设置为 0.。</li><li>否则，<code>lastIndex</code> 被设置为紧随最近一次成功匹配的下一个位置。</li></ul></blockquote><p>例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/\d+/g</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">matchNumber</span>(<span class="hljs-params">str</span>)&#123;<br>    <span class="hljs-keyword">return</span> reg.<span class="hljs-title function_">test</span>(str);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">matchNumber</span>(<span class="hljs-string">&#x27;123&#x27;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">matchNumber</span>(<span class="hljs-string">&#x27;456&#x27;</span>)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面的方法，我们期望返回两个<code>true</code>，但实际第一个确实返回<code>true</code>，第二个却返回了 <code>false</code>，这是因为我们的正则是一个全局变量，所以每次调用之后更改了<code>lastIndex</code>， 而每次的匹配都从<code>lastIndex</code>开始，所以第二次匹配，传入<code>456</code>实际会从第四个字符开始匹配。此时第四个字符为空，所以返回 <code>false</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/\d+/g</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">matchNumber</span>(<span class="hljs-params">str</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;reg.lastIndex is: &quot;</span>, reg.<span class="hljs-property">lastIndex</span>);<br>    <span class="hljs-keyword">return</span> reg.<span class="hljs-title function_">test</span>(str);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">matchNumber</span>(<span class="hljs-string">&#x27;123&#x27;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">matchNumber</span>(<span class="hljs-string">&#x27;456&#x27;</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">matchNumber</span>(<span class="hljs-string">&#x27;4&#x27;</span>));<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">reg.lastIndex is:  0</span><br><span class="hljs-comment">true</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">reg.lastIndex is:  3</span><br><span class="hljs-comment">false</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">reg.lastIndex is:  0</span><br><span class="hljs-comment">true</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><h5 id="test"><a href="#test" class="headerlink" title="test"></a>test</h5><p>测试当前字符串是否满足某个模式</p><p>参数：<code>str</code> 要匹配正则表达式的字符串。</p><p>返回：<code>boolean</code>值，表示是否匹配成功</p><p>例如判断当前字符串是否由11位数字组成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/^\d&#123;11&#125;$/</span>;<br><span class="hljs-keyword">let</span> phone_number = <span class="hljs-string">&#x27;13577898320&#x27;</span>;<br><br>reg.<span class="hljs-title function_">test</span>(phone_number); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h5 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h5><p>方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null"><code>null</code></a>。</p><p>参数：<code>str</code> 要匹配正则表达式的字符串。</p><p>返回：一个数组：</p><table><thead><tr><th>对象</th><th>描述</th></tr></thead><tbody><tr><td><code>[0]</code></td><td>匹配的全部字符串</td></tr><tr><td><code>[1], ...[*n* ]</code></td><td>括号中的分组捕获</td></tr><tr><td><code>index</code></td><td>匹配到的字符位于原始字符串的索引值</td></tr><tr><td><code>input</code></td><td>原始字符串</td></tr><tr><td><code>groups</code></td><td>命名捕获对象</td></tr></tbody></table><p>⚠️：在js与正则相关的函数中，调用这个函数，会涉及到正则对象的状态。MDN中是这样解释的：</p><blockquote><p>在设置了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/global"><code>global</code></a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky"><code>sticky</code></a> 标志位的情况下（如 <code>/foo/g</code> or <code>/foo/y</code>），JavaScript <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp"><code>RegExp</code></a> 对象是<strong>有状态</strong>的。他们会将上次成功匹配后的位置记录在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex"><code>lastIndex</code></a> 属性中。使用此特性，<code>exec()</code> 可用来对单个字符串中的多次匹配结果进行逐条的遍历（包括捕获到的匹配），而相比之下， <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match"><code>String.prototype.match()</code></a> 只会返回匹配到的结果。</p></blockquote><p>提取出字符串中所有的数字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;各科成绩如下:数学: 121;语文: 120;英语: 138&#x27;</span><br><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/\d+/g</span>;<br><span class="hljs-keyword">let</span> result = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> ((result = reg.<span class="hljs-title function_">exec</span>(str)) !== <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`-------------第<span class="hljs-subst">$&#123;++i&#125;</span>次循环开始------------------`</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;result is: &quot;</span>, result); <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;reg.lastIndex is: &quot;</span>, reg.<span class="hljs-property">lastIndex</span>); <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`-------------第<span class="hljs-subst">$&#123;++i&#125;</span>次循环结束------------------`</span>)<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">-------------第1次循环开始------------------</span><br><span class="hljs-comment">result is:  [ &#x27;121&#x27;,</span><br><span class="hljs-comment">  index: 11,</span><br><span class="hljs-comment">  input: &#x27;各科成绩如下:数学: 121;语文: 120;英语: 138&#x27;,</span><br><span class="hljs-comment">  groups: undefined ]</span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">reg.lastIndex is:  14</span><br><span class="hljs-comment">-------------第1次循环结束------------------</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">-------------第2次循环开始------------------</span><br><span class="hljs-comment">result is:  [ &#x27;120&#x27;,</span><br><span class="hljs-comment">  index: 19,</span><br><span class="hljs-comment">  input: &#x27;各科成绩如下:数学: 121;语文: 120;英语: 138&#x27;,</span><br><span class="hljs-comment">  groups: undefined ]</span><br><span class="hljs-comment">reg.lastIndex is:  22</span><br><span class="hljs-comment">-------------第2次循环结束------------------</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">-------------第3次循环开始------------------</span><br><span class="hljs-comment">result is:  [ &#x27;138&#x27;,</span><br><span class="hljs-comment">  index: 27,</span><br><span class="hljs-comment">  input: &#x27;各科成绩如下:数学: 121;语文: 120;英语: 138&#x27;,</span><br><span class="hljs-comment">  groups: undefined ]</span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">reg.lastIndex is:  30</span><br><span class="hljs-comment">-------------第3次循环结束------------------</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure><h3 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h3><p>String对象中涉及到正则的主要有4个方法：</p><ul><li><code>search</code></li><li><code>match</code></li><li><code>replace</code></li><li><code>split</code></li></ul><p>而其中，<code>match</code>方法中，正则表达式的 <code>global</code> 的不同值会影响返回结果。</p><h4 id="search"><a href="#search" class="headerlink" title="search"></a>search</h4><p><code>search</code>方法很简单，主要用来查找子串的位置。</p><ul><li>参数：一个正则表达式，必填</li><li>返回：找到的第一个子串在字符串中的索引值，如果没有找到就返回 <code>-1</code> </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;find subString index: subString&#x27;</span>;<br><span class="hljs-keyword">let</span> reg1 = <span class="hljs-regexp">/subString/</span>;<br><span class="hljs-keyword">let</span> reg2 = <span class="hljs-regexp">/substring/</span>;<br><span class="hljs-keyword">let</span> reg3 = <span class="hljs-regexp">/subString/g</span>;<br><br>str.<span class="hljs-title function_">search</span>(reg1);<span class="hljs-comment">// 5</span><br>str.<span class="hljs-title function_">search</span>(reg1);<span class="hljs-comment">// -1</span><br>str.<span class="hljs-title function_">search</span>(reg1);<span class="hljs-comment">// 5 此时有无global都不影响结果</span><br></code></pre></td></tr></table></figure><h4 id="match"><a href="#match" class="headerlink" title="match"></a>match</h4><p><code>match </code>方法中，主要用来提取字符串中满足条件的子串。</p><ul><li>参数：正则表达式，，必填。这个正则表达式的 <code>global</code> 标志的值会影响返回结果：<ul><li><code>global == true</code> ：返回一个数组，包含了整个字符串中所有满足条件的子串。 </li><li><code>global == false</code>： 返回<ul><li>数组<code>arr</code> ：<ul><li><code>arr[0]</code> 是当前正则匹配到的第一个子串的值</li><li><code>arr[1] - arr[n]</code> ：分别是当前分组中捕获到的内容，有多少个分组就有多少项。且按照分组的顺序存储</li></ul></li><li><code>index</code> ：当前匹配到的子串在整个字符串中的索引值</li><li><code>input</code> ：源字符串</li><li><code>groups</code>：对象，包含了所有命名捕获组匹配到的内容 ，如果没有定义命名捕获组则为<code>undefined</code></li></ul></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;find subString index: subString&#x27;</span>;<br><span class="hljs-keyword">let</span> reg1 = <span class="hljs-regexp">/subString/</span>;<br><span class="hljs-keyword">let</span> reg2 = <span class="hljs-regexp">/substring/</span>;<br><span class="hljs-keyword">let</span> reg3 = <span class="hljs-regexp">/subString/g</span>;<br><br>str.<span class="hljs-title function_">match</span>(reg1);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">[</span><br><span class="hljs-comment">  &#x27;subString&#x27;,</span><br><span class="hljs-comment">  index: 5,</span><br><span class="hljs-comment">  input: &#x27;find subString index: subString&#x27;,</span><br><span class="hljs-comment">  groups: undefined</span><br><span class="hljs-comment">]</span><br><span class="hljs-comment">**/</span><br>str.<span class="hljs-title function_">match</span>(reg2);<span class="hljs-comment">// null</span><br>str.<span class="hljs-title function_">match</span>(reg3);<span class="hljs-comment">// [ &#x27;subString&#x27;, &#x27;subString&#x27; ]</span><br></code></pre></td></tr></table></figure><h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><p><code>replace</code>方法，就是用指定的值来替换源字符串中一些特定的子串。</p><ul><li><p>参数：</p><ul><li><p><code>pattern</code>： 模式，指定被替换的子串类型。可以是一个 <code>String</code>，也可以是一个 <code>RegExp</code> </p><ul><li> <code>String</code> </li><li> <code>RegExp</code>：当为<code>RegExp</code>对象时，如果 <code>global</code>标志为<code>false</code>，则只会替换匹配到的第一个子串。</li></ul></li><li><p><code>replacement</code>： 替换值，用于替换指定的子串。可以是一个 <code>String</code>，也可以是一个<code>Function</code></p><ul><li><p><code>String</code>：如果pattern是一个<code>RegExp</code>，还可以使用一些特殊字符来插入命令：</p><ul><li><table><thead><tr><th><strong><code>?</code></strong></th><th><strong>插入一个 “$”</strong></th></tr></thead><tbody><tr><td><strong><code>$&amp;</code></strong></td><td><strong>插入匹配的子串</strong></td></tr><tr><td><strong>$`</strong></td><td><strong>插入当前匹配的子串左边的内容</strong></td></tr><tr><td><strong><code>$&#39;</code></strong></td><td><strong>插入当前匹配的子串右边的内容</strong></td></tr><tr><td><strong><code>$n</code></strong></td><td><strong>插入指定的捕获组内容</strong></td></tr></tbody></table></li></ul></li><li><p><code>Function</code>：替换函数，可以指定返回的新字符串。只有第一个参数为正则时才生效。</p><ul><li><blockquote><p>你可以指定一个函数作为第二个参数。在这种情况下，当匹配执行后，该函数就会执行。 函数的返回值作为替换字符串。 (注意：上面提到的特殊替换参数在这里不能被使用。) 另外要注意的是，如果第一个参数是正则表达式，<strong>并且其为全局匹配模式</strong>，那么这个方法将被多次调用，每次匹配都会被调用。（源自MDN）</p></blockquote></li><li><p>参数：</p><ul><li><code>match</code>：每次匹配到的子串。</li><li><code>p1,p2, ...</code>：假如<code>replace</code> 的 <code>pattern</code> 参数是一个 <code>RegExp</code>，则这里就是分别指代了各个分组匹配到的内容。</li><li><code>offset</code>：匹配到的子字符串在原字符串中的偏移量。</li><li><code>string</code>：源字符串。</li><li><code>NamedCaptureGroup</code>： 命名捕获组匹配的对象</li></ul></li><li><p>返回：替换后的新字符串。</p></li></ul></li></ul></li></ul></li><li><p>返回：替换后的新字符串。</p></li></ul><p>有四种组合方式：</p><h5 id="组合一：string-string"><a href="#组合一：string-string" class="headerlink" title="组合一：string + string"></a>组合一：string + string</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;把名字替换成新的: john&#x27;</span>;<br><span class="hljs-keyword">let</span> new_str = str.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;john&#x27;</span>, <span class="hljs-string">&#x27;jerry&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;new_str is: &quot;</span>, new_str);<br><span class="hljs-comment">// new_str is: 把名字替换成新的：jerry</span><br></code></pre></td></tr></table></figure><h5 id="组合二：regexp-string"><a href="#组合二：regexp-string" class="headerlink" title="组合二：regexp + string"></a>组合二：regexp + string</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;把名字替换成新的：john&#x27;</span>;<br><span class="hljs-keyword">let</span> new_str = str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/john/</span>, <span class="hljs-string">&#x27;jerry&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;new_str is: &quot;</span>, new_str);<br><span class="hljs-comment">// new_str is: 把名字替换成新的：jerry</span><br></code></pre></td></tr></table></figure><h5 id="组合三：regexp-特殊符号"><a href="#组合三：regexp-特殊符号" class="headerlink" title="组合三：regexp + 特殊符号"></a>组合三：regexp + 特殊符号</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;交换名字：john,jerry&#x27;</span><br><span class="hljs-keyword">let</span> new_str = str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(\w+),(\w+)/</span>, <span class="hljs-string">&#x27;$2,$1&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;new_str is: &quot;</span>, new_str);<br><span class="hljs-comment">// new_str is: 交换名字：jerry,john</span><br></code></pre></td></tr></table></figure><h5 id="组合四：regexp-function"><a href="#组合四：regexp-function" class="headerlink" title="组合四：regexp + function"></a>组合四：regexp + function</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;交换名字：john,jerry&#x27;</span><br><span class="hljs-keyword">let</span> new_str = str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(?&lt;person1&gt;\w+),(?&lt;person2&gt;\w+)/</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">match, n1, n2, offset, input, groups</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;match:&quot;</span>,match);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;n1:&quot;</span>,n1);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;n2:&quot;</span>,n2);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;offset:&quot;</span>,offset);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;input:&quot;</span>,input);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;groups:&quot;</span>,groups);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;n2&#125;</span> &amp;&amp; <span class="hljs-subst">$&#123;n1&#125;</span>`</span>;<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;new_str is: &quot;</span>, new_str);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    match: john,jerry</span><br><span class="hljs-comment">    n1: john</span><br><span class="hljs-comment">    n2: jerry</span><br><span class="hljs-comment">    offset: 5</span><br><span class="hljs-comment">    input: 交换名字：john,jerry</span><br><span class="hljs-comment">    groups: &#123; person1: &#x27;john&#x27;, person2: &#x27;jerry&#x27; &#125;</span><br><span class="hljs-comment">    new_str is:  交换名字：jerry &amp;&amp; john</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="split"><a href="#split" class="headerlink" title="split"></a>split</h4><p><code>split</code>方法主要用于分割字符串。</p><ul><li>参数：<ul><li><code>separator</code> 分隔符，必填。可以是字符串或者正则表达式</li><li><code>limit</code> 限制，可选。限定返回的分割片段数量。</li></ul></li><li>返回：数组<code>arr</code>，包含了被分割后的片段。</li></ul><h5 id="limit-限制"><a href="#limit-限制" class="headerlink" title="limit 限制"></a><code>limit</code> 限制</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;123,44a,234a,1&#x27;</span>;<br><span class="hljs-keyword">let</span> all = str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>);<br><span class="hljs-keyword">let</span> part = str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>, <span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;all is: &quot;</span>, all);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;part is: &quot;</span>, part);<br><span class="hljs-comment">// all is:  [ &#x27;123&#x27;, &#x27;44a&#x27;, &#x27;234a&#x27;, &#x27;1&#x27; ]</span><br><span class="hljs-comment">// part is:  [ &#x27;123&#x27;, &#x27;44a&#x27; ]</span><br></code></pre></td></tr></table></figure><h5 id="使用正则分割"><a href="#使用正则分割" class="headerlink" title="使用正则分割"></a>使用正则分割</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;year4mouth12days&#x27;</span>;<br><span class="hljs-keyword">let</span> label = str.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/\d+/</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;label is: &quot;</span>, label);<br><span class="hljs-comment">// label is:  [ &#x27;year&#x27;, &#x27;mouth&#x27;, &#x27;days&#x27; ] </span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/6844903487155732494">JS正则表达式完整教程（略长）</a></p><p><a href="https://wizardforcel.gitbooks.io/py-re-guide/content/">Python 正则表达式操作指南</a></p><p><a href="https://www.bookstack.cn/read/deerchao-regex/README.md">正则表达式30分钟入门教程（正则表达式入门教程）</a></p><p><a href="https://www.cnblogs.com/onepixel/articles/7717789.html">正则表达式零宽断言详解</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">MDN 正则表达式</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp">MDN RegExp</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String">MDN String</a></p>]]></content>
    
    
    <categories>
      
      <category>Web前端</category>
      
      <category>javascript</category>
      
      <category>正则表达式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>&lt;span class=&quot;label label-primary&quot;&gt;正则表达式&lt;/span&gt;</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈计算机字体</title>
    <link href="/2023/03/03/%E6%B5%85%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%97%E4%BD%93/"/>
    <url>/2023/03/03/%E6%B5%85%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%97%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机字体简介"><a href="#计算机字体简介" class="headerlink" title="计算机字体简介"></a>计算机字体简介</h1><h2 id="字体分类"><a href="#字体分类" class="headerlink" title="字体分类"></a>字体分类</h2><h2 id="点阵字体"><a href="#点阵字体" class="headerlink" title="点阵字体"></a>点阵字体</h2><p>点阵字体是指每一个字符都按照16×16或24×24的尺寸设置，在设定好的尺寸内，通过每个像素点的虚实来表示字符的轮廓。点阵字体也叫<strong>位图字体</strong>，其中每个字形都以一组二维像素信息表示。</p><p>因为是预先设计好然后直接输出，当字符进行动态的放大缩小时，是无法清晰的显示字形轮廓，所以点阵字体只在预设好的字号下能清晰显示，有时候不同的字号甚至可能显示成完全不同的字体，例如（图片出处：<a href="https://xuchen.wang/archives/fonts.html">对计算机字体渲染的一些研究</a>）：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b543e25616774f4395ffe52440d961eb~tplv-k3u1fbpfcp-zoom-1.image"><br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95709cb05db540918c68bc2393d1c834~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="矢量字体"><a href="#矢量字体" class="headerlink" title="矢量字体"></a>矢量字体</h2><p>矢量字体又叫做轮廓字体(Outline Fonts)，是利用贝塞尔曲线来描述字形轮廓，当使用该字体时，计算机根据曲线进行实时计算渲染，从而保证了当字体进行任意大小缩放时，字符都能清晰显示。</p><h2 id="渲染技术"><a href="#渲染技术" class="headerlink" title="渲染技术"></a>渲染技术</h2><p>无论是点阵字体还是矢量字体，在计算机中，其本质都是栅格化（Rasterization）图像。对于计算机而言，其最小操作单元就是一个个像素栅格。如何使用一定数量的像素栅格去准确描绘理想的字体形状，就是需要解决的问题。</p><h2 id="黑白渲染（Black-and-white-rendering）"><a href="#黑白渲染（Black-and-white-rendering）" class="headerlink" title="黑白渲染（Black and white rendering）"></a>黑白渲染（Black and white rendering）</h2><p>黑白渲染又叫做二值渲染（bi-level rendering）。黑白渲染是最早人们使用的渲染技术，这种渲染方式只使用黑白两种颜色来表达文字的形状。目前打印机就仍在使用这种方法，由于打印机的高输出分辨率，打印的结果能很好地再现原图。但是由于屏幕的分辨率较低，在这种渲染方式下，放大字体可能就会看到一些锯齿。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/132cb451161343ff9e499d6127457c04~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="灰度渲染（Grayscale-rendering）"><a href="#灰度渲染（Grayscale-rendering）" class="headerlink" title="灰度渲染（Grayscale rendering）"></a>灰度渲染（Grayscale rendering）</h2><p>灰度渲染实际上是计算机图形学中的一种<strong>反锯齿（Anti-Aliasing）</strong>技术，通过在锯齿边缘增加一些灰阶像素，从而平滑字体轮廓。它的灰度值取决于理想的字型在此像素所覆盖的面积比例。该技术的原理与照片重新采样（resampled）到一个较低分辨率时的原理是相同的，人眼在识别图像时，由于图像的边界不明显，大脑会将其与周围的像素理解为一个整体。 因此我们的眼睛和大脑在理解灰色像素所包含的信息时，会将它转换为字型的轮廓，这就让我们可以获得与原始设计极为接近的渲染效果。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b676f63f1e254af4bddb0f271e4da1c2~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="亚像素渲染（Subpixel-rendering）"><a href="#亚像素渲染（Subpixel-rendering）" class="headerlink" title="亚像素渲染（Subpixel rendering）"></a>亚像素渲染（Subpixel rendering）</h2><p>亚像素渲染实际上是灰度渲染的进阶版。这种技术的出现主要得益于硬件的提升。传统CRT显示器最小控制单元是像素，是由相邻的红、绿、蓝荧光粉单元各一个为一组组成。LCD液晶显示屏也是由红、绿、蓝三个子（亚）像素构成的，它们共同决定了这一像素的颜色和亮度，但LCD能够做到单独控制每一个子像素。因为这些子像素非常小，以至于人眼无法察觉到他们是一个个独立的颜色点。与单纯的灰度渲染相比，水平方向的分辨率翻了三倍。</p><p>将亚像素渲染与灰度渲染对比可以发现，视觉上来说亚像素的边缘会更平滑：</p><div style="text-align: center"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddfb377e5b2940b8a59af7e3cc7b9a94~tplv-k3u1fbpfcp-zoom-1.image" alt="20200804180415" style="zoom:50%;" /></div><p>我们将这个像素细化到亚像素并转为灰度模式可以会有更直观的感受，原有的一个灰阶像素变成了三个灰阶亚像素，整个边缘进行了更加平滑的过渡：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a4fb6f747ee4b78b983e68bfa026d46~tplv-k3u1fbpfcp-zoom-1.image"></p><h1 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h1><p>文字，是一个可以被人类识别的图形化符号，本质是图形，在计算机我们称之为图元。但是文字是人类文明的产物，计算机并不认识。但是对于计算机而言，它只会认识由0、1组成的二进制值，所以为了让计算机识别一段文字，需要让文字与二进制值之间进行相互转化，这个过程就是编码与解码的过程。</p><p>在计算机中存在着多种编码格式，包括ASCII编码、GB类的中文编码以及Unicode编码等，关于中文字符编码，可以查看<a href="https://zhuanlan.zhihu.com/p/46216008">这篇文章</a>，本文就不做介绍，只是简单介绍一下ASCII编码和Unicode编码。</p><h2 id="ASCII编码"><a href="#ASCII编码" class="headerlink" title="ASCII编码"></a>ASCII编码</h2><p>ASCII码是是上个世纪60年代美国信息交换标准代码是由美国国家标准学会(American National Standard Institute , ANSI )制定的，是一种标准的<strong>单字节</strong>字符<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A0%81">编码</a>方案，用于基于<a href="https://baike.baidu.com/item/%E6%96%87%E6%9C%AC">文本</a>的数据，对英语字符与二进制位之间的关系，做了统一规定。</p><p>ASCII规定，用8位二进制（1byte，8bit）来存储字符和特殊符号，总共可以表示256个字符。（因为英文字符总共才26个，加上特殊字符，8bit绰绰有余）。</p><p>早期只针对英文编码，是使用7 位二进制数（剩下的1位二进制为0）来表示所有的大写和小写字母，数字0 到9、标点符号，以及在美式英语中使用的特殊控制字符。此时7位的叫做<a href="http://ascii.911cha.com/">标准ASCII码</a>也叫<strong>基础ASCII码</strong>。</p><p>后来当它被国际标准化组织（International Organization for Standardization, ISO）定为国际标准后，仅仅128个符号编码就不够用了，因为在其他的拉丁文字字母中还可能存在注音符号，这时就无法用基础 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。此时把8位二进制编码的字符码称为**<a href="https://baike.baidu.com/item/%E6%89%A9%E5%B1%95ASCII">扩展ASCII</a>码**。</p><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>我们知道ASCII码最多支持256位字符，用来表示其他语言是完全不够的，亚洲国家的文字中，汉字就多达10万左右。因此出现了多种编码格式，例如GB类的中文编码。当通过多种编码方案解决了多语言的字符显示问题之后，又出现了新的问题：乱码。</p><p>我们都知道计算机内部只存储二进制数据，当我们进行通信时，发送者需要将文字编码成一串二进制比特流进行传输通信，而接收者需要使用同一套编码规则进行解码，才能获取到正确的信息。但是如果通信双方使用不同的编码规则，例如发送者使用单字节编码（规定每8位为一个字符码），而接收者使用双字节解码（规定每16位为一个字符码），或者接收者同样使用单字节编码，但是其对应的不是同一个字符，就会出现乱码。</p><p>于是Unicode就出现了。Unicode把所有语言都统一到一套编码里，每个字符在Unicode中只有唯一的字符码。</p><h2 id="Unicode标准"><a href="#Unicode标准" class="headerlink" title="Unicode标准"></a>Unicode标准</h2><p>Unicode标准定义 <strong>一个字符代表一个code，不存在二义性</strong>，例如<code>U+0041</code>总是代表<code>&#39;A&#39;</code>，而且这套标准也会随着需求不断的拓展。</p><p>实质上Unicode只是一个字符集，里面是定义了所有字符和二进制code的对应关系，但是并没有真正实现字符集的编码。而UTF-8，UTF-16，UTF-32就是Unicode的不同实现。</p><h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h2><p>UTF-8 是在互联网上使用最广的一种 Unicode 的实现方式之一。UTF-8 最大的一个特点，就是它是一种变长的编码方式，根据不同的Unicode字符，使用不同数量的字节编码。因为如果采用单字节编码方式，是不够的，而如果采用多字节编码，那么对于小序的字符来说，会在前面填充非常多的0，非常浪费空间。所以用一种可变的方式，既可以有效的利用空间，又可以包含更多数量的字符。</p><blockquote><p>UTF-8 的编码规则很简单，只有二条：</p><p>1）对于单字节的符号，字节的第一位设为<code>0</code>，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</p><p>2）对于<code>n</code>字节的符号（<code>n &gt; 1</code>），第一个字节的前<code>n</code>位都设为<code>1</code>，第<code>n + 1</code>位设为<code>0</code>，后面字节的前两位一律设为<code>10</code>。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</p><p>下表总结了编码规则，字母<code>x</code>表示可用编码的位。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">Unicode符号范围     |        UTF-8编码方式<br><span class="hljs-section">(十六进制)          |         （二进制）</span><br><span class="hljs-section">----------------------+---------------------------------------------</span><br>0000 0000-0000 007F | 0xxxxxxx<br>0000 0080-0000 07FF | 110xxxxx 10xxxxxx<br>0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx<br>0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx<br></code></pre></td></tr></table></figure></blockquote><h2 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h2><p>Unicode编码中，最常用的字符其实是<code>0-65535</code>，因此针对这点产生了UTF-16方案。</p><p>UTF-16编码以16位无符号整数为单位，将0–65535范围内的字符编码成2个字节，超过这个的用4个字节编码。UTF16编码是Unicode最直接的实现方式，通常我们在windows上新建文本文件后保存为Unicode编码，其实就是保存为UTF16编码。</p><h2 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h2><p>UTF-32是Unicode的一种实现方式. UTF32编码使用固定的4个字节来存储。 因此,非常浪费空间,不利于网络传输,所以使用不普遍。</p><h1 id="字体文件"><a href="#字体文件" class="headerlink" title="字体文件"></a>字体文件</h1><h2 id="常见的字体文件格式"><a href="#常见的字体文件格式" class="headerlink" title="常见的字体文件格式"></a>常见的字体文件格式</h2><p>我们知道，字体分为点阵字体和矢量字体。</p><p>对于纯点阵字体，其常见的字体格式包括： bdf，pcf，fnt，hbf 。</p><p>对于矢量字体，其常见的格式包括<strong>Type1</strong>，<strong>TrueType（ttf）</strong>和<strong>OpenType（otf / ttf）</strong>。</p><p>简单介绍一下矢量字体中各个格式之间的的区别：</p><ul><li><p><strong>Type1</strong>：全称<strong>PostScript Type1</strong>，是1985年由Adobe公司提出的一套矢量字体标准，使用贝塞尔曲线描述字形，称为<strong>PostScript曲线</strong>。是非开放字体，使用需要收费。</p></li><li><p><strong>TrueType</strong>：TrueType是1991年由苹果（Apple）公司与 微软（Microsoft）公司联合提出另一套矢量字标准。虽然与Type1都是使用贝塞尔曲线描述字体轮廓，但是<strong>Type1</strong>使用三次贝塞尔曲线来描述字形，而TrueType使用的是二次贝塞尔曲线（<strong>TrueType曲线</strong>）。<strong>TrueType 曲线</strong>可接受典型的 hinting，可告知栅格化引擎在栅格化之前应该如何把轮廓扭曲，这样可精确控制字体的抗锯齿结果。</p></li><li><p><strong>Opentype</strong>：是1995年由微软（Microsoft）和 Adobe公司开发的另外一种字体格式 ，基于TrueType扩展，内部兼容了<strong>TrueType 曲线</strong>和 <strong>PostScript 曲线</strong>。并且真正支持 <strong>Unicode</strong>的字体，最多可以支持 65535 个码位。其后缀名可以是ttf或者otf。仅包含<strong>TrueType 曲线</strong>，其后缀名一般是<strong>ttf</strong>，包含有 <strong>PostScript 曲线</strong>的，后缀名则是<strong>otf</strong>。</p></li></ul><p>而目前常见的用于web的字体格式，除了主流的otf 和 ttf之外，还包括了<strong>WOFF</strong> 和 <strong>SVG</strong>。</p><blockquote><ul><li><p><strong>WOFF</strong>：WOFF (Web Open Font Format) 本质上是 metadata + 基于 SFNT 的字体（如 TTF、OTF 或其他开放字体格式）。该格式完全是为了 Web 而创建，由 Mozilla 基金会、微软和 Opera 软件公司合作推出。 WOFF 字体均经过 WOFF 的编码工具压缩，文件大小一般比 TTF 小 40%，加载速度更快，可以更好的嵌入网页中。metadata 允许在字体文件中包含许可数据，以解决版权问题。这是万维网联盟提（qing）倡（ding）的，所以毫无疑问的是字体格式的未来。<strong>目前主流的浏览器的新版本几乎都支持 WOFF。</strong></p></li><li><p><strong>SVG</strong>：SVG (Scalable Vector Graphics font) 字体格式使用 SVG 的字体元素定义。这些字体包含作为标准 SVG 元素和属性的字形轮廓，就像它们是 SVG 映像中的单个矢量对象一样。SVG 字体最大的缺点是缺少字体提示（font-hinting）。字体提示是渲染小字体时为了质量和清晰度额外嵌入的信息。同时，SVG 对文本（body text）支持并不是特别好。因为 SVG 的文本选择（text selection）目前在 Safari、Safari Mobile 和 Chrome 的一些版本上完全崩坏，所以你不能选择单个字符、单词或任何自定义选项，你只能选择整行或段落文本。</p></li></ul></blockquote><h2 id="TrueType-字体"><a href="#TrueType-字体" class="headerlink" title="TrueType 字体"></a>TrueType 字体</h2><p>目前最常使用的主流字体格式还是<strong>ttf</strong>。所以简单了解一下<strong>TrueType</strong> 字体文件结构。</p><p><strong>TrueType</strong> 字体是一个矢量字体格式。对于矢量字体来说，要准确绘制一个字体，其文件中需要存储其图元轮廓的定义，字符代码与图元的映射等信息。所以在<strong>TrueType</strong>字体文件中，存储了多张表格，不同的表格包含了与字体相关的不同信息，下表包含了部分表格说明：</p><table><thead><tr><th>表名</th><th>说明</th><th>说明</th></tr></thead><tbody><tr><td>head</td><td>字体头</td><td>字体的全局信息</td></tr><tr><td>cmap</td><td>字符代码到图元的映射</td><td>把字符代码映射为图元索引</td></tr><tr><td>glyf</td><td>图元数据</td><td>图元轮廓定义以及网格调整指令</td></tr><tr><td>maxp</td><td>最大需求表</td><td>字体中所需内存分配情况的汇总数据</td></tr><tr><td>mmtx</td><td>水平规格</td><td>图元水平规格</td></tr><tr><td>loca</td><td>位置表索引</td><td>把元索引转换为图元的位置</td></tr><tr><td>name</td><td>命名表</td><td>版权说明、字体名、字体族名、风格名等等</td></tr><tr><td>hmtx</td><td>水平布局</td><td>字体水平布局星系：上高、下高、行间距、最大前进宽度、最小左支撑、最小右支撑</td></tr><tr><td>kerm</td><td>字距调整表</td><td>字距调整对的数组</td></tr><tr><td>post</td><td>PostScript信息</td><td>所有图元的PostScript  FontInfo目录项和PostScript名</td></tr><tr><td>PCLT</td><td>PCL  5数据</td><td>HP  PCL  5Printer  Language  的字体信息：字体数、宽度、x高度、风格、记号集等等</td></tr><tr><td>hhea</td><td>mac下渲染数据</td><td>水平布局排列字符的字体所需的信息</td></tr><tr><td>OS/2</td><td>OS/2和Windows特有的规格</td><td>TrueType字体所需的规格集</td></tr></tbody></table><p>其中对于文本的排版布局来说，有几个参数比较重要：</p><ul><li><p>head表中的<code>unitsPerEm</code>字段代表字形中UPM值</p></li><li><p>hhea表中的<code>ascent</code> 、<code>descent</code> 和<code>line gap</code> 字段常用于Mac OS下的字体渲染。</p></li><li><p>OS/2表中</p><ul><li>用于window字体渲染<ul><li><code>usWinAscent</code></li><li><code>usWinDescent</code></li></ul></li><li>用于印刷<ul><li><code>sTypoAscender</code></li><li><code>sTypoDescender</code></li><li><code>sTypoLineGap</code></li><li><code>sCapHeight</code></li><li><code>sxHeight</code></li></ul></li></ul></li></ul><p>这些参数主要用于排版布局的计算。对于前端而言，在CSS行框计算中，这是最根本的依据。但是这些参数究竟代表了什么含义呢？在这里做一个简单的介绍。</p><h2 id="em-square-UPM"><a href="#em-square-UPM" class="headerlink" title="em square (UPM)"></a>em square (UPM)</h2><p>em框，也叫做upm（units per em）。在字体设计中，一个字符图形需要设计到在一个框内，这个框我们称之为em框。em框的概念最早来自印刷。</p><blockquote><p>在传统的金属字模中，每个字符被放置在一个统一大小的金属块中，每个字符的高度是统一的，这样每个字模可以整齐地放进行和块中（如下）。</p><p>字模的高度被称为<code>em</code>，起源于大写的字符“M”的宽度；这个字母的比例被做成了方形（因此有了“EM Square”的称呼）。</p></blockquote><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d25914fc3d464f618a3c0f74c731f876~tplv-k3u1fbpfcp-zoom-1.image"></p><p>em size是根据字模计算出的点值。是字符占用空间的数字化定义总量，通常指代高度，表示当前字体的字符在设计时的单位量。在OpenType字体中，UPM或em大小通常是1000单位。在TrueType字体中，UPM约定是2的幂，通常是1024或2048。而我们设置字号大小，实际上是在设置em框，从而实现缩放字符的效果。</p><p>下图的字体是在1000单位的em框中设计，其中这个 <code>H</code> 字符在设计时总高度为700单位，占整个框高度的 7/10，那么当给这个字符设置10px时，其实是规定了em的大小为10px，那么此时 <code>H</code> 的实际高度就是7px：<br>$$<br>7 / 10 * 10  = 7<br>$$</p><div style="text-align: center;margin-top: 50px;">  <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92d57fb265eb49d4b34fa0b5a4b160a4~tplv-k3u1fbpfcp-zoom-1.image" alt="20200804180415" style="zoom:50%;" /></div><h2 id="font-Metrics"><a href="#font-Metrics" class="headerlink" title="font Metrics"></a>font Metrics</h2><p>简单来说，<strong>字体度量（Font Metrics）</strong>就是描述一个字体的一系列参数，用于计算机解析渲染字体。在设计一套字体时，可以对这些参数进行自定义设置从而实现自定义字体设计。这些参数包含了一个字体中各个字形的轮廓参数，字符的大小，样式设置，以及该字体中字符与字符间的排布等，可以通过<a href="https://www.fontshop.com/glossary">glossary</a> 来了解相关的设计参数信息与含义。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c8976e9e2e1404ea228b9790156f9b9~tplv-k3u1fbpfcp-zoom-1.image"></p><p>而这一些系列的参数中，重点介绍一下与字符排布相关的参数（这些参数都是以英文字符为参考对象）：</p><table><thead><tr><th>参数</th><th>定义</th></tr></thead><tbody><tr><td>baseline</td><td>是文字绘制时所参照的基准线，所有的文字以此为基准位置进行设计。</td></tr><tr><td>x-height</td><td>小写字母的高度，以x为例</td></tr><tr><td>capital height</td><td>基线到大写字母顶部到高度</td></tr><tr><td>ascent</td><td>小写字母中延伸到 x-height以上的部分</td></tr><tr><td>descent</td><td>小写字母中延伸到 x-height以下 的部分</td></tr><tr><td>leading / line gap</td><td>从基线到基线的文本行之间的垂直间隔</td></tr><tr><td>midline</td><td>位于小写字母的主体之上，基线和中线之间的距离是x-height</td></tr><tr><td>spacing</td><td>字间距</td></tr></tbody></table><p>通过一张图来了解这些参数（图源网络）：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1133390d7ac403ab6fec921cd1752a7~tplv-k3u1fbpfcp-zoom-1.image"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.thetype.com/2016/09/10968/">参数化设计与字体战争：从 OpenType 1.8 说起</a></p><p><a href="https://pcedu.pconline.com.cn/teach/xt/1205/2783057_all.html">一笔一划间蕴藏的学问 浅谈计算机字体</a></p><p><a href="https://xuchen.wang/archives/fonts.html">对计算机字体渲染的一些研究</a></p><p><a href="https://www.smashingmagazine.com/2012/04/a-closer-look-at-font-rendering/">A Closer Look At Font Rendering</a></p><p><a href="https://www.joelonsoftware.com/2007/06/12/font-smoothing-anti-aliasing-and-sub-pixel-rendering/">Font smoothing, anti-aliasing, and sub-pixel rendering</a><br><a href="https://www.html5rocks.com/zh/tutorials/internals/antialiasing-101/">Antialiasing 101</a></p><p><a href="http://cenalulu.github.io/linux/character-encoding/">十分钟搞清字符集和字符编码</a></p><p><a href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/">The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets</a></p><p><a href="https://baike.baidu.com/item/ASCII">百度百科：ASCII</a></p><p><a href="https://baike.baidu.com/item/Unicode">百度百科：Unicode</a></p><p><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">字符编码笔记：ASCII，Unicode 和 UTF-8</a><br><a href="https://dailc.github.io/2017/05/17/severalCommonlyCharEncoding.html">【字符编码系列】常用的几种字符编码(GBK，UTF-8，UTF-16)</a><br><a href="https://developer.apple.com/fonts/TrueType-Reference-Manual/">TrueType</a><br><a href="https://zhuanlan.zhihu.com/p/28179203">Web 字体简介: TTF, OTF, WOFF, EOT &amp; SVG</a><br><a href="http://www.shushilvshe.com/data/font-build.html">字体生成小记</a><br><a href="https://www.cnblogs.com/sjhrun2001/archive/2010/01/19/1651274.html">ttf文件结构解析</a></p><p><a href="https://photopea.github.io/Typr.js/">Typr.js</a></p>]]></content>
    
    
    <categories>
      
      <category>字体渲染</category>
      
    </categories>
    
    
    <tags>
      
      <tag>&lt;span class=&quot;label label-primary&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;label label-primary&quot;&gt;字体渲染&lt;/span&gt; &lt;span class=&quot;label label-primary&quot;&gt;ttf&lt;/span&gt; &lt;span class=&quot;label label-primary&quot;&gt;字符编码&lt;/span&gt;</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器同源策略</title>
    <link href="/2023/02/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"/>
    <url>/2023/02/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><h2 id="什么是同源策略"><a href="#什么是同源策略" class="headerlink" title="什么是同源策略"></a>什么是同源策略</h2><p>同源策略是一个重要的<strong>安全策略</strong>，它用于<strong>限制</strong>一个源（origin）的文档或者它加载的脚本如何能与另一个源的资源进行<strong>交互</strong>。非同源下的文档和脚本（JS），不能跨域获取资源。</p><p>其中<strong>同源</strong>是指：</p><ul><li>协议相同</li><li>域名相同</li><li>端口相同</li></ul><h2 id="为什么会存在同源策略"><a href="#为什么会存在同源策略" class="headerlink" title="为什么会存在同源策略"></a>为什么会存在同源策略</h2><p>同源策略是<strong>浏览器</strong>为了<strong>保护用户信息安全</strong>所执行的策略。1995年由 Netscape 公司引入的，目前所有的<strong>浏览器</strong>都执行这个策略。</p><p>因为它的主要目的是为了保证用户信息安全，所以只要涉及到用户信息的获取途径都会被<strong>限制</strong>，这些信息获取途径包括：</p><ul><li>通过操作<strong>其他网站</strong>或者 <strong>iframe</strong>的 <code>dom</code> 来获取用户的表单数据</li><li>通过获取<code>cookie</code>，<code>localstorge</code>，<code>sessionstorage</code>，<code>indexDB</code>等缓存信息，来获取用户信息</li><li>通过发送 <code>ajax / fetch</code> 请求，来获取后端的用户信息（提交表单不受跨域限制）</li></ul><p>如果不对这些途径加以限制，就可能被恶意网站盗取用户信息。那么恶意是如何通过这几种途径获取信息的呢？举几个案例（来源于<a href="https://juejin.im/post/6844903816060469262">彻底理解浏览器的跨域</a>）：</p><blockquote><p>案例：<br>一、cookie获取发送请求<br>A 网站是一家银行，用户登录以后，A 网站在用户的机器上设置了一个 Cookie，包含了一些隐私信息（比如存款总额）。用户离开 A 网站以后，又去访问 B 网站，如果没有同源限制，B 网站可以读取 A 网站的 Cookie，那么隐私信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。<br>例如</p><ol><li>用户登录了自己的银行页面 <a href="http://mybank.com/">http://mybank.com</a>，<a href="https://www.notion.so/b4dda8a6ca0b4a308ed8dd5d5f77861a">mybank.com</a> 向用户的cookie中添加用户标识。</li><li>用户浏览了恶意页面 <a href="http://evil.com/">evil.com</a>。执行了页面中的恶意AJAX请求代码。</li><li>向<a href="http://mybank.com发起ajax/">http://mybank.com发起AJAX</a> HTTP请求，请求会默认把<a href="http://mybank.com对应cookie也同时发送过去./">http://mybank.com对应cookie也同时发送过去。</a></li><li>银行页面从发送的cookie中提取用户标识，验证用户无误，response中返回请求数据。此时数据就泄露了。</li><li>而且由于Ajax在后台执行，用户无法感知这一过程。</li></ol><p>二、dom操作</p><ol><li>做一个假网站，里面用iframe嵌套一个银行网站 <a href="http://mybank.com/">mybank.com</a>。</li><li>把iframe宽高啥的调整到页面全部，这样用户进来除了域名，别的部分和银行的网站没有任何差别。</li><li>这时如果用户输入账号密码，我们的主网站可以跨域访问到<a href="http://mybank.com的dom节点,就可以拿到用户的输入了,那么就完成了一次攻击/">http://mybank.com的dom节点，就可以拿到用户的输入了，那么就完成了一次攻击</a></li></ol></blockquote><p>所以针对这三点，浏览器做了同源限制：</p><ul><li><p>无法获取跨域缓存：<code>cookie</code> <code>localstorge</code> <code>indexDB</code> 等</p></li><li><p>无法访问非同源网页的 DOM （iframe）。</p></li><li><p>无法向非同源地址发送 AJAX 请求 或 Fetch 请求（可以发送，但浏览器拒绝接受响应）。</p></li></ul><p>总结一下：</p><p>同源策略实际就是浏览器为了保证用户信息安全的策略，限制只有同源的文档或者脚本才能进行交互。其中同源是指<strong>协议</strong>、<strong>域名</strong>、<strong>端口</strong>三点相同。通过限制用户（一般是指开发者）通过操作dom、获取缓存信息以及发送ajax / fetch 请求等方式来获取用户信息来保证用户信息安全。</p><h1 id="解决跨域通信"><a href="#解决跨域通信" class="headerlink" title="解决跨域通信"></a>解决跨域通信</h1><p>我们在开发中，避免不了要跨域获取信息，其中最常见的就是发送跨域请求（<code>ajax / fetch</code>）来获取资源。那么解决跨域通信问题就成了我们的日常。根据浏览器的同源限制，我们将解决跨域通信分为2个方向：</p><ul><li>针对<strong>跨域的网络请求</strong>，需要前后端配合操作来解决，主要方法包括：<ul><li>CORS</li><li>JSONP</li><li>服务器代理</li></ul></li><li>针对DOM级别的操作，我们只需要通过前端解决，主要方法包括：<ul><li><code>postMassage</code>（HTML5 的 api， 允许两个窗口之间进行跨域发送消息）</li><li><code>document.domain</code>（只能用于一、二级域名都相同的情况）</li></ul></li></ul><table><thead><tr><th>通信侧</th><th>方法</th></tr></thead><tbody><tr><td>前端</td><td><code>postMassage</code>（HTML5 的 api， 允许两个窗口之间进行跨域发送消息）、<br /><code>document.domain</code>（只能用于一、二级域名都相同的情况）</td></tr><tr><td>前后端</td><td><code>CORS</code>、<code>jsonp</code>、服务器代理</td></tr></tbody></table><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>CORS（<strong>跨域资源共享  Cross-origin resource sharing）</strong>是W3C标准，它允许浏览器向跨域服务器发出请求，解决了<strong>同源限制中AJAX 请求无法跨域</strong>的问题。这种跨域通信解决方案不需要用户做额外的操作，是浏览器和服务器共同实现的。</p><p>在浏览器端，不需要用户额外配置，当用户在浏览器发送AJAX请求（例如在js代码中发起了ajax请求），浏览器会自动处理HTTP请求，同时会对服务器端返回的响应进行拦截处理，判断该响应是否同源，进而决定是返回正常的响应还是抛出错误。</p><p>而服务器则需要手动配置CORS接口，实现对跨域请求的处理。常用的<strong>服务器CORS配置字段</strong>如下：</p><table><thead><tr><th>协议头参数</th><th>说明</th><th>是否必须</th><th align="left">备注</th></tr></thead><tbody><tr><td><code>Access-Control-Allow-Origin</code></td><td>表示允许跨域请求的域 值为：<br />- 通配符<code>*</code>：接受任何域的跨域访问<br /><code>&lt;origin&gt;</code>：指定一个来源（只能指定一个）<br /><code>null</code> ：指定来源为 <code>null</code> <br />此时实际上就是不接受跨域，但是不推荐设置为该值。<br />因为浏览器在进行<code>CORS</code>判定时只会判断<code>Access-Control-Allow-Origin</code>字段是否存在而不会判断该字段的值，所以设置为<code>null</code>会导致安全问题</td><td>T</td><td align="left"></td></tr><tr><td><code>Access-Control-Allow-Methods</code></td><td>服务器允许跨域请求的 <code>http</code> 方法列表</td><td>T</td><td align="left">响应预检请求时，必须包含</td></tr><tr><td><code>Access-Control-Allow-Headers</code></td><td>列出了服务器支持的所有头信息字段，<br />这些字段可以用于预检请求的<code>Access-Control-Request-Headers</code></td><td>F</td><td align="left">当预请求（<code>OPTIONS</code>）中包含<code>Access-Control-Request-Headers</code>时，服务器必须设置该字段配置</td></tr><tr><td><code>Access-Control-Allow-Credentials</code></td><td>表示是否允许发送Cookie，只有一个可选值：true（必为小写）。<br />如果不发送cookie，则直接省略，不写为false</td><td>F</td><td align="left">CORS请求默认不发送<code>Cookie</code>和HTTP认证信息<br />要携带这些信息，需要发送方和服务器配置<br />服务器配置：<br />- <code>Access-Control-Allow-Credentials</code>为<code>true</code><br />- <code>Access-Control-Allow-Origin</code>不能为<code>*</code>，必须指定域名<br />发送方（JS）:<br/>开发者必须在AJAX请求中打开<code>withCredentials</code>属性</td></tr><tr><td><code>Access-Control-Max-Age</code></td><td>以秒为单位的缓存时间在有效时间内，<br />浏览器无须为同一请求再次发起预检请求</td><td>F</td><td align="left"></td></tr></tbody></table><p>在Nginx中的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">location</span> <span class="hljs-string">/</span> &#123;  <br>    <span class="hljs-string">add_header</span> <span class="hljs-string">Access-Control-Allow-Origin</span> <span class="hljs-string">*;</span><br>    <span class="hljs-string">add_header</span> <span class="hljs-string">Access-Control-Allow-Methods</span> <span class="hljs-string">&#x27;GET, POST, OPTIONS&#x27;</span><span class="hljs-string">;</span><br>    <span class="hljs-string">add_header</span> <span class="hljs-string">Access-Control-Allow-Headers</span> <span class="hljs-string">&#x27;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization&#x27;</span><span class="hljs-string">;</span><br><span class="hljs-string">add_header</span> <span class="hljs-string">Access-Control-Allow-Credentials</span> <span class="hljs-string">&#x27;true&#x27;</span><span class="hljs-string">;</span><br><span class="hljs-string">add_header</span> <span class="hljs-string">Access-Control-Max-Age</span> <span class="hljs-number">86400</span><span class="hljs-string">;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="CORS的判定流程"><a href="#CORS的判定流程" class="headerlink" title="CORS的判定流程"></a>CORS的判定流程</h2><p>CORS基本判定流程如图所示，主要分为三个阶段：</p><ol><li><strong>浏览器发起请求</strong>：处理请求头，增加<code>Origin</code>字段</li><li><strong>服务器处理请求，并返回响应</strong>：服务器接收请求，根据当前服务器的CORS配置决定是否在响应头中写入<code>Access-Control-Allow-Origin</code>，并返回正常HTTP响应（注意，因为这里无论是否接收跨域请求，服务器都会返回一个正常HTTP响应，所以无法通过状态码来判断跨域请求是否成功）：<ol><li>服务器已配置CORS，写入该字段</li><li>服务器未配置CORS，不写入该字段</li></ol></li><li><strong>浏览器处理响应</strong>：检查响应头是否存在<code>Access-Control-Allow-Origin</code>：<ol><li>存在，服务器不允许跨域，浏览器抛出错误，错误类型为：<code>No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource.</code></li><li>不存在，浏览器进一步比对该值是否包含当前域的值：<ol><li>包含，服务器同意该源的跨域请求，浏览器正常返回响应</li><li>不包含，服务器允许跨域请求，但拒绝当前源的请求，浏览器抛出错误，错误类型为：<code>The &#39;Access-Control-Allow-Origin&#39; header has a value &#39;[http://xxx.com](http://xxx.com/)&#39; that is not equal to the supplied origin.</code></li></ol></li></ol></li></ol><p><img src="3.png" alt="CORS判定流程图"></p><p>在这三个阶段中，根据<strong>请求类型（</strong>简单请求 / 非简单请求）的不同，具体的流程处理和操作也会不一致。</p><h2 id="简单请求和非简单请求"><a href="#简单请求和非简单请求" class="headerlink" title="简单请求和非简单请求"></a>简单请求和非简单请求</h2><p>什么是简单请求和非简单请求呢？实际上这个可以理解为根据当前请求的信息载量来进行区分的。对于信息载量较少的就是简单请求，信息载量多的就是非简单请求。对于这两种请求类型，有明确的定义。</p><h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><ol><li>使用 <code>GET、POST、HEAD</code> 其中一种请求方法。</li><li>HTTP的头信息不超出以下几种字段：</li></ol><ul><li><code>Accept</code></li><li><code>Accept-Language</code></li><li><code>Content-Language</code></li><li><code>Last-Event-ID</code></li><li><code>Content-Type</code>：只限于三个值 <code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code><ul><li>这三个值也是直接用表单提交可以设置的值</li></ul></li></ul><ol><li><code>XMLHttpRequestUpload</code>：<ol><li>请求中的任意<code>XMLHttpRequestUpload</code> 对象均没有注册任何事件监听器；</li><li><code>XMLHttpRequestUpload</code> 对象可以使用 <code>XMLHttpRequest.upload</code> 属性访问。 </li></ol></li><li>请求中没有使用 <code>ReadableStream</code> 对象。</li></ol><p>对于简单请求类型，整个CORS流程没什么变化（如上图一致），浏览器在第一阶段处理请求时，会直接在当前请求的请求头中增加<code>Origin</code>字段然后发送给服务器。</p><p><img src="1.png" alt="简单请求流程图示"></p><h3 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h3><p>除了简单请求，其他的都是非简单请求。</p><p>非简单请求的流程有所不同。对于非简单请求，浏览器会在正式通信之前，增加一次HTTP查询请求，称为“预检“请求（preflight）。只有通过了预检请求，浏览器才会发出正式通信。这里预检请求的方法是<code>OPTIONS</code> 。一次非简单请求的流程如下：</p><ul><li>浏览器发起<code>OPTIONS</code>请求：当浏览器发现当前的请求是非简单请求，会先发起<code>OPTIONS</code> 请求。在<code>OPTIONS</code>的请求头中增加3个字段：<ul><li><code>Origin</code></li><li><code>Access-Control-Request-Method</code>：列出浏览器的<strong>正式请求</strong>中会用到的HTTP方法。</li><li><code>Access-Control-Request-Headers</code>：指定浏览器的<strong>正式请求</strong>中会额外需要发送哪些头信息字段。</li></ul></li><li>服务器接收<code>OPTIONS</code>请求，返回响应：服务器收到请求后，会检查服务器的CORS配置和请求头中CORS字段，决定如何返回响应：<ul><li>服务器<strong>未配置CORS接口 or</strong> 服务器配置的CORS接口和请求头中的<strong>CORS字段不匹配</strong>：服务器<strong>否定</strong>此次预检请求，返回正常的HTTP响应，响应头中不包含CORS相关字段<code>（未配置 || 不匹配 ⇒ 否定：不包含）</code>。</li><li>服务器<strong>已配置 and</strong> 配置的CORS接口和请求头的<strong>CORS字段匹配</strong>：服务器<strong>肯定</strong>此次预检请求，返回正常的HTTP响应，响应头中包含CORS相关字段<code>（配置 &amp;&amp; 匹配 ⇒ 肯定：包含）</code>；</li></ul></li><li>浏览器处理响应：当浏览器接收到服务器的响应之后，检查响应头是否包含CORS相关字段：<ul><li>不包含，浏览器抛出错误</li><li>包含，服务器肯定此次预检请求，浏览器发出正式的<code>CORS</code>请求获取数据，这个正式的CORS请求的流程和简单请求一致。</li></ul></li></ul><p><img src="2.png" alt="非简单请求流程图示"></p><p>下面列出了CORS请求中会用到的协议头字段以及说明：</p><table><thead><tr><th>协议头参数</th><th>类型</th><th>说明</th><th>是否必须</th><th>备注</th></tr></thead><tbody><tr><td><code>Origin</code></td><td>请求头</td><td>该字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。</td><td>T</td><td></td></tr><tr><td><code>Access-Control-Request-Method</code></td><td>请求头</td><td>该字段用于预检请求，指名浏览器正式的CORS请求会用到的HTTP方法</td><td>T</td><td>发送预检请求时，必须包含</td></tr><tr><td><code>Access-Control-Request-Headers</code></td><td>请求头</td><td>该字段用于预检请求，指名浏览器正式的CORS请求会额外发送的头信息字段</td><td>T</td><td>发送预检请求时，必须包含</td></tr><tr><td><code>Access-Control-Allow-Origin</code></td><td>响应头</td><td>（同服务器配置字段含义）</td><td>T</td><td></td></tr><tr><td><code>Access-Control-Expose-Headers</code></td><td>响应头</td><td>该字段指明服务器允许哪些响应头可以暴露给浏览器中运行的脚本（JS），以响应跨源请求。<br />在没有额外指明的情况下，CORS请求时，XMLHttpRequest对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<br /><code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。<br/>如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。</td><td>F</td><td></td></tr><tr><td><code>Access-Control-Allow-Methods</code></td><td>响应头</td><td>（同服务器配置字段含义）</td><td>T</td><td></td></tr><tr><td><code>Access-Control-Allow-Headers</code></td><td>响应头</td><td>（同服务器配置字段含义）</td><td>F</td><td></td></tr><tr><td><code>Access-Control-Allow-Credentials</code></td><td>响应头</td><td>（同服务器配置字段含义）</td><td>F</td><td></td></tr><tr><td><code>Access-Control-Max-Age</code></td><td>响应头</td><td>（同服务器配置字段含义）</td><td>F</td><td></td></tr></tbody></table><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>JSONP 的原理就是利用 <code>&lt;script&gt;</code> 标签的 src 属性没有跨域的限制，通过指向一个需要访问的地址，由服务端返回一个预先定义好的 Javascript 函数的调用，并且将服务器数据以该函数参数的形式传递过来，此方法需要前后端配合完成。</p><ul><li><code>script</code>标签 src可跨域</li><li>将回调方法作为get参数传给后端</li><li>后端返回一个js，调用这个回调，并把数据传给回调</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//定义获取数据的回调方法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getData</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;<br><br><span class="hljs-comment">// 创建一个script标签，并且告诉后端回调函数名叫 getData</span><br><span class="hljs-keyword">var</span> body = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;body&#x27;</span>)[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">var</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">gerElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br>script.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;text/javasctipt&#x27;</span>;<br>script.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;demo.js?callback=getData&#x27;</span>;<br>body.<span class="hljs-title function_">appendChild</span>(script);<br><br><span class="hljs-comment">//script 加载完毕之后从页面中删除,否则每次点击生成许多script标签</span><br>script.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(script);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="服务器代理"><a href="#服务器代理" class="headerlink" title="服务器代理"></a>服务器代理</h2><p>浏览器对网络请求做了处理，所以通过从浏览器端发送的请求都会有跨域限制，但是服务器请求服务器就不存在这个问题。所以可以搭建一个代理服务器，将前端资源和代理服务器部署到一个域下，然后前端请求代理服务器，再通过代理服务器转发请求，从而实现请求跨域。</p><h2 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h2><p>该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式。</p><p>只需要给两个页面都添加 <code>document.domain = &#39;test.com&#39;</code>，通过在 <code>a.test.com</code> 创建一个 <code>iframe</code>，去控制 <code>iframe</code> 的 <code>window</code>，从而进行交互。</p><h2 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h2><p>window.postMessage 是一个 HTML5 的 api，允许两个窗口之间进行跨域发送消息。</p><p>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 发送消息端</span><br><span class="hljs-keyword">var</span> receiver = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;receiver&#x27;</span>).<span class="hljs-property">contentWindow</span>;<br><span class="hljs-keyword">var</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;send&#x27;</span>);<br>btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    e.<span class="hljs-title function_">preventDefault</span>();<br>    <span class="hljs-keyword">var</span> val = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;text&#x27;</span>).<span class="hljs-property">value</span>;<br>    receiver.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&quot;Hello &quot;</span>+val+<span class="hljs-string">&quot;！&quot;</span>, <span class="hljs-string">&quot;http://res.42du.cn&quot;</span>);<br>&#125;); <br><br><span class="hljs-comment">// 接收消息端</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;message&quot;</span>, receiveMessage, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">receiveMessage</span>(<span class="hljs-params">event</span>)&#123;<br>  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">origin</span> !== <span class="hljs-string">&quot;http://www.42du.cn&quot;</span>)<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="需要跨域请求的情况"><a href="#需要跨域请求的情况" class="headerlink" title="需要跨域请求的情况"></a>需要跨域请求的情况</h1><ul><li>由 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a> 或者 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch</a> 发起的跨源 HTTP 请求。</li><li>Web 字体 (CSS 中通过<code>@font-face</code>使用跨源字体资源)，<a href="https://www.w3.org/TR/css-fonts-3/#font-fetching-requirements">因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用</a>。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL">WebGL 贴图</a></li><li>使用 <code>drawImage</code> 将 <code>Images/video</code> 画面绘制到 <code>canvas</code></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://juejin.im/post/6844903816060469262">彻底理解浏览器的跨域</a><br><a href="https://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 详解</a><br><a href="https://segmentfault.com/a/1190000004322487">你真的会使用XMLHttpRequest吗？</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">跨源资源共享（CORS）</a><br><a href="https://juejin.cn/post/6844903767226351623">九种跨域方式实现原理（完整版）</a></p>]]></content>
    
    
    <categories>
      
      <category>浏览器原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>&lt;span class=&quot;label label-primary&quot;&gt;浏览器安全&lt;/span&gt; &lt;span class=&quot;label label-primary&quot;&gt;CORS&lt;/span&gt;</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BFC</title>
    <link href="/2023/02/28/BFC/"/>
    <url>/2023/02/28/BFC/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是BFC？"><a href="#什么是BFC？" class="headerlink" title="什么是BFC？"></a>什么是BFC？</h1><p>在了解BFC之前，先了解一下FC的定义。<strong>FC</strong>（Formatting Context 格式化上下文），FC指定了页面中一块独立区域的渲染规则，这个渲染规则可以理解为内部元素的布局规则。不同的FC有不同的规则定义。</p><p>目前网页中几种FC的分类：</p><ul><li><strong>IFC</strong>（Inline Formatting Context）：行级格式化上下文</li><li><strong>BFC</strong>（Block Formatting Context）：块格式化上下文<ul><li>更多关于IFC / BFC的定义参考：<a href="https://www.w3.org/TR/CSS2/visuren.html#normal-flow">CSS 2.1 Visual formatting model：Section 9.4</a></li></ul></li><li><strong>FFC</strong>（Flex Formatting Context）：自适应格式化上下文<ul><li>更多关于自适应布局的定义参考 ：<a href="https://drafts.csswg.org/css-flexbox-1/#flex-formatting-context">Flexible Box Layout Module Level 1</a></li></ul></li><li><strong>GFC</strong>（Grid Formatting Context）：网格布局格式化上下文</li></ul><h1 id="BFC的触发条件"><a href="#BFC的触发条件" class="headerlink" title="BFC的触发条件"></a>BFC的触发条件</h1><p>在以下几种情况下，会触发形成BFC：</p><ul><li>根元素<code>HTML</code></li><li>浮动元素：<code>float</code> 属性不为<code>none</code></li><li><code>position</code>定位：设置为 <code>absolute</code> 、<code>fixed</code></li><li><code>overflow</code> 属性：设置为非<code>visible</code> 、<code>clip</code>的<strong>块</strong>元素</li><li><code>display</code>属性：<ul><li>设置为 <code>table</code>类型：<ul><li><code>table</code>：对应<code>&lt;table&gt;</code></li><li><code>table-caption</code>：HTML 表格标题默认值</li><li><code>table-row</code>：对应<code>&lt;tr&gt;</code></li><li><code>table-row-group</code>：<code>&lt;tbody&gt;</code></li><li><code>table-header-group</code>：<code>&lt;thead&gt;</code></li><li><code>table-footer-group</code>：<code>&lt;tfoot&gt;</code></li><li><code>table-cell</code>：HTML 表格单元格默认值</li><li><code>inline-table</code></li></ul></li><li>设置为<code>inline-block</code></li><li>设置为<code>flow-root</code></li><li>设置为<code>flex</code>类型：父元素display属性为<code>flex</code> 或者 <code>inline-flex</code>，其子元素内部的布局规则为BFC（其子元素本身非<code>table</code>类型、<code>grid</code>类型、<code>flex</code>类型）</li><li>设置为<code>grid</code>类型：父元素display属性为<code>gird</code> 或者 <code>inline-grid</code>，其子元素内部的布局规则为BFC（其子元素本身非<code>table</code>类型、<code>grid</code>类型、<code>flex</code>类型）</li></ul></li><li><code>contain</code> 属性：<ul><li><code>layout</code></li><li><code>content</code></li><li><code>paint</code></li></ul></li><li><em>多列容器（暂时没有搞懂）</em></li></ul><h1 id="BFC渲染规则"><a href="#BFC渲染规则" class="headerlink" title="BFC渲染规则"></a>BFC渲染规则</h1><ul><li>渲染隔离：一个BFC是页面上的一个隔离的独立容器，容器里面的子元素的排版布局不会直接影响到外面的元素（可能通过子元素影响父元素容器大小间接影响外部元素布局）。</li><li>容器大小计算：区域大小由内部元素的边界确定：<ul><li>即一个BFC容器会包裹所有的子元素块，无论该子元素是否是浮动元素，所以BFC的高度计算会包含<code>float</code>元素。</li></ul></li><li><code>margin</code>重叠：<ul><li>在同一个BFC中，相邻元素形成的<code>box</code>的上下<code>margin</code>产生重叠；</li><li>但在不同的BFC中，各自的子元素的<code>margin</code>不重叠。</li></ul></li><li>排布方向：<ul><li>内部的子元素由上到下依次排布。</li><li>内部子元素根据书写方向（<code>writing-mode</code>）确定从左开始排布还是从右开始排布。</li><li>起始位置的子元素的<code>margin</code>紧贴父容器的<code>border</code>（只有起始方向的<code>margin</code>紧贴）。</li></ul></li><li>当前的BFC不与外部的<code>float box</code>重叠。</li></ul><h1 id="实例验证"><a href="#实例验证" class="headerlink" title="实例验证"></a>实例验证</h1><h2 id="1、容器大小计算"><a href="#1、容器大小计算" class="headerlink" title="1、容器大小计算"></a>1、容器大小计算</h2><p>区域大小由内部元素的边界确定，高度计算包含<code>float</code>元素<br>当不给父容器设置高度的情况下，查看父容器的高度是如何计算的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-comment">&lt;!-- bfc的高度计算会包含float子元素 可以用作清除内部浮动 --&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>BFC<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.bfc</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">display</span>: flow-root;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.container</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#939393</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background</span>: <span class="hljs-number">#f2f2f2</span>;</span><br><span class="language-css">            <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.float</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#e98f53</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.child</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">40px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">40px</span>;</span><br><span class="language-css">        &#125;  </span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 父容器非BFC --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;float child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 父容器是BFC --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bfc container&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin-top: 100px&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;float child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="1.png"></p><h2 id="2、margin重叠"><a href="#2、margin重叠" class="headerlink" title="2、margin重叠"></a>2、margin重叠</h2><p>同一个BFC中相邻的元素上下<code>margin</code>重叠<br>当给子元素设置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>BFC<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.bfc</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">display</span>: flow-root;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.container</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#939393</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background</span>: <span class="hljs-number">#f2f2f2</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">       <span class="hljs-selector-class">.bfc-child</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">40px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">margin</span>: <span class="hljs-number">30px</span> <span class="hljs-number">0</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ccc</span>;</span><br><span class="language-css">       &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bfc container&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bfc-child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bfc container&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bfc-child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bfc-child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="2.png"></p><p>相反，当父容器非BFC时，所有子元素（无论是否是平级）都会发生上下<code>margin</code>重叠。<br>将上面父容器的display属性改为<code>contents</code> ：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.bfc</span>&#123;<br><span class="hljs-attribute">display</span>: contents;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="3.png"></p><blockquote><p>contents<br>These elements don’t produce a specific box by themselves. They are replaced by their pseudo-box and their child boxes. </p><p>当设置元素为content时，该元素不会生成自己的box，而是会被子元素生成的box取代。</p></blockquote><p>会发现此时处于两个父级下的子元素，上下<code>margin</code>也会发生重叠。此时因为父容器不是BFC，没有渲染隔离，所有子元素生成的盒子被平铺到了最外层。</p><h2 id="3、当前的BFC不与外部的float-box重叠"><a href="#3、当前的BFC不与外部的float-box重叠" class="headerlink" title="3、当前的BFC不与外部的float box重叠"></a>3、当前的BFC不与外部的<code>float box</code>重叠</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>BFC<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">     <span class="hljs-selector-class">.bfc</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">display</span>: flow-root;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.float</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#e98f53</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">40px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">40px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.aside</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#696fa7</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 规则三：bfc区域不和浮动元素重叠 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;float&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;aside&quot;</span>&gt;</span>该元素非BFC，则该元素和小黄块重叠<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;float&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;aside bfc&quot;</span>&gt;</span>该元素BFC，则该元素和小黄块不重叠<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><img src="4.png"></p><h1 id="BFC的作用"><a href="#BFC的作用" class="headerlink" title="BFC的作用"></a>BFC的作用</h1><p>利用BFC的渲染规则，可以实现以下几个功能：</p><ul><li>自适应两栏布局</li><li>阻止元素被浮动元素覆盖</li><li>清除内部浮动</li><li>阻止<code>margin</code>重叠：分属于不同的BFC时不发生重叠</li></ul><p>后面三条在实验中以及实现过了，但是针对第一条，如何利用BFC实现两栏布局呢？</p><p>利用2个特性：</p><ol><li>块级元素<code>width:auto</code> 时，会自动拉伸至父元素左右边界处（横向占满）。</li><li>BFC渲染规则：当前的BFC不与外部的<code>float box</code>重叠。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>BFC<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.bfc</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">display</span>: flow-root;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"><span class="hljs-selector-class">.container</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#939393</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background</span>: <span class="hljs-number">#f2f2f2</span>;</span><br><span class="language-css">            <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.main</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background</span>: <span class="hljs-number">#ddd</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.float-aside</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">            <span class="hljs-attribute">background</span>: <span class="hljs-number">#757575</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 利用bfc区域不和浮动元素重叠的特性，实现自适应两栏布局 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bfc container&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;float-aside&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bfc main&quot;</span>&gt;</span>设置float的宽度，然后给相邻的bfc元素不设置宽度，块级元素默认宽度为auto，那么该bfc元素会自动延伸到父元素的最右端<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="5.png"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://juejin.cn/post/6844903476774830094">[布局概念] 关于CSS-BFC深入理解</a><br><a href="https://drafts.csswg.org/css-display/#formatting-context">CSS Display Module Level 4</a></p>]]></content>
    
    
    <categories>
      
      <category>Web前端</category>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>&lt;span class=&quot;label label-primary&quot;&gt;BFC&lt;/span&gt; &lt;span class=&quot;label label-primary&quot;&gt;CSS渲染&lt;/span&gt;</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>this指针和箭头函数</title>
    <link href="/2023/02/28/this%E6%8C%87%E9%92%88/"/>
    <url>/2023/02/28/this%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是this？"><a href="#什么是this？" class="headerlink" title="什么是this？"></a>什么是<code>this</code>？</h1><p><code>this</code>是一个引用，指向当前函数执行的<strong>上下文对象</strong>。是在运行时绑定的。</p><blockquote><p>💡 执行上下文<br>当 JS 引擎解析到可执行代码片段（通常是函数调用阶段）的时候，就会先做一些执行前的准备工作，这个 “准备工作”，就叫做 “<strong>执行上下文(execution context 简称 EC)</strong>“ 或者也可以叫做 <strong>执行环境</strong>。<br>执行上下文 为我们的可执行代码块提供了执行前的必要准备工作，例如变量对象的定义、作用域链的扩展、提供调用者的对象引用等信息。</p></blockquote><p><img src="this.png" alt="this.png"></p><h1 id="this的绑定规则"><a href="#this的绑定规则" class="headerlink" title="this的绑定规则"></a>this的绑定规则</h1><p>优先级：<code>new</code> &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定</p><h2 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h2><p>当函数被<strong>独立调用</strong>时，默认函数的<code>this</code>指向<strong>全局对象</strong>，此时在浏览器运行环境中，能获取到全局对象下使用<a href="https://www.notion.so/c80e2b095b104f7f8c53c745185de9d0">var操作符定义的变量，但不能获取到let定义的变量</a>。</p><p>当在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode">严格模式</a>下时，<code>this</code>不能获取到全局对象下的变量。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 浏览器运行环境下</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;name is: &#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;age is: &#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;kira&#x27;</span>;<br><span class="hljs-keyword">let</span> age = <span class="hljs-number">3</span>;<br><br><span class="hljs-title function_">foo</span>();<br><span class="hljs-comment">// name is:  kira</span><br><span class="hljs-comment">// age is:  undefined</span><br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 严格模式</span><br><span class="hljs-meta">&quot;use strict&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;name is: &#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;age is: &#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);<br><br>&#125;<br><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;kira&#x27;</span>;<br><span class="hljs-keyword">let</span> age = <span class="hljs-number">3</span>;<br><br><span class="hljs-title function_">foo</span>();<br><span class="hljs-comment">/* </span><br><span class="hljs-comment">   Uncaught TypeError: Cannot read property &#x27;name&#x27; of undefined at foo </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h2><p>使用<strong>对象调用</strong>时，函数的<code>this</code>会指向当前调用的对象。</p><p><code>this</code> 指向链式调用的最后一层</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;name is: &#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;age is: &#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);<br><br>&#125;<br><br><span class="hljs-keyword">const</span> person = &#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;kira&#x27;</span>,<br><span class="hljs-attr">age</span>: <span class="hljs-number">3</span>,<br><span class="hljs-attr">foo</span>: foo<br>&#125;<br><br>person.<span class="hljs-title function_">foo</span>();<br><span class="hljs-comment">// name is:  kira</span><br><span class="hljs-comment">// age is:  3</span><br></code></pre></td></tr></table></figure><p><strong>还需要注意的是隐式绑定丢失：</strong></p><p>当把对象 <code>o</code> 的方法 <code>o.method</code> 赋值给一个变量 <code>fn</code>，然后再调用这个变量 <code>fn</code> 的时候，<code>this</code> 不会指向这个对象 <code>o</code>，而会指向全局对象。<br>这是因为，赋值语句是静态执行，而 <code>this</code> 绑定是动态绑定。<br>当我们把一个函数，无论是【对象的方法】还是【普通函数】赋值给一个变量的时候，实际上我们是把当前函数的引用（也就是函数存放的地址）赋值给这个变量。<br>而当我们真正调用的时候，才会绑定 <code>this</code> ，此时对于这个函数变量来说，就是以独立的形式被调用了，所以此时 <code>this</code> 为默认绑定。</p><p>这种隐式丢失的情况有2种：</p><ol><li>直接把对象方法赋值给一个变量</li><li>把一个对象方法作为参数传给另一个函数，这里因为存在给参数变量隐式赋值的步骤，所以也会丢失</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> obj = &#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;kira&#x27;</span>,<br><span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;name is: &#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;window&#x27;</span>;<br><span class="hljs-keyword">var</span> windowFoo = obj.<span class="hljs-property">foo</span>;  <span class="hljs-comment">// 隐式丢失：情况1</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">showFoo</span>(<span class="hljs-params">fn</span>)&#123;<br><span class="hljs-title function_">fn</span>();  <span class="hljs-comment">// 隐式丢失：情况2</span><br>&#125;<br><br>obj.<span class="hljs-title function_">foo</span>();<br><span class="hljs-title function_">windowFoo</span>();<br><span class="hljs-title function_">showFoo</span>(obj.<span class="hljs-property">foo</span>);<br><span class="hljs-built_in">setTimeout</span>(obj.<span class="hljs-property">foo</span>, <span class="hljs-number">1000</span>) <span class="hljs-comment">// 隐式丢失： 情况2</span><br><br><span class="hljs-comment">// name is:  kira</span><br><span class="hljs-comment">// name is:  window</span><br><span class="hljs-comment">// name is:  window</span><br><span class="hljs-comment">// name is:  window</span><br></code></pre></td></tr></table></figure><h2 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h2><p>显示绑定是指给函数直接指定上下文参数（<code>context</code>）。显示绑定有4种方式：</p><ul><li><p><code>call</code></p></li><li><p><code>apply</code></p></li><li><p><code>bind</code> ：关于<code>bind</code>绑定，要注意以下2点：</p><ul><li>使用<code>bind</code>绑定过的函数，只有使用<code>new</code>方法调用才可以更改函数的<code>this</code>值</li></ul></li><li><p><code>js</code>内置函数中的参数传递：例如数组原型方法中的可选参数<code>context</code>，会把<strong>回调函数</strong> [ 非箭头函数 ] 的<code>this</code>指向传入的<code>context</code></p></li><li><p>这4种方式中，关于指定的<code>context</code> 的类型，<code>this</code>的指向：</p><ul><li><code>undefined</code>  <code>null</code> : 指向全局对象</li><li><code>string</code> <code>number</code> <code>bool</code> ：指向当前值类型的原型实例</li><li><code>function</code>：指向函数本身</li><li>引用类型 <code>object</code> <code>array</code>：指向引用对象</li></ul></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// js中内置函数参数传递</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;context&#x27;</span>];<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;this&#x27;</span>, <span class="hljs-variable language_">this</span>)&#125;, &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;非箭头函数&#x27;</span>&#125;);<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;this&#x27;</span>, <span class="hljs-variable language_">this</span>)&#125;, &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;箭头函数&#x27;</span>&#125;);<br></code></pre></td></tr></table></figure><p><img src="1.png" alt="显示绑定：数组传入上下文"></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 传入各种类型的context</span><br><span class="hljs-comment">// call, apply, bind, 内置函数中的参数传递同理</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getContext</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;当前函数的上下文对象 this是：&#x27;</span>, <span class="hljs-variable language_">this</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fnContext</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;fnContext函数作为上下文对象&#x27;</span>)<br>&#125;<br><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;array&#x27;</span>, <span class="hljs-string">&#x27;context&#x27;</span>];<br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;objContext&#x27;</span><br>&#125;<br><br>getContext.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// window</span><br>getContext.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// window</span><br>getContext.<span class="hljs-title function_">call</span>(<span class="hljs-string">&#x27;string&#x27;</span>) <span class="hljs-comment">// String</span><br>getContext.<span class="hljs-title function_">call</span>(<span class="hljs-number">123</span>) <span class="hljs-comment">// Number</span><br>getContext.<span class="hljs-title function_">call</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// Boolean</span><br>getContext.<span class="hljs-title function_">call</span>(fnContext) <span class="hljs-comment">// fnContext</span><br>getContext.<span class="hljs-title function_">call</span>(arr) <span class="hljs-comment">// arr</span><br>getContext.<span class="hljs-title function_">call</span>(obj) <span class="hljs-comment">// obj</span><br></code></pre></td></tr></table></figure><p>控制台打印结果：<br><img src="2.png" alt="传入各种类型的上下文"></p><h2 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h2><p><code>new</code> 操作符的步骤<br><img src="3.png" alt="new操作步骤"></p><p>注意，使用<code>new</code>创建对象时，如果构造函数返回的是引用类型，则<code>new</code>操作生成的对象会被这个引用类型取代。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params">value</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;foo&#x27;</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;object&#x27;</span>&#125;;<br><span class="hljs-keyword">let</span> arr = [];<br><span class="hljs-keyword">let</span> fn = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;this is a function&#x27;</span>)&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(<span class="hljs-literal">null</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(<span class="hljs-literal">undefined</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(<span class="hljs-number">1</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(<span class="hljs-literal">true</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(<span class="hljs-string">&#x27;string&#x27;</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(obj), obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(arr), arr);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(fn), fn);<br></code></pre></td></tr></table></figure><p><img src="7.png" alt="new创建对象，构造函数返回不同类型时的结果"></p><h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><h2 id="箭头函数this对象"><a href="#箭头函数this对象" class="headerlink" title="箭头函数this对象"></a>箭头函数<code>this</code>对象</h2><p>箭头函数没有<code>this</code>对象，或者说箭头函数的<code>this</code>对象早在词法分析时就已经被“绑定”为上层词法作用域（也就是函数声明时所在的作用域）的<code>this</code>了。</p><p>例如下面这个例子：</p><ol><li>当<code>outer</code>调用时，<code>this</code>对象被绑定为<code>obj</code>；</li><li>因为箭头函数是在<code>outer</code>方法中声明的，所以此时返回的箭头函数的<code>this</code>被“绑定”为<code>outer</code>实际执行时的<code>this</code>对象。所以无论该箭头函数在何处被调用，都不会发生改变。</li><li>而如果返回的是普通函数，那么该函数的<code>this</code>对象就会根据调用方式而发生变化。<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-title function_">arrowFn</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;当前在global环境下调用箭头函数，this：&#x27;</span>, <span class="hljs-variable language_">this</span>)<br>    &#125;<br>    <span class="hljs-keyword">let</span> fn = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;当前在global环境下调用普通函数，this：&#x27;</span>, <span class="hljs-variable language_">this</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> [arrowFn, fn];<br>&#125;<br><br><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj&#x27;</span> &#125;;<br><span class="hljs-keyword">let</span> obj1 = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj1&#x27;</span>&#125;;<br><span class="hljs-comment">// 将outer的this绑定为obj</span><br><span class="hljs-keyword">let</span> [arrowFn, fn] = outer.<span class="hljs-title function_">call</span>(obj);<br><span class="hljs-title function_">arrowFn</span>();<br><span class="hljs-title function_">fn</span>();<br><br><span class="hljs-comment">//绑定this</span><br>arrowFn.<span class="hljs-title function_">call</span>(obj1);<br>fn.<span class="hljs-title function_">call</span>(obj1);<br></code></pre></td></tr></table></figure>控制台打印</li></ol><p><img src="8.png" alt="箭头函数与普通函数的this值对比"></p><h2 id="箭头函数与普通函数的区别"><a href="#箭头函数与普通函数的区别" class="headerlink" title="箭头函数与普通函数的区别"></a>箭头函数与普通函数的区别</h2><p>（1）箭头函数的 <code>this</code> 值等于<strong>箭头函数</strong>在<strong>声明</strong>时所在的<strong>上层函数</strong>在<strong>调用</strong>时所绑定的<code>this</code>值。示例如上。</p><p>（2）箭头函数没有自己的 <code>this</code> <code>prototype</code> <code>arguments</code> <code>super</code> 和 <code>new.target</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 箭头函数和普通函数</span><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">arrowFn</span> = (<span class="hljs-params">arg1</span>) =&gt; &#123;&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">arg1</span>)&#123;&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">dir</span>(arrowFn)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">dir</span>(fn)<br></code></pre></td></tr></table></figure><p>控制台打印：</p><p><img src="4.png" alt="箭头函数没有this等属性"></p><p>（3）箭头函数的不能用作构造函数</p><p><img src="5.png" alt="new一个箭头函数会报错"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><p>对 <code>this</code> 对象的理解<br>this 是一个引用，指向当前函数的调用对象。对于非箭头函数来说，</p><ol><li>当独立调用函数时，<code>this</code>指向全局对象；</li><li>当函数作为对象的方法调用时，<code>this</code>指向这个当前对象；</li><li>当函数以<code>call</code>，<code>apply</code>，<code>bind</code>调用，或者对于一些内置的函数例如数组的<code>forEach</code>，<code>map</code>方法，传入指定的上下文对象时，<code>this</code>指向绑定的上下文对象。其中根据传入的上下文对象类型，<code>this</code>会指向不同的对象：<ol><li>如果传入是<code>null</code>或者<code>undefined</code>，则this指向全局对象；</li><li>如果传入的是<code>number</code>, <code>string</code>, <code>boolean</code>值，js会将当前值实例化，并将<code>this</code>指向其实例。（根据当前基本类型的原型对象创建实例，并将当前值作为value参数传入构造函数）；</li><li>如果传入的是函数，则会指向函数对象本身；</li><li>如果传入的是引用类型，则直接指向该引用对象。</li></ol></li><li>如果用<code>new</code>调用函数，则<code>this</code>会指向该函数原型的实例对象。</li></ol></li><li><p>箭头函数和普通函数的区别？<br>箭头函数没有自己的 <code>this</code> <code>arguments</code> <code>prototype</code> <code>super</code>和<code>new.target</code> 以及箭头函数不能作为构造函数使用</p></li><li><p>箭头函数的 <code>this</code> 指向哪里？<br>箭头函数的this等于其函数<strong>声明</strong>时所在的<strong>上级函数被调用</strong>时的<code>this</code></p></li><li><p>如果<code>new</code> 一个箭头函数，会发生什么？<br>会报错，提示箭头函数没有构造函数</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Web前端</category>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>&lt;span class=&quot;label label-primary&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;label label-primary&quot;&gt;箭头函数&lt;/span&gt;</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
