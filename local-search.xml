<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>浏览器同源策略</title>
    <link href="/2023/02/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"/>
    <url>/2023/02/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><h2 id="什么是同源策略"><a href="#什么是同源策略" class="headerlink" title="什么是同源策略"></a>什么是同源策略</h2><p>同源策略是一个重要的<strong>安全策略</strong>，它用于<strong>限制</strong>一个源（origin）的文档或者它加载的脚本如何能与另一个源的资源进行<strong>交互</strong>。非同源下的文档和脚本（JS），不能跨域获取资源。</p><p>其中<strong>同源</strong>是指：</p><ul><li>协议相同</li><li>域名相同</li><li>端口相同</li></ul><h2 id="为什么会存在同源策略"><a href="#为什么会存在同源策略" class="headerlink" title="为什么会存在同源策略"></a>为什么会存在同源策略</h2><p>同源策略是<strong>浏览器</strong>为了<strong>保护用户信息安全</strong>所执行的策略。1995年由 Netscape 公司引入的，目前所有的<strong>浏览器</strong>都执行这个策略。</p><p>因为它的主要目的是为了保证用户信息安全，所以只要涉及到用户信息的获取途径都会被<strong>限制</strong>，这些信息获取途径包括：</p><ul><li>通过操作<strong>其他网站</strong>或者 <strong>iframe</strong>的 <code>dom</code> 来获取用户的表单数据</li><li>通过获取<code>cookie</code>，<code>localstorge</code>，<code>sessionstorage</code>，<code>indexDB</code>等缓存信息，来获取用户信息</li><li>通过发送 <code>ajax / fetch</code> 请求，来获取后端的用户信息（提交表单不受跨域限制）</li></ul><p>如果不对这些途径加以限制，就可能被恶意网站盗取用户信息。那么恶意是如何通过这几种途径获取信息的呢？举几个案例（来源于<a href="https://juejin.im/post/6844903816060469262">彻底理解浏览器的跨域</a>）：</p><blockquote><p>案例：<br>一、cookie获取发送请求<br>A 网站是一家银行，用户登录以后，A 网站在用户的机器上设置了一个 Cookie，包含了一些隐私信息（比如存款总额）。用户离开 A 网站以后，又去访问 B 网站，如果没有同源限制，B 网站可以读取 A 网站的 Cookie，那么隐私信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。<br>例如</p><ol><li>用户登录了自己的银行页面 <a href="http://mybank.com/">http://mybank.com</a>，<a href="https://www.notion.so/b4dda8a6ca0b4a308ed8dd5d5f77861a">mybank.com</a> 向用户的cookie中添加用户标识。</li><li>用户浏览了恶意页面 <a href="http://evil.com/">evil.com</a>。执行了页面中的恶意AJAX请求代码。</li><li>向<a href="http://mybank.com发起ajax/">http://mybank.com发起AJAX</a> HTTP请求，请求会默认把<a href="http://mybank.com对应cookie也同时发送过去./">http://mybank.com对应cookie也同时发送过去。</a></li><li>银行页面从发送的cookie中提取用户标识，验证用户无误，response中返回请求数据。此时数据就泄露了。</li><li>而且由于Ajax在后台执行，用户无法感知这一过程。</li></ol><p>二、dom操作</p><ol><li>做一个假网站，里面用iframe嵌套一个银行网站 <a href="http://mybank.com/">mybank.com</a>。</li><li>把iframe宽高啥的调整到页面全部，这样用户进来除了域名，别的部分和银行的网站没有任何差别。</li><li>这时如果用户输入账号密码，我们的主网站可以跨域访问到<a href="http://mybank.com的dom节点,就可以拿到用户的输入了,那么就完成了一次攻击/">http://mybank.com的dom节点，就可以拿到用户的输入了，那么就完成了一次攻击</a></li></ol></blockquote><p>所以针对这三点，浏览器做了同源限制：</p><ul><li><p>无法获取跨域缓存：<code>cookie</code> <code>localstorge</code> <code>indexDB</code> 等</p></li><li><p>无法访问非同源网页的 DOM （iframe）。</p></li><li><p>无法向非同源地址发送 AJAX 请求 或 Fetch 请求（可以发送，但浏览器拒绝接受响应）。</p></li></ul><p>总结一下：</p><p>同源策略实际就是浏览器为了保证用户信息安全的策略，限制只有同源的文档或者脚本才能进行交互。其中同源是指<strong>协议</strong>、<strong>域名</strong>、<strong>端口</strong>三点相同。通过限制用户（一般是指开发者）通过操作dom、获取缓存信息以及发送ajax / fetch 请求等方式来获取用户信息来保证用户信息安全。</p><h1 id="解决跨域通信"><a href="#解决跨域通信" class="headerlink" title="解决跨域通信"></a>解决跨域通信</h1><p>我们在开发中，避免不了要跨域获取信息，其中最常见的就是发送跨域请求（<code>ajax / fetch</code>）来获取资源。那么解决跨域通信问题就成了我们的日常。根据浏览器的同源限制，我们将解决跨域通信分为2个方向：</p><ul><li>针对<strong>跨域的网络请求</strong>，需要前后端配合操作来解决，主要方法包括：<ul><li>CORS</li><li>JSONP</li><li>服务器代理</li></ul></li><li>针对DOM级别的操作，我们只需要通过前端解决，主要方法包括：<ul><li><code>postMassage</code>（HTML5 的 api， 允许两个窗口之间进行跨域发送消息）</li><li><code>document.domain</code>（只能用于一、二级域名都相同的情况）</li></ul></li></ul><table><thead><tr><th>通信侧</th><th>方法</th></tr></thead><tbody><tr><td>前端</td><td><code>postMassage</code>（HTML5 的 api， 允许两个窗口之间进行跨域发送消息）、<br /><code>document.domain</code>（只能用于一、二级域名都相同的情况）</td></tr><tr><td>前后端</td><td><code>CORS</code>、<code>jsonp</code>、服务器代理</td></tr></tbody></table><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>CORS（<strong>跨域资源共享  Cross-origin resource sharing）</strong>是W3C标准，它允许浏览器向跨域服务器发出请求，解决了<strong>同源限制中AJAX 请求无法跨域</strong>的问题。这种跨域通信解决方案不需要用户做额外的操作，是浏览器和服务器共同实现的。</p><p>在浏览器端，不需要用户额外配置，当用户在浏览器发送AJAX请求（例如在js代码中发起了ajax请求），浏览器会自动处理HTTP请求，同时会对服务器端返回的响应进行拦截处理，判断该响应是否同源，进而决定是返回正常的响应还是抛出错误。</p><p>而服务器则需要手动配置CORS接口，实现对跨域请求的处理。常用的<strong>服务器CORS配置字段</strong>如下：</p><table><thead><tr><th>协议头参数</th><th>说明</th><th>是否必须</th><th align="left">备注</th></tr></thead><tbody><tr><td><code>Access-Control-Allow-Origin</code></td><td>表示允许跨域请求的域 值为：<br />- 通配符<code>*</code>：接受任何域的跨域访问<br /><code>&lt;origin&gt;</code>：指定一个来源（只能指定一个）<br /><code>null</code> ：指定来源为 <code>null</code> <br />此时实际上就是不接受跨域，但是不推荐设置为该值。<br />因为浏览器在进行<code>CORS</code>判定时只会判断<code>Access-Control-Allow-Origin</code>字段是否存在而不会判断该字段的值，所以设置为<code>null</code>会导致安全问题</td><td>T</td><td align="left"></td></tr><tr><td><code>Access-Control-Allow-Methods</code></td><td>服务器允许跨域请求的 <code>http</code> 方法列表</td><td>T</td><td align="left">响应预检请求时，必须包含</td></tr><tr><td><code>Access-Control-Allow-Headers</code></td><td>列出了服务器支持的所有头信息字段，<br />这些字段可以用于预检请求的<code>Access-Control-Request-Headers</code></td><td>F</td><td align="left">当预请求（<code>OPTIONS</code>）中包含<code>Access-Control-Request-Headers</code>时，服务器必须设置该字段配置</td></tr><tr><td><code>Access-Control-Allow-Credentials</code></td><td>表示是否允许发送Cookie，只有一个可选值：true（必为小写）。<br />如果不发送cookie，则直接省略，不写为false</td><td>F</td><td align="left">CORS请求默认不发送<code>Cookie</code>和HTTP认证信息<br />要携带这些信息，需要发送方和服务器配置<br />服务器配置：<br />- <code>Access-Control-Allow-Credentials</code>为<code>true</code><br />- <code>Access-Control-Allow-Origin</code>不能为<code>*</code>，必须指定域名<br />发送方（JS）:<br/>开发者必须在AJAX请求中打开<code>withCredentials</code>属性</td></tr><tr><td><code>Access-Control-Max-Age</code></td><td>以秒为单位的缓存时间在有效时间内，<br />浏览器无须为同一请求再次发起预检请求</td><td>F</td><td align="left"></td></tr></tbody></table><p>在Nginx中的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">location</span> <span class="hljs-string">/</span> &#123;  <br>    <span class="hljs-string">add_header</span> <span class="hljs-string">Access-Control-Allow-Origin</span> <span class="hljs-string">*;</span><br>    <span class="hljs-string">add_header</span> <span class="hljs-string">Access-Control-Allow-Methods</span> <span class="hljs-string">&#x27;GET, POST, OPTIONS&#x27;</span><span class="hljs-string">;</span><br>    <span class="hljs-string">add_header</span> <span class="hljs-string">Access-Control-Allow-Headers</span> <span class="hljs-string">&#x27;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization&#x27;</span><span class="hljs-string">;</span><br><span class="hljs-string">add_header</span> <span class="hljs-string">Access-Control-Allow-Credentials</span> <span class="hljs-string">&#x27;true&#x27;</span><span class="hljs-string">;</span><br><span class="hljs-string">add_header</span> <span class="hljs-string">Access-Control-Max-Age</span> <span class="hljs-number">86400</span><span class="hljs-string">;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="CORS的判定流程"><a href="#CORS的判定流程" class="headerlink" title="CORS的判定流程"></a>CORS的判定流程</h2><p>CORS基本判定流程如图所示，主要分为三个阶段：</p><ol><li><strong>浏览器发起请求</strong>：处理请求头，增加<code>Origin</code>字段</li><li><strong>服务器处理请求，并返回响应</strong>：服务器接收请求，根据当前服务器的CORS配置决定是否在响应头中写入<code>Access-Control-Allow-Origin</code>，并返回正常HTTP响应（注意，因为这里无论是否接收跨域请求，服务器都会返回一个正常HTTP响应，所以无法通过状态码来判断跨域请求是否成功）：<ol><li>服务器已配置CORS，写入该字段</li><li>服务器未配置CORS，不写入该字段</li></ol></li><li><strong>浏览器处理响应</strong>：检查响应头是否存在<code>Access-Control-Allow-Origin</code>：<ol><li>存在，服务器不允许跨域，浏览器抛出错误，错误类型为：<code>No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource.</code></li><li>不存在，浏览器进一步比对该值是否包含当前域的值：<ol><li>包含，服务器同意该源的跨域请求，浏览器正常返回响应</li><li>不包含，服务器允许跨域请求，但拒绝当前源的请求，浏览器抛出错误，错误类型为：<code>The &#39;Access-Control-Allow-Origin&#39; header has a value &#39;[http://xxx.com](http://xxx.com/)&#39; that is not equal to the supplied origin.</code></li></ol></li></ol></li></ol><p><img src="3.png" alt="CORS判定流程图"></p><p>在这三个阶段中，根据<strong>请求类型（</strong>简单请求 / 非简单请求）的不同，具体的流程处理和操作也会不一致。</p><h2 id="简单请求和非简单请求"><a href="#简单请求和非简单请求" class="headerlink" title="简单请求和非简单请求"></a>简单请求和非简单请求</h2><p>什么是简单请求和非简单请求呢？实际上这个可以理解为根据当前请求的信息载量来进行区分的。对于信息载量较少的就是简单请求，信息载量多的就是非简单请求。对于这两种请求类型，有明确的定义。</p><h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><ol><li>使用 <code>GET、POST、HEAD</code> 其中一种请求方法。</li><li>HTTP的头信息不超出以下几种字段：</li></ol><ul><li><code>Accept</code></li><li><code>Accept-Language</code></li><li><code>Content-Language</code></li><li><code>Last-Event-ID</code></li><li><code>Content-Type</code>：只限于三个值 <code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code><ul><li>这三个值也是直接用表单提交可以设置的值</li></ul></li></ul><ol><li><code>XMLHttpRequestUpload</code>：<ol><li>请求中的任意<code>XMLHttpRequestUpload</code> 对象均没有注册任何事件监听器；</li><li><code>XMLHttpRequestUpload</code> 对象可以使用 <code>XMLHttpRequest.upload</code> 属性访问。 </li></ol></li><li>请求中没有使用 <code>ReadableStream</code> 对象。</li></ol><p>对于简单请求类型，整个CORS流程没什么变化（如上图一致），浏览器在第一阶段处理请求时，会直接在当前请求的请求头中增加<code>Origin</code>字段然后发送给服务器。</p><p><img src="1.png" alt="简单请求流程图示"></p><h3 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h3><p>除了简单请求，其他的都是非简单请求。</p><p>非简单请求的流程有所不同。对于非简单请求，浏览器会在正式通信之前，增加一次HTTP查询请求，称为“预检“请求（preflight）。只有通过了预检请求，浏览器才会发出正式通信。这里预检请求的方法是<code>OPTIONS</code> 。一次非简单请求的流程如下：</p><ul><li>浏览器发起<code>OPTIONS</code>请求：当浏览器发现当前的请求是非简单请求，会先发起<code>OPTIONS</code> 请求。在<code>OPTIONS</code>的请求头中增加3个字段：<ul><li><code>Origin</code></li><li><code>Access-Control-Request-Method</code>：列出浏览器的<strong>正式请求</strong>中会用到的HTTP方法。</li><li><code>Access-Control-Request-Headers</code>：指定浏览器的<strong>正式请求</strong>中会额外需要发送哪些头信息字段。</li></ul></li><li>服务器接收<code>OPTIONS</code>请求，返回响应：服务器收到请求后，会检查服务器的CORS配置和请求头中CORS字段，决定如何返回响应：<ul><li>服务器<strong>未配置CORS接口 or</strong> 服务器配置的CORS接口和请求头中的<strong>CORS字段不匹配</strong>：服务器<strong>否定</strong>此次预检请求，返回正常的HTTP响应，响应头中不包含CORS相关字段<code>（未配置 || 不匹配 ⇒ 否定：不包含）</code>。</li><li>服务器<strong>已配置 and</strong> 配置的CORS接口和请求头的<strong>CORS字段匹配</strong>：服务器<strong>肯定</strong>此次预检请求，返回正常的HTTP响应，响应头中包含CORS相关字段<code>（配置 &amp;&amp; 匹配 ⇒ 肯定：包含）</code>；</li></ul></li><li>浏览器处理响应：当浏览器接收到服务器的响应之后，检查响应头是否包含CORS相关字段：<ul><li>不包含，浏览器抛出错误</li><li>包含，服务器肯定此次预检请求，浏览器发出正式的<code>CORS</code>请求获取数据，这个正式的CORS请求的流程和简单请求一致。</li></ul></li></ul><p><img src="2.png" alt="非简单请求流程图示"></p><p>下面列出了CORS请求中会用到的协议头字段以及说明：</p><table><thead><tr><th>协议头参数</th><th>类型</th><th>说明</th><th>是否必须</th><th>备注</th></tr></thead><tbody><tr><td><code>Origin</code></td><td>请求头</td><td>该字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。</td><td>T</td><td></td></tr><tr><td><code>Access-Control-Request-Method</code></td><td>请求头</td><td>该字段用于预检请求，指名浏览器正式的CORS请求会用到的HTTP方法</td><td>T</td><td>发送预检请求时，必须包含</td></tr><tr><td><code>Access-Control-Request-Headers</code></td><td>请求头</td><td>该字段用于预检请求，指名浏览器正式的CORS请求会额外发送的头信息字段</td><td>T</td><td>发送预检请求时，必须包含</td></tr><tr><td><code>Access-Control-Allow-Origin</code></td><td>响应头</td><td>（同服务器配置字段含义）</td><td>T</td><td></td></tr><tr><td><code>Access-Control-Expose-Headers</code></td><td>响应头</td><td>该字段指明服务器允许哪些响应头可以暴露给浏览器中运行的脚本（JS），以响应跨源请求。<br />在没有额外指明的情况下，CORS请求时，XMLHttpRequest对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<br /><code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。<br/>如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。</td><td>F</td><td></td></tr><tr><td><code>Access-Control-Allow-Methods</code></td><td>响应头</td><td>（同服务器配置字段含义）</td><td>T</td><td></td></tr><tr><td><code>Access-Control-Allow-Headers</code></td><td>响应头</td><td>（同服务器配置字段含义）</td><td>F</td><td></td></tr><tr><td><code>Access-Control-Allow-Credentials</code></td><td>响应头</td><td>（同服务器配置字段含义）</td><td>F</td><td></td></tr><tr><td><code>Access-Control-Max-Age</code></td><td>响应头</td><td>（同服务器配置字段含义）</td><td>F</td><td></td></tr></tbody></table><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>JSONP 的原理就是利用 <code>&lt;script&gt;</code> 标签的 src 属性没有跨域的限制，通过指向一个需要访问的地址，由服务端返回一个预先定义好的 Javascript 函数的调用，并且将服务器数据以该函数参数的形式传递过来，此方法需要前后端配合完成。</p><ul><li><code>script</code>标签 src可跨域</li><li>将回调方法作为get参数传给后端</li><li>后端返回一个js，调用这个回调，并把数据传给回调</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//定义获取数据的回调方法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getData</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;<br><br><span class="hljs-comment">// 创建一个script标签，并且告诉后端回调函数名叫 getData</span><br><span class="hljs-keyword">var</span> body = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;body&#x27;</span>)[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">var</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">gerElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br>script.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;text/javasctipt&#x27;</span>;<br>script.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;demo.js?callback=getData&#x27;</span>;<br>body.<span class="hljs-title function_">appendChild</span>(script);<br><br><span class="hljs-comment">//script 加载完毕之后从页面中删除,否则每次点击生成许多script标签</span><br>script.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(script);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="服务器代理"><a href="#服务器代理" class="headerlink" title="服务器代理"></a>服务器代理</h2><p>浏览器对网络请求做了处理，所以通过从浏览器端发送的请求都会有跨域限制，但是服务器请求服务器就不存在这个问题。所以可以搭建一个代理服务器，将前端资源和代理服务器部署到一个域下，然后前端请求代理服务器，再通过代理服务器转发请求，从而实现请求跨域。</p><h2 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h2><p>该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式。</p><p>只需要给两个页面都添加 <code>document.domain = &#39;test.com&#39;</code>，通过在 <code>a.test.com</code> 创建一个 <code>iframe</code>，去控制 <code>iframe</code> 的 <code>window</code>，从而进行交互。</p><h2 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h2><p>window.postMessage 是一个 HTML5 的 api，允许两个窗口之间进行跨域发送消息。</p><p>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 发送消息端</span><br><span class="hljs-keyword">var</span> receiver = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;receiver&#x27;</span>).<span class="hljs-property">contentWindow</span>;<br><span class="hljs-keyword">var</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;send&#x27;</span>);<br>btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    e.<span class="hljs-title function_">preventDefault</span>();<br>    <span class="hljs-keyword">var</span> val = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;text&#x27;</span>).<span class="hljs-property">value</span>;<br>    receiver.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&quot;Hello &quot;</span>+val+<span class="hljs-string">&quot;！&quot;</span>, <span class="hljs-string">&quot;http://res.42du.cn&quot;</span>);<br>&#125;); <br><br><span class="hljs-comment">// 接收消息端</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;message&quot;</span>, receiveMessage, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">receiveMessage</span>(<span class="hljs-params">event</span>)&#123;<br>  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">origin</span> !== <span class="hljs-string">&quot;http://www.42du.cn&quot;</span>)<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="需要跨域请求的情况"><a href="#需要跨域请求的情况" class="headerlink" title="需要跨域请求的情况"></a>需要跨域请求的情况</h1><ul><li>由 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a> 或者 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch</a> 发起的跨源 HTTP 请求。</li><li>Web 字体 (CSS 中通过<code>@font-face</code>使用跨源字体资源)，<a href="https://www.w3.org/TR/css-fonts-3/#font-fetching-requirements">因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用</a>。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL">WebGL 贴图</a></li><li>使用 <code>drawImage</code> 将 <code>Images/video</code> 画面绘制到 <code>canvas</code></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://juejin.im/post/6844903816060469262">彻底理解浏览器的跨域</a><br><a href="https://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 详解</a><br><a href="https://segmentfault.com/a/1190000004322487">你真的会使用XMLHttpRequest吗？</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">跨源资源共享（CORS）</a><br><a href="https://juejin.cn/post/6844903767226351623">九种跨域方式实现原理（完整版）</a></p>]]></content>
    
    
    <categories>
      
      <category>浏览器原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>&lt;span class=&quot;label label-primary&quot;&gt;浏览器安全&lt;/span&gt; &lt;span class=&quot;label label-primary&quot;&gt;CORS&lt;/span&gt;</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BFC</title>
    <link href="/2023/02/28/BFC/"/>
    <url>/2023/02/28/BFC/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是BFC？"><a href="#什么是BFC？" class="headerlink" title="什么是BFC？"></a>什么是BFC？</h1><p>在了解BFC之前，先了解一下FC的定义。<strong>FC</strong>（Formatting Context 格式化上下文），FC指定了页面中一块独立区域的渲染规则，这个渲染规则可以理解为内部元素的布局规则。不同的FC有不同的规则定义。</p><p>目前网页中几种FC的分类：</p><ul><li><strong>IFC</strong>（Inline Formatting Context）：行级格式化上下文</li><li><strong>BFC</strong>（Block Formatting Context）：块格式化上下文<ul><li>更多关于IFC / BFC的定义参考：<a href="https://www.w3.org/TR/CSS2/visuren.html#normal-flow">CSS 2.1 Visual formatting model：Section 9.4</a></li></ul></li><li><strong>FFC</strong>（Flex Formatting Context）：自适应格式化上下文<ul><li>更多关于自适应布局的定义参考 ：<a href="https://drafts.csswg.org/css-flexbox-1/#flex-formatting-context">Flexible Box Layout Module Level 1</a></li></ul></li><li><strong>GFC</strong>（Grid Formatting Context）：网格布局格式化上下文</li></ul><h1 id="BFC的触发条件"><a href="#BFC的触发条件" class="headerlink" title="BFC的触发条件"></a>BFC的触发条件</h1><p>在以下几种情况下，会触发形成BFC：</p><ul><li>根元素<code>HTML</code></li><li>浮动元素：<code>float</code> 属性不为<code>none</code></li><li><code>position</code>定位：设置为 <code>absolute</code> 、<code>fixed</code></li><li><code>overflow</code> 属性：设置为非<code>visible</code> 、<code>clip</code>的<strong>块</strong>元素</li><li><code>display</code>属性：<ul><li>设置为 <code>table</code>类型：<ul><li><code>table</code>：对应<code>&lt;table&gt;</code></li><li><code>table-caption</code>：HTML 表格标题默认值</li><li><code>table-row</code>：对应<code>&lt;tr&gt;</code></li><li><code>table-row-group</code>：<code>&lt;tbody&gt;</code></li><li><code>table-header-group</code>：<code>&lt;thead&gt;</code></li><li><code>table-footer-group</code>：<code>&lt;tfoot&gt;</code></li><li><code>table-cell</code>：HTML 表格单元格默认值</li><li><code>inline-table</code></li></ul></li><li>设置为<code>inline-block</code></li><li>设置为<code>flow-root</code></li><li>设置为<code>flex</code>类型：父元素display属性为<code>flex</code> 或者 <code>inline-flex</code>，其子元素内部的布局规则为BFC（其子元素本身非<code>table</code>类型、<code>grid</code>类型、<code>flex</code>类型）</li><li>设置为<code>grid</code>类型：父元素display属性为<code>gird</code> 或者 <code>inline-grid</code>，其子元素内部的布局规则为BFC（其子元素本身非<code>table</code>类型、<code>grid</code>类型、<code>flex</code>类型）</li></ul></li><li><code>contain</code> 属性：<ul><li><code>layout</code></li><li><code>content</code></li><li><code>paint</code></li></ul></li><li><em>多列容器（暂时没有搞懂）</em></li></ul><h1 id="BFC渲染规则"><a href="#BFC渲染规则" class="headerlink" title="BFC渲染规则"></a>BFC渲染规则</h1><ul><li>渲染隔离：一个BFC是页面上的一个隔离的独立容器，容器里面的子元素的排版布局不会直接影响到外面的元素（可能通过子元素影响父元素容器大小间接影响外部元素布局）。</li><li>容器大小计算：区域大小由内部元素的边界确定：<ul><li>即一个BFC容器会包裹所有的子元素块，无论该子元素是否是浮动元素，所以BFC的高度计算会包含<code>float</code>元素。</li></ul></li><li><code>margin</code>重叠：<ul><li>在同一个BFC中，相邻元素形成的<code>box</code>的上下<code>margin</code>产生重叠；</li><li>但在不同的BFC中，各自的子元素的<code>margin</code>不重叠。</li></ul></li><li>排布方向：<ul><li>内部的子元素由上到下依次排布。</li><li>内部子元素根据书写方向（<code>writing-mode</code>）确定从左开始排布还是从右开始排布。</li><li>起始位置的子元素的<code>margin</code>紧贴父容器的<code>border</code>（只有起始方向的<code>margin</code>紧贴）。</li></ul></li><li>当前的BFC不与外部的<code>float box</code>重叠。</li></ul><h1 id="实例验证"><a href="#实例验证" class="headerlink" title="实例验证"></a>实例验证</h1><h2 id="1、容器大小计算"><a href="#1、容器大小计算" class="headerlink" title="1、容器大小计算"></a>1、容器大小计算</h2><p>区域大小由内部元素的边界确定，高度计算包含<code>float</code>元素<br>当不给父容器设置高度的情况下，查看父容器的高度是如何计算的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-comment">&lt;!-- bfc的高度计算会包含float子元素 可以用作清除内部浮动 --&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>BFC<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.bfc</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">display</span>: flow-root;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.container</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#939393</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background</span>: <span class="hljs-number">#f2f2f2</span>;</span><br><span class="language-css">            <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.float</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#e98f53</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.child</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">40px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">40px</span>;</span><br><span class="language-css">        &#125;  </span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 父容器非BFC --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;float child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 父容器是BFC --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bfc container&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin-top: 100px&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;float child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="1.png"></p><h2 id="2、margin重叠"><a href="#2、margin重叠" class="headerlink" title="2、margin重叠"></a>2、margin重叠</h2><p>同一个BFC中相邻的元素上下<code>margin</code>重叠<br>当给子元素设置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>BFC<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.bfc</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">display</span>: flow-root;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.container</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#939393</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background</span>: <span class="hljs-number">#f2f2f2</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">       <span class="hljs-selector-class">.bfc-child</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">40px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">margin</span>: <span class="hljs-number">30px</span> <span class="hljs-number">0</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ccc</span>;</span><br><span class="language-css">       &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bfc container&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bfc-child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bfc container&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bfc-child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bfc-child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="2.png"></p><p>相反，当父容器非BFC时，所有子元素（无论是否是平级）都会发生上下<code>margin</code>重叠。<br>将上面父容器的display属性改为<code>contents</code> ：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.bfc</span>&#123;<br><span class="hljs-attribute">display</span>: contents;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="3.png"></p><blockquote><p>contents<br>These elements don’t produce a specific box by themselves. They are replaced by their pseudo-box and their child boxes. </p><p>当设置元素为content时，该元素不会生成自己的box，而是会被子元素生成的box取代。</p></blockquote><p>会发现此时处于两个父级下的子元素，上下<code>margin</code>也会发生重叠。此时因为父容器不是BFC，没有渲染隔离，所有子元素生成的盒子被平铺到了最外层。</p><h2 id="3、当前的BFC不与外部的float-box重叠"><a href="#3、当前的BFC不与外部的float-box重叠" class="headerlink" title="3、当前的BFC不与外部的float box重叠"></a>3、当前的BFC不与外部的<code>float box</code>重叠</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>BFC<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">     <span class="hljs-selector-class">.bfc</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">display</span>: flow-root;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.float</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#e98f53</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">40px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">40px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.aside</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#696fa7</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 规则三：bfc区域不和浮动元素重叠 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;float&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;aside&quot;</span>&gt;</span>该元素非BFC，则该元素和小黄块重叠<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;float&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;aside bfc&quot;</span>&gt;</span>该元素BFC，则该元素和小黄块不重叠<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><img src="4.png"></p><h1 id="BFC的作用"><a href="#BFC的作用" class="headerlink" title="BFC的作用"></a>BFC的作用</h1><p>利用BFC的渲染规则，可以实现以下几个功能：</p><ul><li>自适应两栏布局</li><li>阻止元素被浮动元素覆盖</li><li>清除内部浮动</li><li>阻止<code>margin</code>重叠：分属于不同的BFC时不发生重叠</li></ul><p>后面三条在实验中以及实现过了，但是针对第一条，如何利用BFC实现两栏布局呢？</p><p>利用2个特性：</p><ol><li>块级元素<code>width:auto</code> 时，会自动拉伸至父元素左右边界处（横向占满）。</li><li>BFC渲染规则：当前的BFC不与外部的<code>float box</code>重叠。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>BFC<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.bfc</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">display</span>: flow-root;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"><span class="hljs-selector-class">.container</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#939393</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background</span>: <span class="hljs-number">#f2f2f2</span>;</span><br><span class="language-css">            <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.main</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background</span>: <span class="hljs-number">#ddd</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.float-aside</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">            <span class="hljs-attribute">background</span>: <span class="hljs-number">#757575</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 利用bfc区域不和浮动元素重叠的特性，实现自适应两栏布局 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bfc container&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;float-aside&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bfc main&quot;</span>&gt;</span>设置float的宽度，然后给相邻的bfc元素不设置宽度，块级元素默认宽度为auto，那么该bfc元素会自动延伸到父元素的最右端<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="5.png"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://juejin.cn/post/6844903476774830094">[布局概念] 关于CSS-BFC深入理解</a><br><a href="https://drafts.csswg.org/css-display/#formatting-context">CSS Display Module Level 4</a></p>]]></content>
    
    
    <categories>
      
      <category>Web前端</category>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>&lt;span class=&quot;label label-primary&quot;&gt;BFC&lt;/span&gt; &lt;span class=&quot;label label-primary&quot;&gt;CSS渲染&lt;/span&gt;</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>this指针和箭头函数</title>
    <link href="/2023/02/28/this%E6%8C%87%E9%92%88/"/>
    <url>/2023/02/28/this%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是this？"><a href="#什么是this？" class="headerlink" title="什么是this？"></a>什么是<code>this</code>？</h1><p><code>this</code>是一个引用，指向当前函数执行的<strong>上下文对象</strong>。是在运行时绑定的。</p><blockquote><p>💡 执行上下文<br>当 JS 引擎解析到可执行代码片段（通常是函数调用阶段）的时候，就会先做一些执行前的准备工作，这个 “准备工作”，就叫做 “<strong>执行上下文(execution context 简称 EC)</strong>“ 或者也可以叫做 <strong>执行环境</strong>。<br>执行上下文 为我们的可执行代码块提供了执行前的必要准备工作，例如变量对象的定义、作用域链的扩展、提供调用者的对象引用等信息。</p></blockquote><p><img src="this.png" alt="this.png"></p><h1 id="this的绑定规则"><a href="#this的绑定规则" class="headerlink" title="this的绑定规则"></a>this的绑定规则</h1><p>优先级：<code>new</code> &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定</p><h2 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h2><p>当函数被<strong>独立调用</strong>时，默认函数的<code>this</code>指向<strong>全局对象</strong>，此时在浏览器运行环境中，能获取到全局对象下使用<a href="https://www.notion.so/c80e2b095b104f7f8c53c745185de9d0">var操作符定义的变量，但不能获取到let定义的变量</a>。</p><p>当在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode">严格模式</a>下时，<code>this</code>不能获取到全局对象下的变量。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 浏览器运行环境下</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;name is: &#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;age is: &#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;kira&#x27;</span>;<br><span class="hljs-keyword">let</span> age = <span class="hljs-number">3</span>;<br><br><span class="hljs-title function_">foo</span>();<br><span class="hljs-comment">// name is:  kira</span><br><span class="hljs-comment">// age is:  undefined</span><br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 严格模式</span><br><span class="hljs-meta">&quot;use strict&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;name is: &#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;age is: &#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);<br><br>&#125;<br><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;kira&#x27;</span>;<br><span class="hljs-keyword">let</span> age = <span class="hljs-number">3</span>;<br><br><span class="hljs-title function_">foo</span>();<br><span class="hljs-comment">/* </span><br><span class="hljs-comment">   Uncaught TypeError: Cannot read property &#x27;name&#x27; of undefined at foo </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h2><p>使用<strong>对象调用</strong>时，函数的<code>this</code>会指向当前调用的对象。</p><p><code>this</code> 指向链式调用的最后一层</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;name is: &#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;age is: &#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);<br><br>&#125;<br><br><span class="hljs-keyword">const</span> person = &#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;kira&#x27;</span>,<br><span class="hljs-attr">age</span>: <span class="hljs-number">3</span>,<br><span class="hljs-attr">foo</span>: foo<br>&#125;<br><br>person.<span class="hljs-title function_">foo</span>();<br><span class="hljs-comment">// name is:  kira</span><br><span class="hljs-comment">// age is:  3</span><br></code></pre></td></tr></table></figure><p><strong>还需要注意的是隐式绑定丢失：</strong></p><p>当把对象 <code>o</code> 的方法 <code>o.method</code> 赋值给一个变量 <code>fn</code>，然后再调用这个变量 <code>fn</code> 的时候，<code>this</code> 不会指向这个对象 <code>o</code>，而会指向全局对象。<br>这是因为，赋值语句是静态执行，而 <code>this</code> 绑定是动态绑定。<br>当我们把一个函数，无论是【对象的方法】还是【普通函数】赋值给一个变量的时候，实际上我们是把当前函数的引用（也就是函数存放的地址）赋值给这个变量。<br>而当我们真正调用的时候，才会绑定 <code>this</code> ，此时对于这个函数变量来说，就是以独立的形式被调用了，所以此时 <code>this</code> 为默认绑定。</p><p>这种隐式丢失的情况有2种：</p><ol><li>直接把对象方法赋值给一个变量</li><li>把一个对象方法作为参数传给另一个函数，这里因为存在给参数变量隐式赋值的步骤，所以也会丢失</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> obj = &#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;kira&#x27;</span>,<br><span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;name is: &#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;window&#x27;</span>;<br><span class="hljs-keyword">var</span> windowFoo = obj.<span class="hljs-property">foo</span>;  <span class="hljs-comment">// 隐式丢失：情况1</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">showFoo</span>(<span class="hljs-params">fn</span>)&#123;<br><span class="hljs-title function_">fn</span>();  <span class="hljs-comment">// 隐式丢失：情况2</span><br>&#125;<br><br>obj.<span class="hljs-title function_">foo</span>();<br><span class="hljs-title function_">windowFoo</span>();<br><span class="hljs-title function_">showFoo</span>(obj.<span class="hljs-property">foo</span>);<br><span class="hljs-built_in">setTimeout</span>(obj.<span class="hljs-property">foo</span>, <span class="hljs-number">1000</span>) <span class="hljs-comment">// 隐式丢失： 情况2</span><br><br><span class="hljs-comment">// name is:  kira</span><br><span class="hljs-comment">// name is:  window</span><br><span class="hljs-comment">// name is:  window</span><br><span class="hljs-comment">// name is:  window</span><br></code></pre></td></tr></table></figure><h2 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h2><p>显示绑定是指给函数直接指定上下文参数（<code>context</code>）。显示绑定有4种方式：</p><ul><li><p><code>call</code></p></li><li><p><code>apply</code></p></li><li><p><code>bind</code> ：关于<code>bind</code>绑定，要注意以下2点：</p><ul><li>使用<code>bind</code>绑定过的函数，只有使用<code>new</code>方法调用才可以更改函数的<code>this</code>值</li></ul></li><li><p><code>js</code>内置函数中的参数传递：例如数组原型方法中的可选参数<code>context</code>，会把<strong>回调函数</strong> [ 非箭头函数 ] 的<code>this</code>指向传入的<code>context</code></p></li><li><p>这4种方式中，关于指定的<code>context</code> 的类型，<code>this</code>的指向：</p><ul><li><code>undefined</code>  <code>null</code> : 指向全局对象</li><li><code>string</code> <code>number</code> <code>bool</code> ：指向当前值类型的原型实例</li><li><code>function</code>：指向函数本身</li><li>引用类型 <code>object</code> <code>array</code>：指向引用对象</li></ul></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// js中内置函数参数传递</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;context&#x27;</span>];<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;this&#x27;</span>, <span class="hljs-variable language_">this</span>)&#125;, &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;非箭头函数&#x27;</span>&#125;);<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;this&#x27;</span>, <span class="hljs-variable language_">this</span>)&#125;, &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;箭头函数&#x27;</span>&#125;);<br></code></pre></td></tr></table></figure><p><img src="1.png" alt="显示绑定：数组传入上下文"></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 传入各种类型的context</span><br><span class="hljs-comment">// call, apply, bind, 内置函数中的参数传递同理</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getContext</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;当前函数的上下文对象 this是：&#x27;</span>, <span class="hljs-variable language_">this</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fnContext</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;fnContext函数作为上下文对象&#x27;</span>)<br>&#125;<br><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;array&#x27;</span>, <span class="hljs-string">&#x27;context&#x27;</span>];<br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;objContext&#x27;</span><br>&#125;<br><br>getContext.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// window</span><br>getContext.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// window</span><br>getContext.<span class="hljs-title function_">call</span>(<span class="hljs-string">&#x27;string&#x27;</span>) <span class="hljs-comment">// String</span><br>getContext.<span class="hljs-title function_">call</span>(<span class="hljs-number">123</span>) <span class="hljs-comment">// Number</span><br>getContext.<span class="hljs-title function_">call</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// Boolean</span><br>getContext.<span class="hljs-title function_">call</span>(fnContext) <span class="hljs-comment">// fnContext</span><br>getContext.<span class="hljs-title function_">call</span>(arr) <span class="hljs-comment">// arr</span><br>getContext.<span class="hljs-title function_">call</span>(obj) <span class="hljs-comment">// obj</span><br></code></pre></td></tr></table></figure><p>控制台打印结果：<br><img src="2.png" alt="传入各种类型的上下文"></p><h2 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h2><p><code>new</code> 操作符的步骤<br><img src="3.png" alt="new操作步骤"></p><p>注意，使用<code>new</code>创建对象时，如果构造函数返回的是引用类型，则<code>new</code>操作生成的对象会被这个引用类型取代。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params">value</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;foo&#x27;</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;object&#x27;</span>&#125;;<br><span class="hljs-keyword">let</span> arr = [];<br><span class="hljs-keyword">let</span> fn = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;this is a function&#x27;</span>)&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(<span class="hljs-literal">null</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(<span class="hljs-literal">undefined</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(<span class="hljs-number">1</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(<span class="hljs-literal">true</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(<span class="hljs-string">&#x27;string&#x27;</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(obj), obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(arr), arr);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(fn), fn);<br></code></pre></td></tr></table></figure><p><img src="7.png" alt="new创建对象，构造函数返回不同类型时的结果"></p><h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><h2 id="箭头函数this对象"><a href="#箭头函数this对象" class="headerlink" title="箭头函数this对象"></a>箭头函数<code>this</code>对象</h2><p>箭头函数没有<code>this</code>对象，或者说箭头函数的<code>this</code>对象早在词法分析时就已经被“绑定”为上层词法作用域（也就是函数声明时所在的作用域）的<code>this</code>了。</p><p>例如下面这个例子：</p><ol><li>当<code>outer</code>调用时，<code>this</code>对象被绑定为<code>obj</code>；</li><li>因为箭头函数是在<code>outer</code>方法中声明的，所以此时返回的箭头函数的<code>this</code>被“绑定”为<code>outer</code>实际执行时的<code>this</code>对象。所以无论该箭头函数在何处被调用，都不会发生改变。</li><li>而如果返回的是普通函数，那么该函数的<code>this</code>对象就会根据调用方式而发生变化。<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-title function_">arrowFn</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;当前在global环境下调用箭头函数，this：&#x27;</span>, <span class="hljs-variable language_">this</span>)<br>    &#125;<br>    <span class="hljs-keyword">let</span> fn = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;当前在global环境下调用普通函数，this：&#x27;</span>, <span class="hljs-variable language_">this</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> [arrowFn, fn];<br>&#125;<br><br><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj&#x27;</span> &#125;;<br><span class="hljs-keyword">let</span> obj1 = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj1&#x27;</span>&#125;;<br><span class="hljs-comment">// 将outer的this绑定为obj</span><br><span class="hljs-keyword">let</span> [arrowFn, fn] = outer.<span class="hljs-title function_">call</span>(obj);<br><span class="hljs-title function_">arrowFn</span>();<br><span class="hljs-title function_">fn</span>();<br><br><span class="hljs-comment">//绑定this</span><br>arrowFn.<span class="hljs-title function_">call</span>(obj1);<br>fn.<span class="hljs-title function_">call</span>(obj1);<br></code></pre></td></tr></table></figure>控制台打印</li></ol><p><img src="8.png" alt="箭头函数与普通函数的this值对比"></p><h2 id="箭头函数与普通函数的区别"><a href="#箭头函数与普通函数的区别" class="headerlink" title="箭头函数与普通函数的区别"></a>箭头函数与普通函数的区别</h2><p>（1）箭头函数的 <code>this</code> 值等于<strong>箭头函数</strong>在<strong>声明</strong>时所在的<strong>上层函数</strong>在<strong>调用</strong>时所绑定的<code>this</code>值。示例如上。</p><p>（2）箭头函数没有自己的 <code>this</code> <code>prototype</code> <code>arguments</code> <code>super</code> 和 <code>new.target</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 箭头函数和普通函数</span><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">arrowFn</span> = (<span class="hljs-params">arg1</span>) =&gt; &#123;&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">arg1</span>)&#123;&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">dir</span>(arrowFn)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">dir</span>(fn)<br></code></pre></td></tr></table></figure><p>控制台打印：</p><p><img src="4.png" alt="箭头函数没有this等属性"></p><p>（3）箭头函数的不能用作构造函数</p><p><img src="5.png" alt="new一个箭头函数会报错"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><p>对 <code>this</code> 对象的理解<br>this 是一个引用，指向当前函数的调用对象。对于非箭头函数来说，</p><ol><li>当独立调用函数时，<code>this</code>指向全局对象；</li><li>当函数作为对象的方法调用时，<code>this</code>指向这个当前对象；</li><li>当函数以<code>call</code>，<code>apply</code>，<code>bind</code>调用，或者对于一些内置的函数例如数组的<code>forEach</code>，<code>map</code>方法，传入指定的上下文对象时，<code>this</code>指向绑定的上下文对象。其中根据传入的上下文对象类型，<code>this</code>会指向不同的对象：<ol><li>如果传入是<code>null</code>或者<code>undefined</code>，则this指向全局对象；</li><li>如果传入的是<code>number</code>, <code>string</code>, <code>boolean</code>值，js会将当前值实例化，并将<code>this</code>指向其实例。（根据当前基本类型的原型对象创建实例，并将当前值作为value参数传入构造函数）；</li><li>如果传入的是函数，则会指向函数对象本身；</li><li>如果传入的是引用类型，则直接指向该引用对象。</li></ol></li><li>如果用<code>new</code>调用函数，则<code>this</code>会指向该函数原型的实例对象。</li></ol></li><li><p>箭头函数和普通函数的区别？<br>箭头函数没有自己的 <code>this</code> <code>arguments</code> <code>prototype</code> <code>super</code>和<code>new.target</code> 以及箭头函数不能作为构造函数使用</p></li><li><p>箭头函数的 <code>this</code> 指向哪里？<br>箭头函数的this等于其函数<strong>声明</strong>时所在的<strong>上级函数被调用</strong>时的<code>this</code></p></li><li><p>如果<code>new</code> 一个箭头函数，会发生什么？<br>会报错，提示箭头函数没有构造函数</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Web前端</category>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>&lt;span class=&quot;label label-primary&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;label label-primary&quot;&gt;箭头函数&lt;/span&gt;</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
